/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoals{}).Type1()):                                                           ApplicationSpecConversionGoalsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalDestination{}).Type1()):                                            ApplicationSpecConversionGoalsGoalDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalUserAction{}).Type1()):                                             ApplicationSpecConversionGoalsGoalUserActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitDuration{}).Type1()):                                          ApplicationSpecConversionGoalsGoalVisitDurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitNumAction{}).Type1()):                                         ApplicationSpecConversionGoalsGoalVisitNumActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCustomActionApdexSettings{}).Type1()):                                                 ApplicationSpecCustomActionApdexSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecLoadActionApdexSettings{}).Type1()):                                                   ApplicationSpecLoadActionApdexSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMetaDataCaptureSettings{}).Type1()):                                                   ApplicationSpecMetaDataCaptureSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettings{}).Type1()):                                                        ApplicationSpecMonitoringSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}).Type1()):                           ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}).Type1()):    ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}).Type1()):       ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}).Type1()): ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}).Type1()):                              ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}).Type1()):                  ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCapture{}).Type1()):                                          ApplicationSpecMonitoringSettingsContentCaptureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}).Type1()):                    ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}).Type1()):                           ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}).Type1()):                  ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}).Type1()):                            ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}).Type1()):                ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}).Type1()):                              ApplicationSpecMonitoringSettingsJavascriptFrameworkSupportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}).Type1()):                                ApplicationSpecMonitoringSettingsJavascriptInjectionRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecSessionReplayConfig{}).Type1()):                                                       ApplicationSpecSessionReplayConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionProperties{}).Type1()):                                            ApplicationSpecUserActionAndSessionPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionPropertiesProperty{}).Type1()):                                    ApplicationSpecUserActionAndSessionPropertiesPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettings{}).Type1()):                                                  ApplicationSpecUserActionNamingSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}).Type1()):                           ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}).Type1()):             ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}).Type1()):                             ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}).Type1()):               ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholders{}).Type1()):                                      ApplicationSpecUserActionNamingSettingsPlaceholdersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}).Type1()):            ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}).Type1()):                              ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}).Type1()):                ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserTags{}).Type1()):                                                                  ApplicationSpecUserTagsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecWaterfallSettings{}).Type1()):                                                         ApplicationSpecWaterfallSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecXhrActionApdexSettings{}).Type1()):                                                    ApplicationSpecXhrActionApdexSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoals{}).Type1()):                                                           ApplicationSpecConversionGoalsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalDestination{}).Type1()):                                            ApplicationSpecConversionGoalsGoalDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalUserAction{}).Type1()):                                             ApplicationSpecConversionGoalsGoalUserActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitDuration{}).Type1()):                                          ApplicationSpecConversionGoalsGoalVisitDurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitNumAction{}).Type1()):                                         ApplicationSpecConversionGoalsGoalVisitNumActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCustomActionApdexSettings{}).Type1()):                                                 ApplicationSpecCustomActionApdexSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecLoadActionApdexSettings{}).Type1()):                                                   ApplicationSpecLoadActionApdexSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMetaDataCaptureSettings{}).Type1()):                                                   ApplicationSpecMetaDataCaptureSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettings{}).Type1()):                                                        ApplicationSpecMonitoringSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}).Type1()):                           ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}).Type1()):    ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}).Type1()):       ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}).Type1()): ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}).Type1()):                              ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}).Type1()):                  ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCapture{}).Type1()):                                          ApplicationSpecMonitoringSettingsContentCaptureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}).Type1()):                    ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}).Type1()):                           ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}).Type1()):                  ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}).Type1()):                            ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}).Type1()):                ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}).Type1()):                              ApplicationSpecMonitoringSettingsJavascriptFrameworkSupportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}).Type1()):                                ApplicationSpecMonitoringSettingsJavascriptInjectionRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecSessionReplayConfig{}).Type1()):                                                       ApplicationSpecSessionReplayConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionProperties{}).Type1()):                                            ApplicationSpecUserActionAndSessionPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionPropertiesProperty{}).Type1()):                                    ApplicationSpecUserActionAndSessionPropertiesPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettings{}).Type1()):                                                  ApplicationSpecUserActionNamingSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}).Type1()):                           ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}).Type1()):             ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}).Type1()):                             ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}).Type1()):               ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholders{}).Type1()):                                      ApplicationSpecUserActionNamingSettingsPlaceholdersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}).Type1()):            ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}).Type1()):                              ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}).Type1()):                ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserTags{}).Type1()):                                                                  ApplicationSpecUserTagsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecWaterfallSettings{}).Type1()):                                                         ApplicationSpecWaterfallSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecXhrActionApdexSettings{}).Type1()):                                                    ApplicationSpecXhrActionApdexSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ApplicationSpecConversionGoalsCodec struct {
}

func (ApplicationSpecConversionGoalsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecConversionGoals)(ptr) == nil
}

func (ApplicationSpecConversionGoalsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecConversionGoals)(ptr)
	var objs []ApplicationSpecConversionGoals
	if obj != nil {
		objs = []ApplicationSpecConversionGoals{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoals{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecConversionGoalsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecConversionGoals)(ptr) = ApplicationSpecConversionGoals{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecConversionGoals

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoals{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecConversionGoals)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecConversionGoals)(ptr) = ApplicationSpecConversionGoals{}
			}
		} else {
			*(*ApplicationSpecConversionGoals)(ptr) = ApplicationSpecConversionGoals{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecConversionGoals

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoals{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecConversionGoals)(ptr) = obj
		} else {
			*(*ApplicationSpecConversionGoals)(ptr) = ApplicationSpecConversionGoals{}
		}
	default:
		iter.ReportError("decode ApplicationSpecConversionGoals", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecConversionGoalsGoalDestinationCodec struct {
}

func (ApplicationSpecConversionGoalsGoalDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecConversionGoalsGoalDestination)(ptr) == nil
}

func (ApplicationSpecConversionGoalsGoalDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecConversionGoalsGoalDestination)(ptr)
	var objs []ApplicationSpecConversionGoalsGoalDestination
	if obj != nil {
		objs = []ApplicationSpecConversionGoalsGoalDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecConversionGoalsGoalDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecConversionGoalsGoalDestination)(ptr) = ApplicationSpecConversionGoalsGoalDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecConversionGoalsGoalDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecConversionGoalsGoalDestination)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecConversionGoalsGoalDestination)(ptr) = ApplicationSpecConversionGoalsGoalDestination{}
			}
		} else {
			*(*ApplicationSpecConversionGoalsGoalDestination)(ptr) = ApplicationSpecConversionGoalsGoalDestination{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecConversionGoalsGoalDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecConversionGoalsGoalDestination)(ptr) = obj
		} else {
			*(*ApplicationSpecConversionGoalsGoalDestination)(ptr) = ApplicationSpecConversionGoalsGoalDestination{}
		}
	default:
		iter.ReportError("decode ApplicationSpecConversionGoalsGoalDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecConversionGoalsGoalUserActionCodec struct {
}

func (ApplicationSpecConversionGoalsGoalUserActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecConversionGoalsGoalUserAction)(ptr) == nil
}

func (ApplicationSpecConversionGoalsGoalUserActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecConversionGoalsGoalUserAction)(ptr)
	var objs []ApplicationSpecConversionGoalsGoalUserAction
	if obj != nil {
		objs = []ApplicationSpecConversionGoalsGoalUserAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalUserAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecConversionGoalsGoalUserActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecConversionGoalsGoalUserAction)(ptr) = ApplicationSpecConversionGoalsGoalUserAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecConversionGoalsGoalUserAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalUserAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecConversionGoalsGoalUserAction)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecConversionGoalsGoalUserAction)(ptr) = ApplicationSpecConversionGoalsGoalUserAction{}
			}
		} else {
			*(*ApplicationSpecConversionGoalsGoalUserAction)(ptr) = ApplicationSpecConversionGoalsGoalUserAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecConversionGoalsGoalUserAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalUserAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecConversionGoalsGoalUserAction)(ptr) = obj
		} else {
			*(*ApplicationSpecConversionGoalsGoalUserAction)(ptr) = ApplicationSpecConversionGoalsGoalUserAction{}
		}
	default:
		iter.ReportError("decode ApplicationSpecConversionGoalsGoalUserAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecConversionGoalsGoalVisitDurationCodec struct {
}

func (ApplicationSpecConversionGoalsGoalVisitDurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) == nil
}

func (ApplicationSpecConversionGoalsGoalVisitDurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr)
	var objs []ApplicationSpecConversionGoalsGoalVisitDuration
	if obj != nil {
		objs = []ApplicationSpecConversionGoalsGoalVisitDuration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitDuration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecConversionGoalsGoalVisitDurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) = ApplicationSpecConversionGoalsGoalVisitDuration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecConversionGoalsGoalVisitDuration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitDuration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) = ApplicationSpecConversionGoalsGoalVisitDuration{}
			}
		} else {
			*(*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) = ApplicationSpecConversionGoalsGoalVisitDuration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecConversionGoalsGoalVisitDuration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitDuration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) = obj
		} else {
			*(*ApplicationSpecConversionGoalsGoalVisitDuration)(ptr) = ApplicationSpecConversionGoalsGoalVisitDuration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecConversionGoalsGoalVisitDuration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecConversionGoalsGoalVisitNumActionCodec struct {
}

func (ApplicationSpecConversionGoalsGoalVisitNumActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) == nil
}

func (ApplicationSpecConversionGoalsGoalVisitNumActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr)
	var objs []ApplicationSpecConversionGoalsGoalVisitNumAction
	if obj != nil {
		objs = []ApplicationSpecConversionGoalsGoalVisitNumAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitNumAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecConversionGoalsGoalVisitNumActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) = ApplicationSpecConversionGoalsGoalVisitNumAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecConversionGoalsGoalVisitNumAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitNumAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) = ApplicationSpecConversionGoalsGoalVisitNumAction{}
			}
		} else {
			*(*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) = ApplicationSpecConversionGoalsGoalVisitNumAction{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecConversionGoalsGoalVisitNumAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecConversionGoalsGoalVisitNumAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) = obj
		} else {
			*(*ApplicationSpecConversionGoalsGoalVisitNumAction)(ptr) = ApplicationSpecConversionGoalsGoalVisitNumAction{}
		}
	default:
		iter.ReportError("decode ApplicationSpecConversionGoalsGoalVisitNumAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecCustomActionApdexSettingsCodec struct {
}

func (ApplicationSpecCustomActionApdexSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecCustomActionApdexSettings)(ptr) == nil
}

func (ApplicationSpecCustomActionApdexSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecCustomActionApdexSettings)(ptr)
	var objs []ApplicationSpecCustomActionApdexSettings
	if obj != nil {
		objs = []ApplicationSpecCustomActionApdexSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCustomActionApdexSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecCustomActionApdexSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecCustomActionApdexSettings)(ptr) = ApplicationSpecCustomActionApdexSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecCustomActionApdexSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCustomActionApdexSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecCustomActionApdexSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecCustomActionApdexSettings)(ptr) = ApplicationSpecCustomActionApdexSettings{}
			}
		} else {
			*(*ApplicationSpecCustomActionApdexSettings)(ptr) = ApplicationSpecCustomActionApdexSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecCustomActionApdexSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCustomActionApdexSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecCustomActionApdexSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecCustomActionApdexSettings)(ptr) = ApplicationSpecCustomActionApdexSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecCustomActionApdexSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecLoadActionApdexSettingsCodec struct {
}

func (ApplicationSpecLoadActionApdexSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecLoadActionApdexSettings)(ptr) == nil
}

func (ApplicationSpecLoadActionApdexSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecLoadActionApdexSettings)(ptr)
	var objs []ApplicationSpecLoadActionApdexSettings
	if obj != nil {
		objs = []ApplicationSpecLoadActionApdexSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecLoadActionApdexSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecLoadActionApdexSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecLoadActionApdexSettings)(ptr) = ApplicationSpecLoadActionApdexSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecLoadActionApdexSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecLoadActionApdexSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecLoadActionApdexSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecLoadActionApdexSettings)(ptr) = ApplicationSpecLoadActionApdexSettings{}
			}
		} else {
			*(*ApplicationSpecLoadActionApdexSettings)(ptr) = ApplicationSpecLoadActionApdexSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecLoadActionApdexSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecLoadActionApdexSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecLoadActionApdexSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecLoadActionApdexSettings)(ptr) = ApplicationSpecLoadActionApdexSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecLoadActionApdexSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMetaDataCaptureSettingsCodec struct {
}

func (ApplicationSpecMetaDataCaptureSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMetaDataCaptureSettings)(ptr) == nil
}

func (ApplicationSpecMetaDataCaptureSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMetaDataCaptureSettings)(ptr)
	var objs []ApplicationSpecMetaDataCaptureSettings
	if obj != nil {
		objs = []ApplicationSpecMetaDataCaptureSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMetaDataCaptureSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMetaDataCaptureSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMetaDataCaptureSettings)(ptr) = ApplicationSpecMetaDataCaptureSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMetaDataCaptureSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMetaDataCaptureSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMetaDataCaptureSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMetaDataCaptureSettings)(ptr) = ApplicationSpecMetaDataCaptureSettings{}
			}
		} else {
			*(*ApplicationSpecMetaDataCaptureSettings)(ptr) = ApplicationSpecMetaDataCaptureSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMetaDataCaptureSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMetaDataCaptureSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMetaDataCaptureSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMetaDataCaptureSettings)(ptr) = ApplicationSpecMetaDataCaptureSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMetaDataCaptureSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettings)(ptr) = ApplicationSpecMonitoringSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettings)(ptr) = ApplicationSpecMonitoringSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettings)(ptr) = ApplicationSpecMonitoringSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettings)(ptr) = ApplicationSpecMonitoringSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersCodec struct {
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr)
	var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings)(ptr) = ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsBrowserRestrictionSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsBrowserRestrictionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsBrowserRestrictionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsBrowserRestrictionSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsCodec struct {
}

func (ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr)
	var objs []ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsContentCaptureCodec struct {
}

func (ApplicationSpecMonitoringSettingsContentCaptureCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsContentCapture)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsContentCaptureCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsContentCapture)(ptr)
	var objs []ApplicationSpecMonitoringSettingsContentCapture
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsContentCapture{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCapture{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsContentCaptureCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsContentCapture)(ptr) = ApplicationSpecMonitoringSettingsContentCapture{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsContentCapture

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCapture{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsContentCapture)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsContentCapture)(ptr) = ApplicationSpecMonitoringSettingsContentCapture{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCapture)(ptr) = ApplicationSpecMonitoringSettingsContentCapture{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsContentCapture

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCapture{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsContentCapture)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCapture)(ptr) = ApplicationSpecMonitoringSettingsContentCapture{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsContentCapture", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings)(ptr) = ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsCodec struct {
}

func (ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr)
	var objs []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsCodec struct {
}

func (ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr)
	var objs []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions)(ptr) = ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsJavascriptFrameworkSupportCodec struct {
}

func (ApplicationSpecMonitoringSettingsJavascriptFrameworkSupportCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsJavascriptFrameworkSupportCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr)
	var objs []ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsJavascriptFrameworkSupportCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) = ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) = ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) = ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport)(ptr) = ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecMonitoringSettingsJavascriptInjectionRulesCodec struct {
}

func (ApplicationSpecMonitoringSettingsJavascriptInjectionRulesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) == nil
}

func (ApplicationSpecMonitoringSettingsJavascriptInjectionRulesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr)
	var objs []ApplicationSpecMonitoringSettingsJavascriptInjectionRules
	if obj != nil {
		objs = []ApplicationSpecMonitoringSettingsJavascriptInjectionRules{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecMonitoringSettingsJavascriptInjectionRulesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) = ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecMonitoringSettingsJavascriptInjectionRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) = ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}
			}
		} else {
			*(*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) = ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecMonitoringSettingsJavascriptInjectionRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) = obj
		} else {
			*(*ApplicationSpecMonitoringSettingsJavascriptInjectionRules)(ptr) = ApplicationSpecMonitoringSettingsJavascriptInjectionRules{}
		}
	default:
		iter.ReportError("decode ApplicationSpecMonitoringSettingsJavascriptInjectionRules", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecSessionReplayConfigCodec struct {
}

func (ApplicationSpecSessionReplayConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecSessionReplayConfig)(ptr) == nil
}

func (ApplicationSpecSessionReplayConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecSessionReplayConfig)(ptr)
	var objs []ApplicationSpecSessionReplayConfig
	if obj != nil {
		objs = []ApplicationSpecSessionReplayConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecSessionReplayConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecSessionReplayConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecSessionReplayConfig)(ptr) = ApplicationSpecSessionReplayConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecSessionReplayConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecSessionReplayConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecSessionReplayConfig)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecSessionReplayConfig)(ptr) = ApplicationSpecSessionReplayConfig{}
			}
		} else {
			*(*ApplicationSpecSessionReplayConfig)(ptr) = ApplicationSpecSessionReplayConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecSessionReplayConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecSessionReplayConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecSessionReplayConfig)(ptr) = obj
		} else {
			*(*ApplicationSpecSessionReplayConfig)(ptr) = ApplicationSpecSessionReplayConfig{}
		}
	default:
		iter.ReportError("decode ApplicationSpecSessionReplayConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionAndSessionPropertiesCodec struct {
}

func (ApplicationSpecUserActionAndSessionPropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionAndSessionProperties)(ptr) == nil
}

func (ApplicationSpecUserActionAndSessionPropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionAndSessionProperties)(ptr)
	var objs []ApplicationSpecUserActionAndSessionProperties
	if obj != nil {
		objs = []ApplicationSpecUserActionAndSessionProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionAndSessionPropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionAndSessionProperties)(ptr) = ApplicationSpecUserActionAndSessionProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionAndSessionProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionAndSessionProperties)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionAndSessionProperties)(ptr) = ApplicationSpecUserActionAndSessionProperties{}
			}
		} else {
			*(*ApplicationSpecUserActionAndSessionProperties)(ptr) = ApplicationSpecUserActionAndSessionProperties{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionAndSessionProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionAndSessionProperties)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionAndSessionProperties)(ptr) = ApplicationSpecUserActionAndSessionProperties{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionAndSessionProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionAndSessionPropertiesPropertyCodec struct {
}

func (ApplicationSpecUserActionAndSessionPropertiesPropertyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) == nil
}

func (ApplicationSpecUserActionAndSessionPropertiesPropertyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr)
	var objs []ApplicationSpecUserActionAndSessionPropertiesProperty
	if obj != nil {
		objs = []ApplicationSpecUserActionAndSessionPropertiesProperty{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionPropertiesProperty{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionAndSessionPropertiesPropertyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) = ApplicationSpecUserActionAndSessionPropertiesProperty{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionAndSessionPropertiesProperty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionPropertiesProperty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) = ApplicationSpecUserActionAndSessionPropertiesProperty{}
			}
		} else {
			*(*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) = ApplicationSpecUserActionAndSessionPropertiesProperty{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionAndSessionPropertiesProperty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionAndSessionPropertiesProperty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionAndSessionPropertiesProperty)(ptr) = ApplicationSpecUserActionAndSessionPropertiesProperty{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionAndSessionPropertiesProperty", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettings)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettings)(ptr)
	var objs []ApplicationSpecUserActionNamingSettings
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettings)(ptr) = ApplicationSpecUserActionNamingSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettings)(ptr) = ApplicationSpecUserActionNamingSettings{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettings)(ptr) = ApplicationSpecUserActionNamingSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettings)(ptr) = ApplicationSpecUserActionNamingSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsCustomActionNamingRules
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsCustomActionNamingRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsCustomActionNamingRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRules{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsCustomActionNamingRules", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsLoadActionNamingRules
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsLoadActionNamingRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsLoadActionNamingRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRules{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsLoadActionNamingRules", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsPlaceholdersCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsPlaceholdersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsPlaceholdersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsPlaceholders
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsPlaceholders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsPlaceholdersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsPlaceholders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholders{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsPlaceholders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsPlaceholders)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholders{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsPlaceholders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps)(ptr) = ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsXhrActionNamingRules
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsXhrActionNamingRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsXhrActionNamingRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRules)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRules{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsXhrActionNamingRules", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCodec struct {
}

func (ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) == nil
}

func (ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr)
	var objs []ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions
	if obj != nil {
		objs = []ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}
			}
		} else {
			*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) = obj
		} else {
			*(*ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions)(ptr) = ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecUserTagsCodec struct {
}

func (ApplicationSpecUserTagsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecUserTags)(ptr) == nil
}

func (ApplicationSpecUserTagsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecUserTags)(ptr)
	var objs []ApplicationSpecUserTags
	if obj != nil {
		objs = []ApplicationSpecUserTags{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserTags{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecUserTagsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecUserTags)(ptr) = ApplicationSpecUserTags{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecUserTags

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserTags{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecUserTags)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecUserTags)(ptr) = ApplicationSpecUserTags{}
			}
		} else {
			*(*ApplicationSpecUserTags)(ptr) = ApplicationSpecUserTags{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecUserTags

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecUserTags{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecUserTags)(ptr) = obj
		} else {
			*(*ApplicationSpecUserTags)(ptr) = ApplicationSpecUserTags{}
		}
	default:
		iter.ReportError("decode ApplicationSpecUserTags", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecWaterfallSettingsCodec struct {
}

func (ApplicationSpecWaterfallSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecWaterfallSettings)(ptr) == nil
}

func (ApplicationSpecWaterfallSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecWaterfallSettings)(ptr)
	var objs []ApplicationSpecWaterfallSettings
	if obj != nil {
		objs = []ApplicationSpecWaterfallSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecWaterfallSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecWaterfallSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecWaterfallSettings)(ptr) = ApplicationSpecWaterfallSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecWaterfallSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecWaterfallSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecWaterfallSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecWaterfallSettings)(ptr) = ApplicationSpecWaterfallSettings{}
			}
		} else {
			*(*ApplicationSpecWaterfallSettings)(ptr) = ApplicationSpecWaterfallSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecWaterfallSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecWaterfallSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecWaterfallSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecWaterfallSettings)(ptr) = ApplicationSpecWaterfallSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecWaterfallSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecXhrActionApdexSettingsCodec struct {
}

func (ApplicationSpecXhrActionApdexSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecXhrActionApdexSettings)(ptr) == nil
}

func (ApplicationSpecXhrActionApdexSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecXhrActionApdexSettings)(ptr)
	var objs []ApplicationSpecXhrActionApdexSettings
	if obj != nil {
		objs = []ApplicationSpecXhrActionApdexSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecXhrActionApdexSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecXhrActionApdexSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecXhrActionApdexSettings)(ptr) = ApplicationSpecXhrActionApdexSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecXhrActionApdexSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecXhrActionApdexSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecXhrActionApdexSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecXhrActionApdexSettings)(ptr) = ApplicationSpecXhrActionApdexSettings{}
			}
		} else {
			*(*ApplicationSpecXhrActionApdexSettings)(ptr) = ApplicationSpecXhrActionApdexSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ApplicationSpecXhrActionApdexSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecXhrActionApdexSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ApplicationSpecXhrActionApdexSettings)(ptr) = obj
		} else {
			*(*ApplicationSpecXhrActionApdexSettings)(ptr) = ApplicationSpecXhrActionApdexSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecXhrActionApdexSettings", "unexpected JSON type")
	}
}
