/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Application struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ApplicationSpec   `json:"spec,omitempty"`
	Status            ApplicationStatus `json:"status,omitempty"`
}

type ApplicationSpecConversionGoalsGoalDestination struct {
	// The match is case-sensitive (`true`) or (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// The operator of the match. Possible values are `Begins`, `Contains` and `Ends`.
	// +optional
	MatchType *string `json:"matchType,omitempty" tf:"match_type"`
	// The path to be reached to hit the conversion goal
	UrlOrPath *string `json:"urlOrPath" tf:"url_or_path"`
}

type ApplicationSpecConversionGoalsGoalUserAction struct {
	// Type of the action to which the rule applies. Possible values are `Custom`, `Load` and `Xhr`.
	// +optional
	ActionType *string `json:"actionType,omitempty" tf:"action_type"`
	// The match is case-sensitive (`true`) or (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// The type of the entity to which the rule applies. Possible values are `ActionName`, `CssSelector`, `JavaScriptVariable`, `MetaTag`, `PagePath`, `PageTitle`, `PageUrl`, `UrlAnchor` and `XhrUrl`.
	// +optional
	MatchEntity *string `json:"matchEntity,omitempty" tf:"match_entity"`
	// The operator of the match. Possible values are `Begins`, `Contains` and `Ends`.
	// +optional
	MatchType *string `json:"matchType,omitempty" tf:"match_type"`
	// The value to be matched to hit the conversion goal
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ApplicationSpecConversionGoalsGoalVisitDuration struct {
	// The duration of session to hit the conversion goal, in milliseconds
	Duration *int64 `json:"duration" tf:"duration"`
}

type ApplicationSpecConversionGoalsGoalVisitNumAction struct {
	// The number of user actions to hit the conversion goal
	// +optional
	NumUserActions *int64 `json:"numUserActions,omitempty" tf:"num_user_actions"`
}

type ApplicationSpecConversionGoalsGoal struct {
	// Configuration of a destination-based conversion goal
	// +optional
	Destination *ApplicationSpecConversionGoalsGoalDestination `json:"destination,omitempty" tf:"destination"`
	// The ID of conversion goal.
	//
	//  Omit it while creating a new conversion goal
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// The name of the conversion goal. Valid length within 1 and 50 characters.
	Name *string `json:"name" tf:"name"`
	// The type of the conversion goal. Possible values are `Destination`, `UserAction`, `VisitDuration` and `VisitNumActions`
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Configuration of a destination-based conversion goal
	// +optional
	UserAction *ApplicationSpecConversionGoalsGoalUserAction `json:"userAction,omitempty" tf:"user_action"`
	// Configuration of a destination-based conversion goal
	// +optional
	VisitDuration *ApplicationSpecConversionGoalsGoalVisitDuration `json:"visitDuration,omitempty" tf:"visit_duration"`
	// Configuration of a destination-based conversion goal
	// +optional
	VisitNumAction *ApplicationSpecConversionGoalsGoalVisitNumAction `json:"visitNumAction,omitempty" tf:"visit_num_action"`
}

type ApplicationSpecConversionGoals struct {
	// A conversion goal of the application
	// +kubebuilder:validation:MinItems=1
	Goal []ApplicationSpecConversionGoalsGoal `json:"goal" tf:"goal"`
}

type ApplicationSpecCustomActionApdexSettings struct {
	// Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
	// +optional
	FrustratingFallbackThreshold *int64 `json:"frustratingFallbackThreshold,omitempty" tf:"frustrating_fallback_threshold"`
	// Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
	// +optional
	FrustratingThreshold *int64 `json:"frustratingThreshold,omitempty" tf:"frustrating_threshold"`
	// no documentation available
	// +optional
	Threshold *int64 `json:"threshold,omitempty" tf:"threshold"`
	// Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
	// +optional
	ToleratedFallbackThreshold *int64 `json:"toleratedFallbackThreshold,omitempty" tf:"tolerated_fallback_threshold"`
	// Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
	// +optional
	ToleratedThreshold *int64 `json:"toleratedThreshold,omitempty" tf:"tolerated_threshold"`
}

type ApplicationSpecKeyUserActionsAction struct {
	// The domain where the action is performed.
	// +optional
	Domain *string `json:"domain,omitempty" tf:"domain"`
	// The name of the action
	Name *string `json:"name" tf:"name"`
	// The type of the action. Possible values are `Custom`, `Load` and `Xhr`.
	Type *string `json:"type" tf:"type"`
}

type ApplicationSpecKeyUserActions struct {
	// Configuration of the key user action
	// +kubebuilder:validation:MinItems=1
	Action []ApplicationSpecKeyUserActionsAction `json:"action" tf:"action"`
}

type ApplicationSpecLoadActionApdexSettings struct {
	// Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
	// +optional
	FrustratingFallbackThreshold *int64 `json:"frustratingFallbackThreshold,omitempty" tf:"frustrating_fallback_threshold"`
	// Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
	// +optional
	FrustratingThreshold *int64 `json:"frustratingThreshold,omitempty" tf:"frustrating_threshold"`
	// no documentation available
	// +optional
	Threshold *int64 `json:"threshold,omitempty" tf:"threshold"`
	// Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
	// +optional
	ToleratedFallbackThreshold *int64 `json:"toleratedFallbackThreshold,omitempty" tf:"tolerated_fallback_threshold"`
	// Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
	// +optional
	ToleratedThreshold *int64 `json:"toleratedThreshold,omitempty" tf:"tolerated_threshold"`
}

type ApplicationSpecMetaDataCaptureSettingsCapture struct {
	// The name of the meta data to capture
	CapturingName *string `json:"capturingName" tf:"capturing_name"`
	// Name for displaying the captured values in Dynatrace
	Name *string `json:"name" tf:"name"`
	// `true` if this metadata should be captured regardless of the privacy settings, `false` otherwise
	// +optional
	PublicMetadata *bool `json:"publicMetadata,omitempty" tf:"public_metadata"`
	// The type of the meta data to capture. Possible values are `COOKIE`, `CSS_SELECTOR`, `JAVA_SCRIPT_FUNCTION`, `JAVA_SCRIPT_VARIABLE`, `META_TAG` and `QUERY_STRING`.
	Type *string `json:"type" tf:"type"`
	// The unique ID of the meta data to capture
	// +optional
	UniqueID *int64 `json:"uniqueID,omitempty" tf:"unique_id"`
	// `true` if the last captured value should be used for this metadata. By default the first value will be used.
	// +optional
	UseLastValue *bool `json:"useLastValue,omitempty" tf:"use_last_value"`
}

type ApplicationSpecMetaDataCaptureSettings struct {
	// Java script agent meta data capture settings
	// +optional
	Capture []ApplicationSpecMetaDataCaptureSettingsCapture `json:"capture,omitempty" tf:"capture"`
}

type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers struct {
	// Blur event handler enabled/disabled
	// +optional
	Blur *bool `json:"blur,omitempty" tf:"blur"`
	// Change event handler enabled/disabled
	// +optional
	Change *bool `json:"change,omitempty" tf:"change"`
	// Click event handler enabled/disabled
	// +optional
	Click *bool `json:"click,omitempty" tf:"click"`
	// Max. number of DOM nodes to instrument. Valid values range from 0 to 100000.
	MaxDomNodes *int64 `json:"maxDomNodes" tf:"max_dom_nodes"`
	// Mouseup event handler enabled/disabled
	// +optional
	Mouseup *bool `json:"mouseup,omitempty" tf:"mouseup"`
	// toString method enabled/disabled
	// +optional
	ToStringMethod *bool `json:"toStringMethod,omitempty" tf:"to_string_method"`
	// Use mouseup event for clicks enabled/disabled
	// +optional
	UseMouseUpEventForClicks *bool `json:"useMouseUpEventForClicks,omitempty" tf:"use_mouse_up_event_for_clicks"`
}

type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings struct {
	// Blur enabled/disabled
	// +optional
	Blur *bool `json:"blur,omitempty" tf:"blur"`
	// Change enabled/disabled
	// +optional
	Change *bool `json:"change,omitempty" tf:"change"`
	// Click enabled/disabled
	// +optional
	Click *bool `json:"click,omitempty" tf:"click"`
	// MouseUp enabled/disabled
	// +optional
	Mouseup *bool `json:"mouseup,omitempty" tf:"mouseup"`
	// TouchEnd enabled/disabled
	// +optional
	TouchEnd *bool `json:"touchEnd,omitempty" tf:"touch_end"`
	// TouchStart enabled/disabled
	// +optional
	TouchStart *bool `json:"touchStart,omitempty" tf:"touch_start"`
}

type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings struct {
	// Additional events to be captured globally as user input.
	//
	// For example `DragStart` or `DragEnd`. Maximum 100 characters.
	// +optional
	AdditionalEventCapturedAsUserInput *string `json:"additionalEventCapturedAsUserInput,omitempty" tf:"additional_event_captured_as_user_input"`
	// Click enabled/disabled
	// +optional
	Click *bool `json:"click,omitempty" tf:"click"`
	// DoubleClick enabled/disabled
	// +optional
	Doubleclick *bool `json:"doubleclick,omitempty" tf:"doubleclick"`
	// KeyDown enabled/disabled
	// +optional
	Keydown *bool `json:"keydown,omitempty" tf:"keydown"`
	// KeyUp enabled/disabled
	// +optional
	Keyup *bool `json:"keyup,omitempty" tf:"keyup"`
	// MouseDown enabled/disabled
	// +optional
	Mousedown *bool `json:"mousedown,omitempty" tf:"mousedown"`
	// MouseUp enabled/disabled
	// +optional
	Mouseup *bool `json:"mouseup,omitempty" tf:"mouseup"`
	// Scroll enabled/disabled
	// +optional
	Scroll *bool `json:"scroll,omitempty" tf:"scroll"`
}

type ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings struct {
	// Additional event handlers and wrappers
	// +optional
	AdditionalEventHandlers *ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsAdditionalEventHandlers `json:"additionalEventHandlers,omitempty" tf:"additional_event_handlers"`
	// In addition to the event handlers, events called using `addEventListener` or `attachEvent` can be captured. Be careful with this option! Event wrappers can conflict with the JavaScript code on a web page
	// +optional
	EventWrapperSettings *ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsEventWrapperSettings `json:"eventWrapperSettings,omitempty" tf:"event_wrapper_settings"`
	// Global event capture settings
	// +optional
	GlobalEventCaptureSettings *ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettingsGlobalEventCaptureSettings `json:"globalEventCaptureSettings,omitempty" tf:"global_event_capture_settings"`
	// Instrumentation of unsupported Ajax frameworks enabled/disabled
	// +optional
	InstrumentUnsupportedAjaxFrameworks *bool `json:"instrumentUnsupportedAjaxFrameworks,omitempty" tf:"instrument_unsupported_ajax_frameworks"`
	// Maximum character length for action names. Valid values range from 5 to 10000.
	MaxActionNameLength *int64 `json:"maxActionNameLength" tf:"max_action_name_length"`
	// Maximum number of errors to be captured per page. Valid values range from 0 to 50.
	MaxErrorsToCapture *int64 `json:"maxErrorsToCapture" tf:"max_errors_to_capture"`
	// Additional special characters that are to be escaped using non-alphanumeric characters in HTML escape format. Maximum length 30 character. Allowed characters are `^`, `\`, `<` and `>`.
	// +optional
	SpecialCharactersToEscape *string `json:"specialCharactersToEscape,omitempty" tf:"special_characters_to_escape"`
	// Send the beacon signal as a synchronous XMLHttpRequest using Firefox enabled/disabled
	// +optional
	SyncBeaconFirefox *bool `json:"syncBeaconFirefox,omitempty" tf:"sync_beacon_firefox"`
	// Send the beacon signal as a synchronous XMLHttpRequest using Internet Explorer enabled/disabled
	// +optional
	SyncBeaconInternetExplorer *bool `json:"syncBeaconInternetExplorer,omitempty" tf:"sync_beacon_internet_explorer"`
}

type ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction struct {
	// The type of the browser that is used. Possible values are `ANDROID_WEBKIT`, `BOTS_SPIDERS`, `CHROME`, `EDGE`, `FIREFOX`, `INTERNET_EXPLORER, `OPERA` and `SAFARI`
	BrowserType *string `json:"browserType" tf:"browser_type"`
	// The version of the browser that is used
	// +optional
	BrowserVersion *string `json:"browserVersion,omitempty" tf:"browser_version"`
	// No documentation available. Possible values are `EQUALS`, `GREATER_THAN_OR_EQUAL` and `LOWER_THAN_OR_EQUAL`.
	// +optional
	Comparator *string `json:"comparator,omitempty" tf:"comparator"`
	// The platform on which the browser is being used. Possible values are `ALL`, `DESKTOP` and `MOBILE`
	// +optional
	Platform *string `json:"platform,omitempty" tf:"platform"`
}

type ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions struct {
	// Browser exclusion rules for the browsers that are to be excluded
	// +kubebuilder:validation:MinItems=1
	Restriction []ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictionsRestriction `json:"restriction" tf:"restriction"`
}

type ApplicationSpecMonitoringSettingsBrowserRestrictionSettings struct {
	// The mode of the list of browser restrictions. Possible values area `EXCLUDE` and `INCLUDE`.
	Mode *string `json:"mode" tf:"mode"`
	// A list of browser restrictions
	// +optional
	Restrictions *ApplicationSpecMonitoringSettingsBrowserRestrictionSettingsRestrictions `json:"restrictions,omitempty" tf:"restrictions"`
}

type ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings struct {
	// Instrumentation delay for monitoring resource and image resource impact in browsers that don't offer W3C resource timings.
	//
	// Valid values range from 0 to 9999.
	//
	// Only effective if `nonW3cResourceTimings` is enabled
	InstrumentationDelay *int64 `json:"instrumentationDelay" tf:"instrumentation_delay"`
	// Timing for JavaScript files and images on non-W3C supported browsers enabled/disabled
	// +optional
	NonW3CResourceTimings *bool `json:"nonW3CResourceTimings,omitempty" tf:"non_w3c_resource_timings"`
	// Defines how detailed resource timings are captured.
	//
	// Only effective if **w3cResourceTimings** or **nonW3cResourceTimings** is enabled. Possible values are `CAPTURE_ALL_SUMMARIES`, `CAPTURE_FULL_DETAILS` and `CAPTURE_LIMITED_SUMMARIES`
	ResourceTimingCaptureType *string `json:"resourceTimingCaptureType" tf:"resource_timing_capture_type"`
	// Limits the number of domains for which W3C resource timings are captured.
	//
	// Only effective if **resourceTimingCaptureType** is `CAPTURE_LIMITED_SUMMARIES`. Valid values range from 0 to 50.
	ResourceTimingsDomainLimit *int64 `json:"resourceTimingsDomainLimit" tf:"resource_timings_domain_limit"`
	// W3C resource timings for third party/CDN enabled/disabled
	// +optional
	W3cResourceTimings *bool `json:"w3cResourceTimings,omitempty" tf:"w3c_resource_timings"`
}

type ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings struct {
	// Defines how deep temporary actions may cascade. 0 disables temporary actions completely. Recommended value if enabled is 3
	TemporaryActionLimit *int64 `json:"temporaryActionLimit" tf:"temporary_action_limit"`
	// The total timeout of all cascaded timeouts that should still be able to create a temporary action
	TemporaryActionTotalTimeout *int64 `json:"temporaryActionTotalTimeout" tf:"temporary_action_total_timeout"`
	// Timed action support enabled/disabled.
	//
	// Enable to detect actions that trigger sending of XHRs via `setTimout` methods
	// +optional
	TimedActionSupport *bool `json:"timedActionSupport,omitempty" tf:"timed_action_support"`
}

type ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings struct {
	// A RegularExpression used to exclude images and iframes from being detected by the VC module
	// +optional
	ExcludeURLRegex *string `json:"excludeURLRegex,omitempty" tf:"exclude_url_regex"`
	// Query selector for mutation nodes to ignore in VC and SI calculation
	// +optional
	IgnoredMutationsList *string `json:"ignoredMutationsList,omitempty" tf:"ignored_mutations_list"`
	// The time in ms the VC module waits for no mutations happening on the page after the load action. Defaults to 1000. Valid values range from 0 to 30000.
	// +optional
	InactivityTimeout *int64 `json:"inactivityTimeout,omitempty" tf:"inactivity_timeout"`
	// Determines the time in ms VC waits after an action closes to start calculation. Defaults to 50. Valid values range from 0 to 5000.
	// +optional
	MutationTimeout *int64 `json:"mutationTimeout,omitempty" tf:"mutation_timeout"`
	// Minimum visible area in pixels of elements to be counted towards VC and SI. Defaults to 50. Valid values range from 0 to 10000.
	// +optional
	Threshold *int64 `json:"threshold,omitempty" tf:"threshold"`
}

type ApplicationSpecMonitoringSettingsContentCapture struct {
	// JavaScript errors monitoring enabled/disabled
	// +optional
	JavascriptErrors *bool `json:"javascriptErrors,omitempty" tf:"javascript_errors"`
	// Settings for resource timings capture
	// +optional
	ResourceTimingSettings *ApplicationSpecMonitoringSettingsContentCaptureResourceTimingSettings `json:"resourceTimingSettings,omitempty" tf:"resource_timing_settings"`
	// Settings for timed action capture
	// +optional
	TimeoutSettings *ApplicationSpecMonitoringSettingsContentCaptureTimeoutSettings `json:"timeoutSettings,omitempty" tf:"timeout_settings"`
	// Visually complete and Speed index support enabled/disabled
	// +optional
	VisuallyCompleteAndSpeedIndex *bool `json:"visuallyCompleteAndSpeedIndex,omitempty" tf:"visually_complete_and_speed_index"`
	// Settings for VisuallyComplete
	// +optional
	VisuallyCompleteSettings *ApplicationSpecMonitoringSettingsContentCaptureVisuallyCompleteSettings `json:"visuallyCompleteSettings,omitempty" tf:"visually_complete_settings"`
}

type ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange struct {
	// The IP address to be mapped.
	//
	// For an IP address range, this is the **from** address.
	Address *string `json:"address" tf:"address"`
	// The **to** address of the IP address range.
	// +optional
	AddressTo *string `json:"addressTo,omitempty" tf:"address_to"`
	// The subnet mask of the IP address range. Valid values range from 0 to 128.
	// +optional
	SubnetMask *int64 `json:"subnetMask,omitempty" tf:"subnet_mask"`
}

type ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions struct {
	// The IP address or the IP address range to be mapped to the location
	// +kubebuilder:validation:MinItems=1
	Range []ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictionsRange `json:"range" tf:"range"`
}

type ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings struct {
	// The mode of the list of ip address restrictions. Possible values area `EXCLUDE` and `INCLUDE`.
	Mode *string `json:"mode" tf:"mode"`
	// The IP addresses or the IP address ranges to be mapped to the location
	// +optional
	Restrictions *ApplicationSpecMonitoringSettingsIpAddressRestrictionSettingsRestrictions `json:"restrictions,omitempty" tf:"restrictions"`
}

type ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport struct {
	// ActiveXObject support enabled/disabled
	// +optional
	ActiveXObject *bool `json:"activeXObject,omitempty" tf:"active_x_object"`
	// AngularJS and Angular support enabled/disabled
	// +optional
	Angular *bool `json:"angular,omitempty" tf:"angular"`
	// Dojo support enabled/disabled
	// +optional
	Dojo *bool `json:"dojo,omitempty" tf:"dojo"`
	// ExtJS, Sencha Touch support enabled/disabled
	// +optional
	Extjs *bool `json:"extjs,omitempty" tf:"extjs"`
	// ICEfaces support enabled/disabled
	// +optional
	Icefaces *bool `json:"icefaces,omitempty" tf:"icefaces"`
	// jQuery, Backbone.js support enabled/disabled
	// +optional
	Jquery *bool `json:"jquery,omitempty" tf:"jquery"`
	// MooTools support enabled/disabled
	// +optional
	MooTools *bool `json:"mooTools,omitempty" tf:"moo_tools"`
	// Prototype support enabled/disabled
	// +optional
	Prototype *bool `json:"prototype,omitempty" tf:"prototype"`
}

type ApplicationSpecMonitoringSettingsJavascriptInjectionRulesRule struct {
	// `fetch()` request capture enabled/disabled
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// The HTML pattern of the java script injection
	// +optional
	HtmlPattern *string `json:"htmlPattern,omitempty" tf:"html_pattern"`
	// The url rule of the java script injection. Possible values are `AFTER_SPECIFIC_HTML`, `AUTOMATIC_INJECTION`, `BEFORE_SPECIFIC_HTML` and `DO_NOT_INJECT`.
	Rule *string `json:"rule" tf:"rule"`
	// The target against which the rule of the java script injection should be matched. Possible values are `PAGE_QUERY` and `URL`.
	// +optional
	Target *string `json:"target,omitempty" tf:"target"`
	// The url operator of the java script injection. Possible values are `ALL_PAGES`, `CONTAINS`, `ENDS_WITH`, `EQUALS` and `STARTS_WITH`.
	UrlOperator *string `json:"urlOperator" tf:"url_operator"`
	// The url pattern of the java script injection
	// +optional
	UrlPattern *string `json:"urlPattern,omitempty" tf:"url_pattern"`
}

type ApplicationSpecMonitoringSettingsJavascriptInjectionRules struct {
	// Java script injection rule
	// +kubebuilder:validation:MinItems=1
	Rule []ApplicationSpecMonitoringSettingsJavascriptInjectionRulesRule `json:"rule" tf:"rule"`
}

type ApplicationSpecMonitoringSettings struct {
	// Add the cross origin = anonymous attribute to capture JavaScript error messages and W3C resource timings
	// +optional
	AddCrossOriginAnonymousAttribute *bool `json:"addCrossOriginAnonymousAttribute,omitempty" tf:"add_cross_origin_anonymous_attribute"`
	// Advanced JavaScript tag settings
	// +optional
	AdvancedJavascriptTagSettings *ApplicationSpecMonitoringSettingsAdvancedJavascriptTagSettings `json:"advancedJavascriptTagSettings,omitempty" tf:"advanced_javascript_tag_settings"`
	// The name of the angular package
	// +optional
	AngularPackageName *string `json:"angularPackageName,omitempty" tf:"angular_package_name"`
	// Settings for restricting certain browser type, version, platform and, comparator. It also restricts the mode
	// +optional
	BrowserRestrictionSettings *ApplicationSpecMonitoringSettingsBrowserRestrictionSettings `json:"browserRestrictionSettings,omitempty" tf:"browser_restriction_settings"`
	// Optimize the value of cache control headers for use with Dynatrace real user monitoring enabled/disabled
	// +optional
	CacheControlHeaderOptimizations *bool `json:"cacheControlHeaderOptimizations,omitempty" tf:"cache_control_header_optimizations"`
	// Settings for content capture
	ContentCapture *ApplicationSpecMonitoringSettingsContentCapture `json:"contentCapture" tf:"content_capture"`
	// Domain for cookie placement. Maximum 150 characters.
	// +optional
	CookiePlacementDomain *string `json:"cookiePlacementDomain,omitempty" tf:"cookie_placement_domain"`
	// To enable RUM for XHR calls to AWS Lambda, define a regular expression matching these calls, Dynatrace can then automatically add a custom header (`x-dtc`) to each such request to the respective endpoints in AWS.
	//
	// Important: These endpoints must accept the `x-dtc` header, or the requests will fail
	// +optional
	CorrelationHeaderInclusionRegex *string `json:"correlationHeaderInclusionRegex,omitempty" tf:"correlation_header_inclusion_regex"`
	// The location to send monitoring data from the JavaScript tag.
	//
	//  Specify either a relative or an absolute URL. If you use an absolute URL, data will be sent using CORS.
	//
	//  **Required** for auto-injected applications, optional for agentless applications. Maximum 512 characters.
	// +optional
	CustomConfigurationProperties *string `json:"customConfigurationProperties,omitempty" tf:"custom_configuration_properties"`
	// You can exclude some actions from becoming XHR actions.
	//
	// Put a regular expression, matching all the required URLs, here.
	//
	// If noting specified the feature is disabled
	// +optional
	ExcludeXhrRegex *string `json:"excludeXhrRegex,omitempty" tf:"exclude_xhr_regex"`
	// `fetch()` request capture enabled/disabled
	// +optional
	FetchRequests *bool `json:"fetchRequests,omitempty" tf:"fetch_requests"`
	// Possible valures are `CODE_SNIPPET`, `CODE_SNIPPET_ASYNC`, `INLINE_CODE` and `JAVASCRIPT_TAG`.
	InjectionMode *string `json:"injectionMode" tf:"injection_mode"`
	// Settings for restricting certain ip addresses and for introducing subnet mask. It also restricts the mode
	// +optional
	IpAddressRestrictionSettings *ApplicationSpecMonitoringSettingsIpAddressRestrictionSettings `json:"ipAddressRestrictionSettings,omitempty" tf:"ip_address_restriction_settings"`
	// Support of various JavaScript frameworks
	// +optional
	JavascriptFrameworkSupport *ApplicationSpecMonitoringSettingsJavascriptFrameworkSupport `json:"javascriptFrameworkSupport,omitempty" tf:"javascript_framework_support"`
	// Java script injection rules
	// +optional
	JavascriptInjectionRules *ApplicationSpecMonitoringSettingsJavascriptInjectionRules `json:"javascriptInjectionRules,omitempty" tf:"javascript_injection_rules"`
	// The location of your application’s custom JavaScript library file.
	//
	//  If nothing specified the root directory of your web server is used.
	//
	//  **Required** for auto-injected applications, not supported by agentless applications. Maximum 512 characters.
	// +optional
	LibraryFileLocation *string `json:"libraryFileLocation,omitempty" tf:"library_file_location"`
	// The location to send monitoring data from the JavaScript tag.
	//
	//  Specify either a relative or an absolute URL. If you use an absolute URL, data will be sent using CORS.
	//
	//  **Required** for auto-injected applications, optional for agentless applications. Maximum 512 characters.
	// +optional
	MonitoringDataPath *string `json:"monitoringDataPath,omitempty" tf:"monitoring_data_path"`
	// Time duration for the cache settings
	// +optional
	ScriptTagCacheDurationInHours *int64 `json:"scriptTagCacheDurationInHours,omitempty" tf:"script_tag_cache_duration_in_hours"`
	// Secure attribute usage for Dynatrace cookies enabled/disabled
	// +optional
	SecureCookieAttribute *bool `json:"secureCookieAttribute,omitempty" tf:"secure_cookie_attribute"`
	// Path to identify the server’s request ID. Maximum 150 characters.
	// +optional
	ServerRequestPathID *string `json:"serverRequestPathID,omitempty" tf:"server_request_path_id"`
	// `XmlHttpRequest` support enabled/disabled
	// +optional
	XmlHTTPRequest *bool `json:"xmlHTTPRequest,omitempty" tf:"xml_http_request"`
}

type ApplicationSpecSessionReplayConfig struct {
	// Session replay sampling rating in percent
	CostControlPercentage *int64 `json:"costControlPercentage" tf:"cost_control_percentage"`
	// A list of URLs to be excluded from CSS resource capturing
	// +optional
	CssResourceCapturingExclusionRules []string `json:"cssResourceCapturingExclusionRules,omitempty" tf:"css_resource_capturing_exclusion_rules"`
	// Capture (`true`) or don't capture (`false`) CSS resources from the session
	// +optional
	EnableCssResourceCapturing *bool `json:"enableCssResourceCapturing,omitempty" tf:"enable_css_resource_capturing"`
	// SessionReplay Enabled/Disabled
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
}

type ApplicationSpecUserActionAndSessionPropertiesProperty struct {
	// The aggregation type of the property.
	//
	//   It defines how multiple values of the property are aggregated. Possible values are `AVERAGE`, `FIRST`, `LAST`, `MAXIMUM`, `MINIMUM` and `SUM`.
	// +optional
	Aggregation *string `json:"aggregation,omitempty" tf:"aggregation"`
	// The cleanup rule of the property.
	//
	// Defines how to extract the data you need from a string value. Specify the [regular expression](https://dt-url.net/k9e0iaq) for the data you need there
	// +optional
	CleanupRule *string `json:"cleanupRule,omitempty" tf:"cleanup_rule"`
	// The display name of the property
	// +optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name"`
	// Unique id among all userTags and properties of this application
	ID *int64 `json:"ID" tf:"id"`
	// If `true`, the value of this property will always be stored in lower case. Defaults to `false`.
	// +optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case"`
	// Key of the property
	Key *string `json:"key" tf:"key"`
	// If the `type` is `LONG_STRING`, the max length for this property. Must be a multiple of `100`. Defaults to `200`. Maximum is `1000`.
	// +optional
	LongStringLength *int64 `json:"longStringLength,omitempty" tf:"long_string_length"`
	// If the origin is `META_DATA`, metaData id of the property
	// +optional
	MetadataID *int64 `json:"metadataID,omitempty" tf:"metadata_id"`
	// The origin of the property. Possible values are `JAVASCRIPT_API`, `META_DATA` and `SERVER_SIDE_REQUEST_ATTRIBUTE`.
	Origin *string `json:"origin" tf:"origin"`
	// The ID of the request attribute.
	//
	// Only applicable when the **origin** is set to `SERVER_SIDE_REQUEST_ATTRIBUTE`
	// +optional
	ServerSideRequestAttribute *string `json:"serverSideRequestAttribute,omitempty" tf:"server_side_request_attribute"`
	// If `true`, the property is stored as a session property
	// +optional
	StoreAsSessionProperty *bool `json:"storeAsSessionProperty,omitempty" tf:"store_as_session_property"`
	// If `true`, the property is stored as a user action property
	// +optional
	StoreAsUserActionProperty *bool `json:"storeAsUserActionProperty,omitempty" tf:"store_as_user_action_property"`
	// The data type of the property. Possible values are `DATE`, `DOUBLE`, `LONG`, `LONG_STRING` and `STRING`.
	Type *string `json:"type" tf:"type"`
}

type ApplicationSpecUserActionAndSessionProperties struct {
	// User action and session properties settings
	// +optional
	Property *ApplicationSpecUserActionAndSessionPropertiesProperty `json:"property,omitempty" tf:"property"`
}

type ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition struct {
	// Must be a defined placeholder wrapped in curly braces
	Operand1 *string `json:"operand1" tf:"operand1"`
	// Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
	// +optional
	Operand2 *string `json:"operand2,omitempty" tf:"operand2"`
	// The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
	Operator *string `json:"operator" tf:"operator"`
}

type ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions struct {
	// Defines the conditions when the naming rule should apply
	// +kubebuilder:validation:MinItems=1
	Condition []ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditionsCondition `json:"condition" tf:"condition"`
}

type ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRule struct {
	// Defines the conditions when the naming rule should apply
	// +optional
	Conditions *ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRuleConditions `json:"conditions,omitempty" tf:"conditions"`
	// Naming pattern. Use Curly brackets `{}` to select placeholders
	Template *string `json:"template" tf:"template"`
	// If set to `true` the conditions will be connected by logical OR instead of logical AND
	// +optional
	UseOrConditions *bool `json:"useOrConditions,omitempty" tf:"use_or_conditions"`
}

type ApplicationSpecUserActionNamingSettingsCustomActionNamingRules struct {
	// The settings of naming rule
	// +kubebuilder:validation:MinItems=1
	Rule []ApplicationSpecUserActionNamingSettingsCustomActionNamingRulesRule `json:"rule" tf:"rule"`
}

type ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition struct {
	// Must be a defined placeholder wrapped in curly braces
	Operand1 *string `json:"operand1" tf:"operand1"`
	// Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
	// +optional
	Operand2 *string `json:"operand2,omitempty" tf:"operand2"`
	// The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
	Operator *string `json:"operator" tf:"operator"`
}

type ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions struct {
	// Defines the conditions when the naming rule should apply
	// +kubebuilder:validation:MinItems=1
	Condition []ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditionsCondition `json:"condition" tf:"condition"`
}

type ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRule struct {
	// Defines the conditions when the naming rule should apply
	// +optional
	Conditions *ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRuleConditions `json:"conditions,omitempty" tf:"conditions"`
	// Naming pattern. Use Curly brackets `{}` to select placeholders
	Template *string `json:"template" tf:"template"`
	// If set to `true` the conditions will be connected by logical OR instead of logical AND
	// +optional
	UseOrConditions *bool `json:"useOrConditions,omitempty" tf:"use_or_conditions"`
}

type ApplicationSpecUserActionNamingSettingsLoadActionNamingRules struct {
	// The settings of naming rule
	// +kubebuilder:validation:MinItems=1
	Rule []ApplicationSpecUserActionNamingSettingsLoadActionNamingRulesRule `json:"rule" tf:"rule"`
}

type ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep struct {
	// If set to `true`: Returns the input if `patternBefore` or `patternAfter` cannot be found and the `type` is `SUBSTRING`. Returns the input if `regularExpression` doesn't match and `type` is `EXTRACT_BY_REGULAR_EXPRESSION`.
	//
	//  Otherwise `null` is returned.
	// +optional
	FallbackToInput *bool `json:"fallbackToInput,omitempty" tf:"fallback_to_input"`
	// The pattern after the required value. It will be removed.
	// +optional
	PatternAfter *string `json:"patternAfter,omitempty" tf:"pattern_after"`
	// The required occurrence of **patternAfter**. Possible values are `FIRST` and `LAST`.
	// +optional
	PatternAfterSearchType *string `json:"patternAfterSearchType,omitempty" tf:"pattern_after_search_type"`
	// The pattern before the required value. It will be removed.
	// +optional
	PatternBefore *string `json:"patternBefore,omitempty" tf:"pattern_before"`
	// The required occurrence of **patternBefore**. Possible values are `FIRST` and `LAST`.
	// +optional
	PatternBeforeSearchType *string `json:"patternBeforeSearchType,omitempty" tf:"pattern_before_search_type"`
	// The pattern to be replaced.
	//
	//  Only applicable if the `type` is `REPLACE_WITH_PATTERN`.
	// +optional
	PatternToReplace *string `json:"patternToReplace,omitempty" tf:"pattern_to_replace"`
	// A regular expression for the string to be extracted or replaced. Only applicable if the `type` is `EXTRACT_BY_REGULAR_EXPRESSION` or `REPLACE_WITH_REGULAR_EXPRESSION`.
	// +optional
	RegularExpression *string `json:"regularExpression,omitempty" tf:"regular_expression"`
	// Replacement for the original value
	// +optional
	Replacement *string `json:"replacement,omitempty" tf:"replacement"`
	// An action to be taken by the processing:
	//
	// * `SUBSTRING`: Extracts the string between `patternBefore` and `patternAfter`.
	// * `REPLACEMENT`: Replaces the string between `patternBefore` and `patternAfter` with the specified `replacement`.
	// * `REPLACE_WITH_PATTERN`: Replaces the **patternToReplace** with the specified **replacement**.
	// * `EXTRACT_BY_REGULAR_EXPRESSION`: Extracts the part of the string that matches the **regularExpression**.
	// * `REPLACE_WITH_REGULAR_EXPRESSION`: Replaces all occurrences that match **regularExpression** with the specified **replacement**.
	// * `REPLACE_IDS`: Replaces all IDs and UUIDs with the specified **replacement**. Possible values are `EXTRACT_BY_REGULAR_EXPRESSION`, `REPLACEMENT`, `REPLACE_IDS`, `REPLACE_WITH_PATTERN`, `REPLACE_WITH_REGULAR_EXPRESSION` and `SUBSTRING`.
	Type *string `json:"type" tf:"type"`
}

type ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps struct {
	// The processing step
	// +kubebuilder:validation:MinItems=1
	Step []ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingStepsStep `json:"step" tf:"step"`
}

type ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholder struct {
	// The input for the place holder. Possible values are `ELEMENT_IDENTIFIER`, `INPUT_TYPE`, `METADATA`, `PAGE_TITLE`, `PAGE_URL`, `SOURCE_URL`, `TOP_XHR_URL` and `XHR_URL`
	Input *string `json:"input" tf:"input"`
	// The ID of the metadata
	// +optional
	MetadataID *int64 `json:"metadataID,omitempty" tf:"metadata_id"`
	// Placeholder name. Valid length needs to be between 1 and 50 characters
	Name *string `json:"name" tf:"name"`
	// The part to process. Possible values are `ALL`, `ANCHOR` and `PATH`
	ProcessingPart *string `json:"processingPart" tf:"processing_part"`
	// The processing step settings
	// +optional
	ProcessingSteps *ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholderProcessingSteps `json:"processingSteps,omitempty" tf:"processing_steps"`
	// Use the element identifier that was selected by Dynatrace
	// +optional
	UseGuessedElementIdentifier *bool `json:"useGuessedElementIdentifier,omitempty" tf:"use_guessed_element_identifier"`
}

type ApplicationSpecUserActionNamingSettingsPlaceholders struct {
	// User action placeholders
	// +kubebuilder:validation:MinItems=1
	Placeholder []ApplicationSpecUserActionNamingSettingsPlaceholdersPlaceholder `json:"placeholder" tf:"placeholder"`
}

type ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition struct {
	// Must be a defined placeholder wrapped in curly braces
	Operand1 *string `json:"operand1" tf:"operand1"`
	// Must be null if operator is `IS_EMPTY`, a regex if operator is `MATCHES_REGULAR_ERPRESSION`. In all other cases the value can be a freetext or a placeholder wrapped in curly braces
	// +optional
	Operand2 *string `json:"operand2,omitempty" tf:"operand2"`
	// The operator of the condition. Possible values are `CONTAINS`, `ENDS_WITH`, `EQUALS`, `IS_EMPTY`, `IS_NOT_EMPTY`, `MATCHES_REGULAR_EXPRESSION`, `NOT_CONTAINS`, `NOT_ENDS_WITH`, `NOT_EQUALS`, `NOT_MATCHES_REGULAR_EXPRESSION`, `NOT_STARTS_WITH` and `STARTS_WITH`.
	Operator *string `json:"operator" tf:"operator"`
}

type ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions struct {
	// Defines the conditions when the naming rule should apply
	// +kubebuilder:validation:MinItems=1
	Condition []ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditionsCondition `json:"condition" tf:"condition"`
}

type ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRule struct {
	// Defines the conditions when the naming rule should apply
	// +optional
	Conditions *ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRuleConditions `json:"conditions,omitempty" tf:"conditions"`
	// Naming pattern. Use Curly brackets `{}` to select placeholders
	Template *string `json:"template" tf:"template"`
	// If set to `true` the conditions will be connected by logical OR instead of logical AND
	// +optional
	UseOrConditions *bool `json:"useOrConditions,omitempty" tf:"use_or_conditions"`
}

type ApplicationSpecUserActionNamingSettingsXhrActionNamingRules struct {
	// The settings of naming rule
	// +kubebuilder:validation:MinItems=1
	Rule []ApplicationSpecUserActionNamingSettingsXhrActionNamingRulesRule `json:"rule" tf:"rule"`
}

type ApplicationSpecUserActionNamingSettings struct {
	// User action naming rules for custom actions
	// +optional
	CustomActionNamingRules *ApplicationSpecUserActionNamingSettingsCustomActionNamingRules `json:"customActionNamingRules,omitempty" tf:"custom_action_naming_rules"`
	// Case insensitive naming
	// +optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case"`
	// User action naming rules for loading actions
	// +optional
	LoadActionNamingRules *ApplicationSpecUserActionNamingSettingsLoadActionNamingRules `json:"loadActionNamingRules,omitempty" tf:"load_action_naming_rules"`
	// User action placeholders
	// +optional
	Placeholders *ApplicationSpecUserActionNamingSettingsPlaceholders `json:"placeholders,omitempty" tf:"placeholders"`
	// User action naming rules for custom actions
	// +optional
	// +kubebuilder:validation:MinItems=1
	QueryParameterCleanups []string `json:"queryParameterCleanups,omitempty" tf:"query_parameter_cleanups"`
	// Deactivate this setting if different domains should not result in separate user actions
	// +optional
	SplitUserActionsByDomain *bool `json:"splitUserActionsByDomain,omitempty" tf:"split_user_actions_by_domain"`
	// First load action found under an XHR action should be used when true. Else the deepest one under the xhr action is used
	// +optional
	UseFirstDetectedLoadAction *bool `json:"useFirstDetectedLoadAction,omitempty" tf:"use_first_detected_load_action"`
	// User action naming rules for XHR actions
	// +optional
	XhrActionNamingRules *ApplicationSpecUserActionNamingSettingsXhrActionNamingRules `json:"xhrActionNamingRules,omitempty" tf:"xhr_action_naming_rules"`
}

type ApplicationSpecUserTagsTag struct {
	// Cleanup rule expression of the userTag
	// +optional
	CleanupRule *string `json:"cleanupRule,omitempty" tf:"cleanup_rule"`
	// A unique ID among all userTags and properties of this application. Minimum value is 1.
	ID *int64 `json:"ID" tf:"id"`
	// If `true`, the value of this tag will always be stored in lower case. Defaults to `false`.
	// +optional
	IgnoreCase *bool `json:"ignoreCase,omitempty" tf:"ignore_case"`
	// If it's of type metaData, metaData id of the userTag
	// +optional
	MetadataID *int64 `json:"metadataID,omitempty" tf:"metadata_id"`
	// The ID of the RrequestAttribute for the userTag
	// +optional
	ServerSideRequestAttribute *string `json:"serverSideRequestAttribute,omitempty" tf:"server_side_request_attribute"`
}

type ApplicationSpecUserTags struct {
	// User tag settings
	// +kubebuilder:validation:MinItems=1
	Tag []ApplicationSpecUserTagsTag `json:"tag" tf:"tag"`
}

type ApplicationSpecWaterfallSettings struct {
	// Warn about resources with a lower browser cache rate above *X*%. Values between 1 and 100 are allowed.
	ResourceBrowserCachingThreshold *int64 `json:"resourceBrowserCachingThreshold" tf:"resource_browser_caching_threshold"`
	// Warn about resources larger than *X* bytes. Values between 0 and 99999000 are allowed.
	ResourcesThreshold *int64 `json:"resourcesThreshold" tf:"resources_threshold"`
	// Warn about slow CDN resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
	SlowCndResourcesThreshold *int64 `json:"slowCndResourcesThreshold" tf:"slow_cnd_resources_threshold"`
	// Warn about slow 1st party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
	SlowFirstPartyResourcesThreshold *int64 `json:"slowFirstPartyResourcesThreshold" tf:"slow_first_party_resources_threshold"`
	// Warn about slow 3rd party resources with a response time above *X* ms. Values between 0 and 99999000 are allowed.
	SlowThirdPartyResourcesThreshold *int64 `json:"slowThirdPartyResourcesThreshold" tf:"slow_third_party_resources_threshold"`
	// Warn if Speed index exceeds *X* % of Visually complete. Values between 1 and 99 are allowed.
	SpeedIndexVisuallyCompleteRatioThreshold *int64 `json:"speedIndexVisuallyCompleteRatioThreshold" tf:"speed_index_visually_complete_ratio_threshold"`
	// Warn about uncompressed resources larger than *X* bytes. Values between 0 and 99999 are allowed.
	UncompressedResourcesThreshold *int64 `json:"uncompressedResourcesThreshold" tf:"uncompressed_resources_threshold"`
}

type ApplicationSpecXhrActionApdexSettings struct {
	// Fallback threshold of an XHR action, defining a tolerable user experience, when the configured KPM is not available. Values between 0 and 240000 are allowed.
	// +optional
	FrustratingFallbackThreshold *int64 `json:"frustratingFallbackThreshold,omitempty" tf:"frustrating_fallback_threshold"`
	// Maximal value of apdex, which is considered as tolerable user experience. Values between 0 and 240000 are allowed.
	// +optional
	FrustratingThreshold *int64 `json:"frustratingThreshold,omitempty" tf:"frustrating_threshold"`
	// no documentation available
	// +optional
	Threshold *int64 `json:"threshold,omitempty" tf:"threshold"`
	// Fallback threshold of an XHR action, defining a satisfied user experience, when the configured KPM is not available. Values between 0 and 60000 are allowed.
	// +optional
	ToleratedFallbackThreshold *int64 `json:"toleratedFallbackThreshold,omitempty" tf:"tolerated_fallback_threshold"`
	// Maximal value of apdex, which is considered as satisfied user experience. Values between 0 and 60000 are allowed.
	// +optional
	ToleratedThreshold *int64 `json:"toleratedThreshold,omitempty" tf:"tolerated_threshold"`
}

type ApplicationSpec struct {
	State *ApplicationSpecResource `json:"state,omitempty" tf:"-"`

	Resource ApplicationSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type ApplicationSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// A list of conversion goals of the application
	// +optional
	ConversionGoals *ApplicationSpecConversionGoals `json:"conversionGoals,omitempty" tf:"conversion_goals"`
	// Analize *X*% of user sessions
	CostControlUserSessionPercentage *int64 `json:"costControlUserSessionPercentage" tf:"cost_control_user_session_percentage"`
	// Defines the Custom Action Apdex settings of an application
	CustomActionApdexSettings *ApplicationSpecCustomActionApdexSettings `json:"customActionApdexSettings" tf:"custom_action_apdex_settings"`
	// User Action names to be flagged as Key User Actions
	// +optional
	KeyUserActions []ApplicationSpecKeyUserActions `json:"keyUserActions,omitempty" tf:"key_user_actions"`
	// Defines the Load Action Apdex settings of an application
	LoadActionApdexSettings *ApplicationSpecLoadActionApdexSettings `json:"loadActionApdexSettings" tf:"load_action_apdex_settings"`
	// The key performance metric of load actions. Possible values are `ACTION_DURATION`, `CUMULATIVE_LAYOUT_SHIFT`, `DOM_INTERACTIVE`, `FIRST_INPUT_DELAY`, `LARGEST_CONTENTFUL_PAINT`, `LOAD_EVENT_END`, `LOAD_EVENT_START`, `RESPONSE_END`, `RESPONSE_START`, `SPEED_INDEX` and `VISUALLY_COMPLETE`
	LoadActionKeyPerformanceMetric *string `json:"loadActionKeyPerformanceMetric" tf:"load_action_key_performance_metric"`
	// Java script agent meta data capture settings
	// +optional
	MetaDataCaptureSettings *ApplicationSpecMetaDataCaptureSettings `json:"metaDataCaptureSettings,omitempty" tf:"meta_data_capture_settings"`
	// Real user monitoring settings
	MonitoringSettings *ApplicationSpecMonitoringSettings `json:"monitoringSettings" tf:"monitoring_settings"`
	// The name of the web application, displayed in the UI
	Name *string `json:"name" tf:"name"`
	// Real user monitoring enabled/disabled
	// +optional
	RealUserMonitoringEnabled *bool `json:"realUserMonitoringEnabled,omitempty" tf:"real_user_monitoring_enabled"`
	// Settings regarding Session Replay
	// +optional
	SessionReplayConfig *ApplicationSpecSessionReplayConfig `json:"sessionReplayConfig,omitempty" tf:"session_replay_config"`
	// The type of the web application. Possible values are `AUTO_INJECTED`, `BROWSER_EXTENSION_INJECTED` and `MANUALLY_INJECTED`
	Type *string `json:"type" tf:"type"`
	// URL injection pattern for manual web application
	// +optional
	UrlInjectionPattern *string `json:"urlInjectionPattern,omitempty" tf:"url_injection_pattern"`
	// User action and session properties settings
	// +optional
	UserActionAndSessionProperties *ApplicationSpecUserActionAndSessionProperties `json:"userActionAndSessionProperties,omitempty" tf:"user_action_and_session_properties"`
	// The settings of user action naming
	// +optional
	UserActionNamingSettings *ApplicationSpecUserActionNamingSettings `json:"userActionNamingSettings,omitempty" tf:"user_action_naming_settings"`
	// User tags settings
	// +optional
	UserTags *ApplicationSpecUserTags `json:"userTags,omitempty" tf:"user_tags"`
	// These settings influence the monitoring data you receive for 3rd party, CDN, and 1st party resources
	WaterfallSettings *ApplicationSpecWaterfallSettings `json:"waterfallSettings" tf:"waterfall_settings"`
	// Defines the XHR Action Apdex settings of an application
	XhrActionApdexSettings *ApplicationSpecXhrActionApdexSettings `json:"xhrActionApdexSettings" tf:"xhr_action_apdex_settings"`
	// The key performance metric of XHR actions. Possible values are `ACTION_DURATION`, `RESPONSE_END`, `RESPONSE_START` and `VISUALLY_COMPLETE`.
	XhrActionKeyPerformanceMetric *string `json:"xhrActionKeyPerformanceMetric" tf:"xhr_action_key_performance_metric"`
}

type ApplicationStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ApplicationList is a list of Applications
type ApplicationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Application CRD objects
	Items []Application `json:"items,omitempty"`
}
