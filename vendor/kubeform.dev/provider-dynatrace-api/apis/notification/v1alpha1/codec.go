/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecAnsibleTower{}).Type1()): NotificationSpecAnsibleTowerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecConfig{}).Type1()):       NotificationSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecEmail{}).Type1()):        NotificationSpecEmailCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecHipchat{}).Type1()):      NotificationSpecHipchatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecJira{}).Type1()):         NotificationSpecJiraCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecOpsGenie{}).Type1()):     NotificationSpecOpsGenieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecPagerDuty{}).Type1()):    NotificationSpecPagerDutyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecServiceNow{}).Type1()):   NotificationSpecServiceNowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecSlack{}).Type1()):        NotificationSpecSlackCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecTrello{}).Type1()):       NotificationSpecTrelloCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecVictorOps{}).Type1()):    NotificationSpecVictorOpsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecWebHook{}).Type1()):      NotificationSpecWebHookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecXmatters{}).Type1()):     NotificationSpecXmattersCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecAnsibleTower{}).Type1()): NotificationSpecAnsibleTowerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecConfig{}).Type1()):       NotificationSpecConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecEmail{}).Type1()):        NotificationSpecEmailCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecHipchat{}).Type1()):      NotificationSpecHipchatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecJira{}).Type1()):         NotificationSpecJiraCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecOpsGenie{}).Type1()):     NotificationSpecOpsGenieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecPagerDuty{}).Type1()):    NotificationSpecPagerDutyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecServiceNow{}).Type1()):   NotificationSpecServiceNowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecSlack{}).Type1()):        NotificationSpecSlackCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecTrello{}).Type1()):       NotificationSpecTrelloCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecVictorOps{}).Type1()):    NotificationSpecVictorOpsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecWebHook{}).Type1()):      NotificationSpecWebHookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecXmatters{}).Type1()):     NotificationSpecXmattersCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type NotificationSpecAnsibleTowerCodec struct {
}

func (NotificationSpecAnsibleTowerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecAnsibleTower)(ptr) == nil
}

func (NotificationSpecAnsibleTowerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecAnsibleTower)(ptr)
	var objs []NotificationSpecAnsibleTower
	if obj != nil {
		objs = []NotificationSpecAnsibleTower{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecAnsibleTower{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecAnsibleTowerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecAnsibleTower)(ptr) = NotificationSpecAnsibleTower{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecAnsibleTower

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecAnsibleTower{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecAnsibleTower)(ptr) = objs[0]
			} else {
				*(*NotificationSpecAnsibleTower)(ptr) = NotificationSpecAnsibleTower{}
			}
		} else {
			*(*NotificationSpecAnsibleTower)(ptr) = NotificationSpecAnsibleTower{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecAnsibleTower

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecAnsibleTower{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecAnsibleTower)(ptr) = obj
		} else {
			*(*NotificationSpecAnsibleTower)(ptr) = NotificationSpecAnsibleTower{}
		}
	default:
		iter.ReportError("decode NotificationSpecAnsibleTower", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecConfigCodec struct {
}

func (NotificationSpecConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecConfig)(ptr) == nil
}

func (NotificationSpecConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecConfig)(ptr)
	var objs []NotificationSpecConfig
	if obj != nil {
		objs = []NotificationSpecConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecConfig)(ptr) = NotificationSpecConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecConfig)(ptr) = objs[0]
			} else {
				*(*NotificationSpecConfig)(ptr) = NotificationSpecConfig{}
			}
		} else {
			*(*NotificationSpecConfig)(ptr) = NotificationSpecConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecConfig)(ptr) = obj
		} else {
			*(*NotificationSpecConfig)(ptr) = NotificationSpecConfig{}
		}
	default:
		iter.ReportError("decode NotificationSpecConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecEmailCodec struct {
}

func (NotificationSpecEmailCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecEmail)(ptr) == nil
}

func (NotificationSpecEmailCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecEmail)(ptr)
	var objs []NotificationSpecEmail
	if obj != nil {
		objs = []NotificationSpecEmail{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecEmail{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecEmailCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecEmail)(ptr) = NotificationSpecEmail{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecEmail

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecEmail{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecEmail)(ptr) = objs[0]
			} else {
				*(*NotificationSpecEmail)(ptr) = NotificationSpecEmail{}
			}
		} else {
			*(*NotificationSpecEmail)(ptr) = NotificationSpecEmail{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecEmail

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecEmail{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecEmail)(ptr) = obj
		} else {
			*(*NotificationSpecEmail)(ptr) = NotificationSpecEmail{}
		}
	default:
		iter.ReportError("decode NotificationSpecEmail", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecHipchatCodec struct {
}

func (NotificationSpecHipchatCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecHipchat)(ptr) == nil
}

func (NotificationSpecHipchatCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecHipchat)(ptr)
	var objs []NotificationSpecHipchat
	if obj != nil {
		objs = []NotificationSpecHipchat{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecHipchat{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecHipchatCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecHipchat)(ptr) = NotificationSpecHipchat{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecHipchat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecHipchat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecHipchat)(ptr) = objs[0]
			} else {
				*(*NotificationSpecHipchat)(ptr) = NotificationSpecHipchat{}
			}
		} else {
			*(*NotificationSpecHipchat)(ptr) = NotificationSpecHipchat{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecHipchat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecHipchat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecHipchat)(ptr) = obj
		} else {
			*(*NotificationSpecHipchat)(ptr) = NotificationSpecHipchat{}
		}
	default:
		iter.ReportError("decode NotificationSpecHipchat", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecJiraCodec struct {
}

func (NotificationSpecJiraCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecJira)(ptr) == nil
}

func (NotificationSpecJiraCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecJira)(ptr)
	var objs []NotificationSpecJira
	if obj != nil {
		objs = []NotificationSpecJira{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecJira{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecJiraCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecJira)(ptr) = NotificationSpecJira{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecJira

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecJira{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecJira)(ptr) = objs[0]
			} else {
				*(*NotificationSpecJira)(ptr) = NotificationSpecJira{}
			}
		} else {
			*(*NotificationSpecJira)(ptr) = NotificationSpecJira{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecJira

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecJira{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecJira)(ptr) = obj
		} else {
			*(*NotificationSpecJira)(ptr) = NotificationSpecJira{}
		}
	default:
		iter.ReportError("decode NotificationSpecJira", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecOpsGenieCodec struct {
}

func (NotificationSpecOpsGenieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecOpsGenie)(ptr) == nil
}

func (NotificationSpecOpsGenieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecOpsGenie)(ptr)
	var objs []NotificationSpecOpsGenie
	if obj != nil {
		objs = []NotificationSpecOpsGenie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecOpsGenie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecOpsGenieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecOpsGenie)(ptr) = NotificationSpecOpsGenie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecOpsGenie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecOpsGenie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecOpsGenie)(ptr) = objs[0]
			} else {
				*(*NotificationSpecOpsGenie)(ptr) = NotificationSpecOpsGenie{}
			}
		} else {
			*(*NotificationSpecOpsGenie)(ptr) = NotificationSpecOpsGenie{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecOpsGenie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecOpsGenie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecOpsGenie)(ptr) = obj
		} else {
			*(*NotificationSpecOpsGenie)(ptr) = NotificationSpecOpsGenie{}
		}
	default:
		iter.ReportError("decode NotificationSpecOpsGenie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecPagerDutyCodec struct {
}

func (NotificationSpecPagerDutyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecPagerDuty)(ptr) == nil
}

func (NotificationSpecPagerDutyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecPagerDuty)(ptr)
	var objs []NotificationSpecPagerDuty
	if obj != nil {
		objs = []NotificationSpecPagerDuty{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecPagerDuty{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecPagerDutyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecPagerDuty)(ptr) = NotificationSpecPagerDuty{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecPagerDuty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecPagerDuty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecPagerDuty)(ptr) = objs[0]
			} else {
				*(*NotificationSpecPagerDuty)(ptr) = NotificationSpecPagerDuty{}
			}
		} else {
			*(*NotificationSpecPagerDuty)(ptr) = NotificationSpecPagerDuty{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecPagerDuty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecPagerDuty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecPagerDuty)(ptr) = obj
		} else {
			*(*NotificationSpecPagerDuty)(ptr) = NotificationSpecPagerDuty{}
		}
	default:
		iter.ReportError("decode NotificationSpecPagerDuty", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecServiceNowCodec struct {
}

func (NotificationSpecServiceNowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecServiceNow)(ptr) == nil
}

func (NotificationSpecServiceNowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecServiceNow)(ptr)
	var objs []NotificationSpecServiceNow
	if obj != nil {
		objs = []NotificationSpecServiceNow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecServiceNow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecServiceNowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecServiceNow)(ptr) = NotificationSpecServiceNow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecServiceNow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecServiceNow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecServiceNow)(ptr) = objs[0]
			} else {
				*(*NotificationSpecServiceNow)(ptr) = NotificationSpecServiceNow{}
			}
		} else {
			*(*NotificationSpecServiceNow)(ptr) = NotificationSpecServiceNow{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecServiceNow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecServiceNow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecServiceNow)(ptr) = obj
		} else {
			*(*NotificationSpecServiceNow)(ptr) = NotificationSpecServiceNow{}
		}
	default:
		iter.ReportError("decode NotificationSpecServiceNow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecSlackCodec struct {
}

func (NotificationSpecSlackCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecSlack)(ptr) == nil
}

func (NotificationSpecSlackCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecSlack)(ptr)
	var objs []NotificationSpecSlack
	if obj != nil {
		objs = []NotificationSpecSlack{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecSlack{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecSlackCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecSlack)(ptr) = NotificationSpecSlack{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecSlack

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecSlack{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecSlack)(ptr) = objs[0]
			} else {
				*(*NotificationSpecSlack)(ptr) = NotificationSpecSlack{}
			}
		} else {
			*(*NotificationSpecSlack)(ptr) = NotificationSpecSlack{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecSlack

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecSlack{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecSlack)(ptr) = obj
		} else {
			*(*NotificationSpecSlack)(ptr) = NotificationSpecSlack{}
		}
	default:
		iter.ReportError("decode NotificationSpecSlack", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecTrelloCodec struct {
}

func (NotificationSpecTrelloCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecTrello)(ptr) == nil
}

func (NotificationSpecTrelloCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecTrello)(ptr)
	var objs []NotificationSpecTrello
	if obj != nil {
		objs = []NotificationSpecTrello{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecTrello{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecTrelloCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecTrello)(ptr) = NotificationSpecTrello{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecTrello

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecTrello{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecTrello)(ptr) = objs[0]
			} else {
				*(*NotificationSpecTrello)(ptr) = NotificationSpecTrello{}
			}
		} else {
			*(*NotificationSpecTrello)(ptr) = NotificationSpecTrello{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecTrello

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecTrello{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecTrello)(ptr) = obj
		} else {
			*(*NotificationSpecTrello)(ptr) = NotificationSpecTrello{}
		}
	default:
		iter.ReportError("decode NotificationSpecTrello", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecVictorOpsCodec struct {
}

func (NotificationSpecVictorOpsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecVictorOps)(ptr) == nil
}

func (NotificationSpecVictorOpsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecVictorOps)(ptr)
	var objs []NotificationSpecVictorOps
	if obj != nil {
		objs = []NotificationSpecVictorOps{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecVictorOps{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecVictorOpsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecVictorOps)(ptr) = NotificationSpecVictorOps{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecVictorOps

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecVictorOps{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecVictorOps)(ptr) = objs[0]
			} else {
				*(*NotificationSpecVictorOps)(ptr) = NotificationSpecVictorOps{}
			}
		} else {
			*(*NotificationSpecVictorOps)(ptr) = NotificationSpecVictorOps{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecVictorOps

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecVictorOps{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecVictorOps)(ptr) = obj
		} else {
			*(*NotificationSpecVictorOps)(ptr) = NotificationSpecVictorOps{}
		}
	default:
		iter.ReportError("decode NotificationSpecVictorOps", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecWebHookCodec struct {
}

func (NotificationSpecWebHookCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecWebHook)(ptr) == nil
}

func (NotificationSpecWebHookCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecWebHook)(ptr)
	var objs []NotificationSpecWebHook
	if obj != nil {
		objs = []NotificationSpecWebHook{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecWebHook{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecWebHookCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecWebHook)(ptr) = NotificationSpecWebHook{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecWebHook

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecWebHook{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecWebHook)(ptr) = objs[0]
			} else {
				*(*NotificationSpecWebHook)(ptr) = NotificationSpecWebHook{}
			}
		} else {
			*(*NotificationSpecWebHook)(ptr) = NotificationSpecWebHook{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecWebHook

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecWebHook{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecWebHook)(ptr) = obj
		} else {
			*(*NotificationSpecWebHook)(ptr) = NotificationSpecWebHook{}
		}
	default:
		iter.ReportError("decode NotificationSpecWebHook", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationSpecXmattersCodec struct {
}

func (NotificationSpecXmattersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationSpecXmatters)(ptr) == nil
}

func (NotificationSpecXmattersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationSpecXmatters)(ptr)
	var objs []NotificationSpecXmatters
	if obj != nil {
		objs = []NotificationSpecXmatters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecXmatters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationSpecXmattersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationSpecXmatters)(ptr) = NotificationSpecXmatters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationSpecXmatters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecXmatters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationSpecXmatters)(ptr) = objs[0]
			} else {
				*(*NotificationSpecXmatters)(ptr) = NotificationSpecXmatters{}
			}
		} else {
			*(*NotificationSpecXmatters)(ptr) = NotificationSpecXmatters{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NotificationSpecXmatters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationSpecXmatters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NotificationSpecXmatters)(ptr) = obj
		} else {
			*(*NotificationSpecXmatters)(ptr) = NotificationSpecXmatters{}
		}
	default:
		iter.ReportError("decode NotificationSpecXmatters", "unexpected JSON type")
	}
}
