/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Naming struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NamingSpec   `json:"spec,omitempty"`
	Status            NamingStatus `json:"status,omitempty"`
}

type NamingSpecConditionsConditionApplicationType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionApplicationTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be APPLICATION_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionAzureComputeMode struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionAzureComputeModeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionAzureSku struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionAzureSkuComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be AZURE_SKU
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionBaseComparisonBasic struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// The type of comparison
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionBaseConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// Defines the actual set of fields depending on the value
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionBitness struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are 32 and 64.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionBitnessComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be BITNESS
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are 32 and 64.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionCloudType struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionCloudTypeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be CLOUD_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// The type of comparison
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomApplicationType struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionCustomApplicationTypeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be CUSTOM_APPLICATION_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionCustomHostMetadataDynamicKey struct {
	// The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomHostMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *NamingSpecConditionsConditionCustomHostMetadataDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey struct {
	// The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomHostMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be HOST_CUSTOM_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomProcessMetadataDynamicKey struct {
	//  The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomProcessMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *NamingSpecConditionsConditionCustomProcessMetadataDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey struct {
	//  The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionCustomProcessMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionDatabaseTopology struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionDatabaseTopologyComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be DATABASE_TOPOLOGY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionDcrumDecoder struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionDcrumDecoderComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be DCRUM_DECODER_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionEntity struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionEntityIDComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be ENTITY_ID
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionHostTechValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type NamingSpecConditionsConditionHostTech struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *NamingSpecConditionsConditionHostTechValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionHypervisor struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionHypervisorTypeComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be HYPERVISOR_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedName struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedNameComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_NAME
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedString struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedStringComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_STRING
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedTag struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *NamingSpecConditionsConditionIndexedTagValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedTagComparisonValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIndexedTagComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_TAG
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *NamingSpecConditionsConditionIndexedTagComparisonValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionInteger struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *int64 `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIntegerComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INTEGER
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *int64 `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIpaddress struct {
	//  The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionIpaddressComparison struct {
	//  The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be IP_ADDRESS
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// Defines the actual set of fields depending on the value
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionMobilePlatform struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionMobilePlatformComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be MOBILE_PLATFORM
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionOsArch struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionOsType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionOsarchitectureComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be OS_ARCHITECTURE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionOstypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be OS_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionPaasType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionPaasTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be PAAS_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionProcessMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionProcessMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionServiceTopology struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionServiceTopologyComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SERVICE_TOPOLOGY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionServiceType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionServiceTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SERVICE_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionSimpleHostTechComparisonValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type NamingSpecConditionsConditionSimpleHostTechComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SIMPLE_HOST_TECH
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *NamingSpecConditionsConditionSimpleHostTechComparisonValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionSimpleTechComparisonValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type NamingSpecConditionsConditionSimpleTechComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SIMPLE_TECH
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *NamingSpecConditionsConditionSimpleTechComparisonValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionString struct {
	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionStringComparison struct {
	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be STRING
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionStringConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	//    - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	//    - `AMAZON_ECR_IMAGE_REGION`
	//    - `AMAZON_LAMBDA_FUNCTION_NAME`
	//    - `AMAZON_REGION`
	//    - `APACHE_CONFIG_PATH`
	//    - `APACHE_SPARK_MASTER_IP_ADDRESS`
	//    - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	//    - `AWS_ECS_CLUSTER`
	//    - `AWS_ECS_CONTAINERNAME`
	//    - `AWS_ECS_FAMILY`
	//    - `AWS_ECS_REVISION`
	//    - `CASSANDRA_CLUSTER_NAME`
	//    - `CATALINA_BASE`
	//    - `CATALINA_HOME`
	//    - `CLOUD_FOUNDRY_APP_ID`
	//    - `CLOUD_FOUNDRY_APP_NAME`
	//    - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	//    - `CLOUD_FOUNDRY_SPACE_ID`
	//    - `CLOUD_FOUNDRY_SPACE_NAME`
	//    - `COLDFUSION_JVM_CONFIG_FILE`
	//    - `COLDFUSION_SERVICE_NAME`
	//    - `COMMAND_LINE_ARGS`
	//    - `DOTNET_COMMAND`
	//    - `DOTNET_COMMAND_PATH`
	//    - `DYNATRACE_CLUSTER_ID`
	//    - `DYNATRACE_NODE_ID`
	//    - `ELASTICSEARCH_CLUSTER_NAME`
	//    - `ELASTICSEARCH_NODE_NAME`
	//    - `EQUINOX_CONFIG_PATH`
	//    - `EXE_NAME`
	//    - `EXE_PATH`
	//    - `GLASS_FISH_DOMAIN_NAME`
	//    - `GLASS_FISH_INSTANCE_NAME`
	//    - `GOOGLE_APP_ENGINE_INSTANCE`
	//    - `GOOGLE_APP_ENGINE_SERVICE`
	//    - `GOOGLE_CLOUD_PROJECT`
	//    - `HYBRIS_BIN_DIRECTORY`
	//    - `HYBRIS_CONFIG_DIRECTORY`
	//    - `HYBRIS_DATA_DIRECTORY`
	//    - `IBM_CICS_REGION`
	//    - `IBM_CTG_NAME`
	//    - `IBM_IMS_CONNECT_REGION`
	//    - `IBM_IMS_CONTROL_REGION`
	//    - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	//    - `IBM_IMS_SOAP_GW_NAME`
	//    - `IBM_INTEGRATION_NODE_NAME`
	//    - `IBM_INTEGRATION_SERVER_NAME`
	//    - `IIS_APP_POOL`
	//    - `IIS_ROLE_NAME`
	//    - `JAVA_JAR_FILE`
	//    - `JAVA_JAR_PATH`
	//    - `JAVA_MAIN_CLASS`
	//    - `JAVA_MAIN_MODULE`
	//    - `JBOSS_HOME`
	//    - `JBOSS_MODE`
	//    - `JBOSS_SERVER_NAME`
	//    - `KUBERNETES_BASE_POD_NAME`
	//    - `KUBERNETES_CONTAINER_NAME`
	//    - `KUBERNETES_FULL_POD_NAME`
	//    - `KUBERNETES_NAMESPACE`
	//    - `KUBERNETES_POD_UID`
	//    - `MSSQL_INSTANCE_NAME`
	//    - `NODE_JS_APP_BASE_DIRECTORY`
	//    - `NODE_JS_APP_NAME`
	//    - `NODE_JS_SCRIPT_NAME`
	//    - `ORACLE_SID`
	//    - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	//    - `PHP_SCRIPT_PATH`
	//    - `PHP_WORKING_DIRECTORY`
	//    - `RUBY_APP_ROOT_PATH`
	//    - `RUBY_SCRIPT_PATH`
	//    - `RULE_RESULT`
	//    - `SOFTWAREAG_INSTALL_ROOT`
	//    - `SOFTWAREAG_PRODUCTPROPNAME`
	//    - `SPRINGBOOT_APP_NAME`
	//    - `SPRINGBOOT_PROFILE_NAME`
	//    - `SPRINGBOOT_STARTUP_CLASS`
	//    - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	//    - `TIBCO_BUSINESSWORKS_CE_VERSION`
	//    - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	//    - `TIBCO_BUSINESS_WORKS_HOME`
	//    - `VARNISH_INSTANCE_NAME`
	//    - `WEB_LOGIC_CLUSTER_NAME`
	//    - `WEB_LOGIC_DOMAIN_NAME`
	//    - `WEB_LOGIC_HOME`
	//    - `WEB_LOGIC_NAME`
	//    - `WEB_SPHERE_CELL_NAME`
	//    - `WEB_SPHERE_CLUSTER_NAME`
	//    - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be `STRING`
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionStringKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	//    - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	//    - `AMAZON_ECR_IMAGE_REGION`
	//    - `AMAZON_LAMBDA_FUNCTION_NAME`
	//    - `AMAZON_REGION`
	//    - `APACHE_CONFIG_PATH`
	//    - `APACHE_SPARK_MASTER_IP_ADDRESS`
	//    - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	//    - `AWS_ECS_CLUSTER`
	//    - `AWS_ECS_CONTAINERNAME`
	//    - `AWS_ECS_FAMILY`
	//    - `AWS_ECS_REVISION`
	//    - `CASSANDRA_CLUSTER_NAME`
	//    - `CATALINA_BASE`
	//    - `CATALINA_HOME`
	//    - `CLOUD_FOUNDRY_APP_ID`
	//    - `CLOUD_FOUNDRY_APP_NAME`
	//    - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	//    - `CLOUD_FOUNDRY_SPACE_ID`
	//    - `CLOUD_FOUNDRY_SPACE_NAME`
	//    - `COLDFUSION_JVM_CONFIG_FILE`
	//    - `COLDFUSION_SERVICE_NAME`
	//    - `COMMAND_LINE_ARGS`
	//    - `DOTNET_COMMAND`
	//    - `DOTNET_COMMAND_PATH`
	//    - `DYNATRACE_CLUSTER_ID`
	//    - `DYNATRACE_NODE_ID`
	//    - `ELASTICSEARCH_CLUSTER_NAME`
	//    - `ELASTICSEARCH_NODE_NAME`
	//    - `EQUINOX_CONFIG_PATH`
	//    - `EXE_NAME`
	//    - `EXE_PATH`
	//    - `GLASS_FISH_DOMAIN_NAME`
	//    - `GLASS_FISH_INSTANCE_NAME`
	//    - `GOOGLE_APP_ENGINE_INSTANCE`
	//    - `GOOGLE_APP_ENGINE_SERVICE`
	//    - `GOOGLE_CLOUD_PROJECT`
	//    - `HYBRIS_BIN_DIRECTORY`
	//    - `HYBRIS_CONFIG_DIRECTORY`
	//    - `HYBRIS_DATA_DIRECTORY`
	//    - `IBM_CICS_REGION`
	//    - `IBM_CTG_NAME`
	//    - `IBM_IMS_CONNECT_REGION`
	//    - `IBM_IMS_CONTROL_REGION`
	//    - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	//    - `IBM_IMS_SOAP_GW_NAME`
	//    - `IBM_INTEGRATION_NODE_NAME`
	//    - `IBM_INTEGRATION_SERVER_NAME`
	//    - `IIS_APP_POOL`
	//    - `IIS_ROLE_NAME`
	//    - `JAVA_JAR_FILE`
	//    - `JAVA_JAR_PATH`
	//    - `JAVA_MAIN_CLASS`
	//    - `JAVA_MAIN_MODULE`
	//    - `JBOSS_HOME`
	//    - `JBOSS_MODE`
	//    - `JBOSS_SERVER_NAME`
	//    - `KUBERNETES_BASE_POD_NAME`
	//    - `KUBERNETES_CONTAINER_NAME`
	//    - `KUBERNETES_FULL_POD_NAME`
	//    - `KUBERNETES_NAMESPACE`
	//    - `KUBERNETES_POD_UID`
	//    - `MSSQL_INSTANCE_NAME`
	//    - `NODE_JS_APP_BASE_DIRECTORY`
	//    - `NODE_JS_APP_NAME`
	//    - `NODE_JS_SCRIPT_NAME`
	//    - `ORACLE_SID`
	//    - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	//    - `PHP_SCRIPT_PATH`
	//    - `PHP_WORKING_DIRECTORY`
	//    - `RUBY_APP_ROOT_PATH`
	//    - `RUBY_SCRIPT_PATH`
	//    - `RULE_RESULT`
	//    - `SOFTWAREAG_INSTALL_ROOT`
	//    - `SOFTWAREAG_PRODUCTPROPNAME`
	//    - `SPRINGBOOT_APP_NAME`
	//    - `SPRINGBOOT_PROFILE_NAME`
	//    - `SPRINGBOOT_STARTUP_CLASS`
	//    - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	//    - `TIBCO_BUSINESSWORKS_CE_VERSION`
	//    - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	//    - `TIBCO_BUSINESS_WORKS_HOME`
	//    - `VARNISH_INSTANCE_NAME`
	//    - `WEB_LOGIC_CLUSTER_NAME`
	//    - `WEB_LOGIC_DOMAIN_NAME`
	//    - `WEB_LOGIC_HOME`
	//    - `WEB_LOGIC_NAME`
	//    - `WEB_SPHERE_CELL_NAME`
	//    - `WEB_SPHERE_CLUSTER_NAME`
	//    - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionSyntheticEngine struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionSyntheticEngineTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SYNTHETIC_ENGINE_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionTag struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *NamingSpecConditionsConditionTagValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionTagComparisonValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionTagComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be TAG
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *NamingSpecConditionsConditionTagComparisonValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionTechValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type NamingSpecConditionsConditionTech struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *NamingSpecConditionsConditionTechValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsCondition struct {
	// Comparison for `APPLICATION_TYPE` attributes
	// +optional
	ApplicationType []NamingSpecConditionsConditionApplicationType `json:"applicationType,omitempty" tf:"application_type"`
	// Comparison for `APPLICATION_TYPE` attributes
	// +optional
	// Deprecated
	ApplicationTypeComparison []NamingSpecConditionsConditionApplicationTypeComparison `json:"applicationTypeComparison,omitempty" tf:"application_type_comparison"`
	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +optional
	// Deprecated
	AzureComputeMode []NamingSpecConditionsConditionAzureComputeMode `json:"azureComputeMode,omitempty" tf:"azure_compute_mode"`
	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +optional
	AzureComputeModeComparison []NamingSpecConditionsConditionAzureComputeModeComparison `json:"azureComputeModeComparison,omitempty" tf:"azure_compute_mode_comparison"`
	// Comparison for `AZURE_SKU` attributes
	// +optional
	AzureSku []NamingSpecConditionsConditionAzureSku `json:"azureSku,omitempty" tf:"azure_sku"`
	// Comparison for `AZURE_SKU` attributes
	// +optional
	// Deprecated
	AzureSkuComparision []NamingSpecConditionsConditionAzureSkuComparision `json:"azureSkuComparision,omitempty" tf:"azure_sku_comparision"`
	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +optional
	// Deprecated
	BaseComparisonBasic []NamingSpecConditionsConditionBaseComparisonBasic `json:"baseComparisonBasic,omitempty" tf:"base_comparison_basic"`
	// Fallback for not yet known type
	// +optional
	// Deprecated
	BaseConditionKey []NamingSpecConditionsConditionBaseConditionKey `json:"baseConditionKey,omitempty" tf:"base_condition_key"`
	// Comparison for `BITNESS` attributes
	// +optional
	Bitness []NamingSpecConditionsConditionBitness `json:"bitness,omitempty" tf:"bitness"`
	// Comparison for `BITNESS` attributes
	// +optional
	// Deprecated
	BitnessComparision []NamingSpecConditionsConditionBitnessComparision `json:"bitnessComparision,omitempty" tf:"bitness_comparision"`
	// Comparison for `CLOUD_TYPE` attributes
	// +optional
	CloudType []NamingSpecConditionsConditionCloudType `json:"cloudType,omitempty" tf:"cloud_type"`
	// Comparison for `CLOUD_TYPE` attributes
	// +optional
	// Deprecated
	CloudTypeComparison []NamingSpecConditionsConditionCloudTypeComparison `json:"cloudTypeComparison,omitempty" tf:"cloud_type_comparison"`
	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +optional
	Comparison []NamingSpecConditionsConditionComparison `json:"comparison,omitempty" tf:"comparison"`
	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +optional
	CustomApplicationType []NamingSpecConditionsConditionCustomApplicationType `json:"customApplicationType,omitempty" tf:"custom_application_type"`
	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +optional
	// Deprecated
	CustomApplicationTypeComparison []NamingSpecConditionsConditionCustomApplicationTypeComparison `json:"customApplicationTypeComparison,omitempty" tf:"custom_application_type_comparison"`
	// Key for Custom Host Metadata
	// +optional
	CustomHostMetadata []NamingSpecConditionsConditionCustomHostMetadata `json:"customHostMetadata,omitempty" tf:"custom_host_metadata"`
	// Key for Custom Host Metadata
	// +optional
	// Deprecated
	CustomHostMetadataConditionKey []NamingSpecConditionsConditionCustomHostMetadataConditionKey `json:"customHostMetadataConditionKey,omitempty" tf:"custom_host_metadata_condition_key"`
	// Key for Custom Process Metadata
	// +optional
	CustomProcessMetadata []NamingSpecConditionsConditionCustomProcessMetadata `json:"customProcessMetadata,omitempty" tf:"custom_process_metadata"`
	// Key for Custom Process Metadata
	// +optional
	// Deprecated
	CustomProcessMetadataConditionKey []NamingSpecConditionsConditionCustomProcessMetadataConditionKey `json:"customProcessMetadataConditionKey,omitempty" tf:"custom_process_metadata_condition_key"`
	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +optional
	DatabaseTopology []NamingSpecConditionsConditionDatabaseTopology `json:"databaseTopology,omitempty" tf:"database_topology"`
	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +optional
	// Deprecated
	DatabaseTopologyComparison []NamingSpecConditionsConditionDatabaseTopologyComparison `json:"databaseTopologyComparison,omitempty" tf:"database_topology_comparison"`
	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +optional
	DcrumDecoder []NamingSpecConditionsConditionDcrumDecoder `json:"dcrumDecoder,omitempty" tf:"dcrum_decoder"`
	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +optional
	// Deprecated
	DcrumDecoderComparison []NamingSpecConditionsConditionDcrumDecoderComparison `json:"dcrumDecoderComparison,omitempty" tf:"dcrum_decoder_comparison"`
	// Comparison for `ENTITY_ID` attributes
	// +optional
	Entity []NamingSpecConditionsConditionEntity `json:"entity,omitempty" tf:"entity"`
	// Comparison for `ENTITY_ID` attributes
	// +optional
	// Deprecated
	EntityIDComparison []NamingSpecConditionsConditionEntityIDComparison `json:"entityIDComparison,omitempty" tf:"entity_id_comparison"`
	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +optional
	HostTech []NamingSpecConditionsConditionHostTech `json:"hostTech,omitempty" tf:"host_tech"`
	// Comparison for `HYPERVISOR_TYPE` attributes
	// +optional
	Hypervisor []NamingSpecConditionsConditionHypervisor `json:"hypervisor,omitempty" tf:"hypervisor"`
	// `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
	// +optional
	// Deprecated
	HypervisorTypeComparision []NamingSpecConditionsConditionHypervisorTypeComparision `json:"hypervisorTypeComparision,omitempty" tf:"hypervisor_type_comparision"`
	// Comparison for `INDEXED_NAME` attributes
	// +optional
	IndexedName []NamingSpecConditionsConditionIndexedName `json:"indexedName,omitempty" tf:"indexed_name"`
	// Comparison for `INDEXED_NAME` attributes
	// +optional
	// Deprecated
	IndexedNameComparison []NamingSpecConditionsConditionIndexedNameComparison `json:"indexedNameComparison,omitempty" tf:"indexed_name_comparison"`
	// Comparison for `INDEXED_STRING` attributes
	// +optional
	IndexedString []NamingSpecConditionsConditionIndexedString `json:"indexedString,omitempty" tf:"indexed_string"`
	// Comparison for `INDEXED_STRING` attributes
	// +optional
	// Deprecated
	IndexedStringComparison []NamingSpecConditionsConditionIndexedStringComparison `json:"indexedStringComparison,omitempty" tf:"indexed_string_comparison"`
	// Comparison for `INDEXED_TAG` attributes
	// +optional
	IndexedTag []NamingSpecConditionsConditionIndexedTag `json:"indexedTag,omitempty" tf:"indexed_tag"`
	// Comparison for `INDEXED_TAG` attributes
	// +optional
	// Deprecated
	IndexedTagComparison []NamingSpecConditionsConditionIndexedTagComparison `json:"indexedTagComparison,omitempty" tf:"indexed_tag_comparison"`
	// Comparison for `INTEGER` attributes
	// +optional
	Integer []NamingSpecConditionsConditionInteger `json:"integer,omitempty" tf:"integer"`
	// Comparison for `INTEGER` attributes
	// +optional
	// Deprecated
	IntegerComparison []NamingSpecConditionsConditionIntegerComparison `json:"integerComparison,omitempty" tf:"integer_comparison"`
	// Comparison for `IP_ADDRESS` attributes
	// +optional
	Ipaddress []NamingSpecConditionsConditionIpaddress `json:"ipaddress,omitempty" tf:"ipaddress"`
	// Comparison for `IP_ADDRESS` attributes
	// +optional
	// Deprecated
	IpaddressComparison []NamingSpecConditionsConditionIpaddressComparison `json:"ipaddressComparison,omitempty" tf:"ipaddress_comparison"`
	// Fallback for not yet known type
	// +optional
	Key []NamingSpecConditionsConditionKey `json:"key,omitempty" tf:"key"`
	// Comparison for `MOBILE_PLATFORM` attributes
	// +optional
	MobilePlatform []NamingSpecConditionsConditionMobilePlatform `json:"mobilePlatform,omitempty" tf:"mobile_platform"`
	// Comparison for `MOBILE_PLATFORM` attributes
	// +optional
	// Deprecated
	MobilePlatformComparison []NamingSpecConditionsConditionMobilePlatformComparison `json:"mobilePlatformComparison,omitempty" tf:"mobile_platform_comparison"`
	// Comparison for `OS_ARCHITECTURE` attributes
	// +optional
	OsArch []NamingSpecConditionsConditionOsArch `json:"osArch,omitempty" tf:"os_arch"`
	// Comparison for `OS_TYPE` attributes
	// +optional
	OsType []NamingSpecConditionsConditionOsType `json:"osType,omitempty" tf:"os_type"`
	// Comparison for `OS_ARCHITECTURE` attributes
	// +optional
	// Deprecated
	OsarchitectureComparison []NamingSpecConditionsConditionOsarchitectureComparison `json:"osarchitectureComparison,omitempty" tf:"osarchitecture_comparison"`
	// Comparison for `OS_TYPE` attributes
	// +optional
	// Deprecated
	OstypeComparison []NamingSpecConditionsConditionOstypeComparison `json:"ostypeComparison,omitempty" tf:"ostype_comparison"`
	// Comparison for `PAAS_TYPE` attributes
	// +optional
	PaasType []NamingSpecConditionsConditionPaasType `json:"paasType,omitempty" tf:"paas_type"`
	// Comparison for `PAAS_TYPE` attributes
	// +optional
	// Deprecated
	PaasTypeComparison []NamingSpecConditionsConditionPaasTypeComparison `json:"paasTypeComparison,omitempty" tf:"paas_type_comparison"`
	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +optional
	ProcessMetadata []NamingSpecConditionsConditionProcessMetadata `json:"processMetadata,omitempty" tf:"process_metadata"`
	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +optional
	// Deprecated
	ProcessMetadataConditionKey []NamingSpecConditionsConditionProcessMetadataConditionKey `json:"processMetadataConditionKey,omitempty" tf:"process_metadata_condition_key"`
	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +optional
	ServiceTopology []NamingSpecConditionsConditionServiceTopology `json:"serviceTopology,omitempty" tf:"service_topology"`
	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +optional
	// Deprecated
	ServiceTopologyComparison []NamingSpecConditionsConditionServiceTopologyComparison `json:"serviceTopologyComparison,omitempty" tf:"service_topology_comparison"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	ServiceType []NamingSpecConditionsConditionServiceType `json:"serviceType,omitempty" tf:"service_type"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	// Deprecated
	ServiceTypeComparison []NamingSpecConditionsConditionServiceTypeComparison `json:"serviceTypeComparison,omitempty" tf:"service_type_comparison"`
	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +optional
	// Deprecated
	SimpleHostTechComparison []NamingSpecConditionsConditionSimpleHostTechComparison `json:"simpleHostTechComparison,omitempty" tf:"simple_host_tech_comparison"`
	// Comparison for `SIMPLE_TECH` attributes
	// +optional
	// Deprecated
	SimpleTechComparison []NamingSpecConditionsConditionSimpleTechComparison `json:"simpleTechComparison,omitempty" tf:"simple_tech_comparison"`
	// Comparison for `STRING` attributes
	// +optional
	String []NamingSpecConditionsConditionString `json:"string,omitempty" tf:"string"`
	// Comparison for `STRING` attributes
	// +optional
	// Deprecated
	StringComparison []NamingSpecConditionsConditionStringComparison `json:"stringComparison,omitempty" tf:"string_comparison"`
	//  The key for dynamic attributes of the `STRING` type
	// +optional
	// Deprecated
	StringConditionKey []NamingSpecConditionsConditionStringConditionKey `json:"stringConditionKey,omitempty" tf:"string_condition_key"`
	//  The key for dynamic attributes of the `STRING` type
	// +optional
	StringKey []NamingSpecConditionsConditionStringKey `json:"stringKey,omitempty" tf:"string_key"`
	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +optional
	SyntheticEngine []NamingSpecConditionsConditionSyntheticEngine `json:"syntheticEngine,omitempty" tf:"synthetic_engine"`
	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +optional
	// Deprecated
	SyntheticEngineTypeComparison []NamingSpecConditionsConditionSyntheticEngineTypeComparison `json:"syntheticEngineTypeComparison,omitempty" tf:"synthetic_engine_type_comparison"`
	// Comparison for `TAG` attributes
	// +optional
	Tag []NamingSpecConditionsConditionTag `json:"tag,omitempty" tf:"tag"`
	// Comparison for `TAG` attributes
	// +optional
	// Deprecated
	TagComparison []NamingSpecConditionsConditionTagComparison `json:"tagComparison,omitempty" tf:"tag_comparison"`
	// Comparison for `SIMPLE_TECH` attributes
	// +optional
	Tech []NamingSpecConditionsConditionTech `json:"tech,omitempty" tf:"tech"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditions struct {
	// A conditions for the metric usage
	// +optional
	// +kubebuilder:validation:MinItems=1
	Condition []NamingSpecConditionsCondition `json:"condition,omitempty" tf:"condition"`
}

type NamingSpec struct {
	State *NamingSpecResource `json:"state,omitempty" tf:"-"`

	Resource NamingSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type NamingSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// A list of matching conditions of the rule.  The rule applies only if **all** conditions are fulfilled
	// +optional
	// +kubebuilder:validation:MinItems=1
	Conditions []NamingSpecConditions `json:"conditions,omitempty" tf:"conditions"`
	// The rule is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled" tf:"enabled"`
	// The name to be assigned to matching entities. You can use the following placeholders here:  * `{AwsAutoScalingGroup:Name}`  * `{AwsAvailabilityZone:Name}`  * `{AwsElasticLoadBalancer:Name}`  * `{AwsRelationalDatabaseService:DBName}`  * `{AwsRelationalDatabaseService:Endpoint}`  * `{AwsRelationalDatabaseService:Engine}`  * `{AwsRelationalDatabaseService:InstanceClass}`  * `{AwsRelationalDatabaseService:Name}`  * `{AwsRelationalDatabaseService:Port}`  * `{AzureRegion:Name}`  * `{AzureScaleSet:Name}`  * `{AzureVm:Name}`  * `{CloudFoundryOrganization:Name}`  * `{CustomDevice:DetectedName}`  * `{CustomDevice:DnsName}`  * `{CustomDevice:IpAddress}`  * `{CustomDevice:Port}`  * `{DockerContainerGroupInstance:ContainerName}`  * `{DockerContainerGroupInstance:FullImageName}`  * `{DockerContainerGroupInstance:ImageVersion}`  * `{DockerContainerGroupInstance:StrippedImageName}`  * `{ESXIHost:HardwareModel}`  * `{ESXIHost:HardwareVendor}`  * `{ESXIHost:Name}`  * `{ESXIHost:ProductName}`  * `{ESXIHost:ProductVersion}`  * `{Ec2Instance:AmiId}`  * `{Ec2Instance:BeanstalkEnvironmentName}`  * `{Ec2Instance:InstanceId}`  * `{Ec2Instance:InstanceType}`  * `{Ec2Instance:LocalHostName}`  * `{Ec2Instance:Name}`  * `{Ec2Instance:PublicHostName}`  * `{Ec2Instance:SecurityGroup}`  * `{GoogleComputeInstance:Id}`  * `{GoogleComputeInstance:IpAddresses}`  * `{GoogleComputeInstance:MachineType}`  * `{GoogleComputeInstance:Name}`  * `{GoogleComputeInstance:ProjectId}`  * `{GoogleComputeInstance:Project}`  * `{Host:AWSNameTag}`  * `{Host:AixLogicalCpuCount}`  * `{Host:AzureHostName}`  * `{Host:AzureSiteName}`  * `{Host:BoshDeploymentId}`  * `{Host:BoshInstanceId}`  * `{Host:BoshInstanceName}`  * `{Host:BoshName}`  * `{Host:BoshStemcellVersion}`  * `{Host:CpuCores}`  * `{Host:DetectedName}`  * `{Host:Environment:AppName}`  * `{Host:Environment:BoshReleaseVersion}`  * `{Host:Environment:Environment}`  * `{Host:Environment:Link}`  * `{Host:Environment:Organization}`  * `{Host:Environment:Owner}`  * `{Host:Environment:Support}`  * `{Host:IpAddress}`  * `{Host:LogicalCpuCores}`  * `{Host:OneAgentCustomHostName}`  * `{Host:OperatingSystemVersion}`  * `{Host:PaasMemoryLimit}`  * `{HostGroup:Name}`  * `{KubernetesCluster:Name}`  * `{KubernetesNode:DetectedName}`  * `{OpenstackAvailabilityZone:Name}`  * `{OpenstackZone:Name}`  * `{OpenstackComputeNode:Name}`  * `{OpenstackProject:Name}`  * `{OpenstackVm:InstanceType}`  * `{OpenstackVm:Name}`  * `{OpenstackVm:SecurityGroup}`  * `{ProcessGroup:AmazonECRImageAccountId}`  * `{ProcessGroup:AmazonECRImageRegion}`  * `{ProcessGroup:AmazonECSCluster}`  * `{ProcessGroup:AmazonECSContainerName}`  * `{ProcessGroup:AmazonECSFamily}`  * `{ProcessGroup:AmazonECSRevision}`  * `{ProcessGroup:AmazonLambdaFunctionName}`  * `{ProcessGroup:AmazonRegion}`  * `{ProcessGroup:ApacheConfigPath}`  * `{ProcessGroup:ApacheSparkMasterIpAddress}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AzureHostName}`  * `{ProcessGroup:AzureSiteName}`  * `{ProcessGroup:CassandraClusterName}`  * `{ProcessGroup:CatalinaBase}`  * `{ProcessGroup:CatalinaHome}`  * `{ProcessGroup:CloudFoundryAppId}`  * `{ProcessGroup:CloudFoundryAppName}`  * `{ProcessGroup:CloudFoundryInstanceIndex}`  * `{ProcessGroup:CloudFoundrySpaceId}`  * `{ProcessGroup:CloudFoundrySpaceName}`  * `{ProcessGroup:ColdFusionJvmConfigFile}`  * `{ProcessGroup:ColdFusionServiceName}`  * `{ProcessGroup:CommandLineArgs}`  * `{ProcessGroup:DetectedName}`  * `{ProcessGroup:DotNetCommandPath}`  * `{ProcessGroup:DotNetCommand}`  * `{ProcessGroup:DotNetClusterId}`  * `{ProcessGroup:DotNetNodeId}`  * `{ProcessGroup:ElasticsearchClusterName}`  * `{ProcessGroup:ElasticsearchNodeName}`  * `{ProcessGroup:EquinoxConfigPath}`  * `{ProcessGroup:ExeName}`  * `{ProcessGroup:ExePath}`  * `{ProcessGroup:GlassFishDomainName}`  * `{ProcessGroup:GlassFishInstanceName}`  * `{ProcessGroup:GoogleAppEngineInstance}`  * `{ProcessGroup:GoogleAppEngineService}`  * `{ProcessGroup:GoogleCloudProject}`  * `{ProcessGroup:HybrisBinDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisDataDirectory}`  * `{ProcessGroup:IBMCicsRegion}`  * `{ProcessGroup:IBMCtgName}`  * `{ProcessGroup:IBMImsConnectRegion}`  * `{ProcessGroup:IBMImsControlRegion}`  * `{ProcessGroup:IBMImsMessageProcessingRegion}`  * `{ProcessGroup:IBMImsSoapGwName}`  * `{ProcessGroup:IBMIntegrationNodeName}`  * `{ProcessGroup:IBMIntegrationServerName}`  * `{ProcessGroup:IISAppPool}`  * `{ProcessGroup:IISRoleName}`  * `{ProcessGroup:JbossHome}`  * `{ProcessGroup:JbossMode}`  * `{ProcessGroup:JbossServerName}`  * `{ProcessGroup:JavaJarFile}`  * `{ProcessGroup:JavaJarPath}`  * `{ProcessGroup:JavaMainCLass}`  * `{ProcessGroup:KubernetesBasePodName}`  * `{ProcessGroup:KubernetesContainerName}`  * `{ProcessGroup:KubernetesFullPodName}`  * `{ProcessGroup:KubernetesNamespace}`  * `{ProcessGroup:KubernetesPodUid}`  * `{ProcessGroup:MssqlInstanceName}`  * `{ProcessGroup:NodeJsAppBaseDirectory}`  * `{ProcessGroup:NodeJsAppName}`  * `{ProcessGroup:NodeJsScriptName}`  * `{ProcessGroup:OracleSid}`  * `{ProcessGroup:PHPScriptPath}`  * `{ProcessGroup:PHPWorkingDirectory}`  * `{ProcessGroup:Ports}`  * `{ProcessGroup:RubyAppRootPath}`  * `{ProcessGroup:RubyScriptPath}`  * `{ProcessGroup:SoftwareAGInstallRoot}`  * `{ProcessGroup:SoftwareAGProductPropertyName}`  * `{ProcessGroup:SpringBootAppName}`  * `{ProcessGroup:SpringBootProfileName}`  * `{ProcessGroup:SpringBootStartupClass}`  * `{ProcessGroup:TIBCOBusinessWorksAppNodeName}`  * `{ProcessGroup:TIBCOBusinessWorksAppSpaceName}`  * `{ProcessGroup:TIBCOBusinessWorksCeAppName}`  * `{ProcessGroup:TIBCOBusinessWorksCeVersion}`  * `{ProcessGroup:TIBCOBusinessWorksDomainName}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFilePath}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFile}`  * `{ProcessGroup:TIBCOBusinessWorksHome}`  * `{ProcessGroup:VarnishInstanceName}`  * `{ProcessGroup:WebLogicClusterName}`  * `{ProcessGroup:WebLogicDomainName}`  * `{ProcessGroup:WebLogicHome}`  * `{ProcessGroup:WebLogicName}`  * `{ProcessGroup:WebSphereCellName}`  * `{ProcessGroup:WebSphereClusterName}`  * `{ProcessGroup:WebSphereNodeName}`  * `{ProcessGroup:WebSphereServerName}`  * `{ProcessGroup:ActorSystem}`  * `{Service:STGServerName}`  * `{Service:DatabaseHostName}`  * `{Service:DatabaseName}`  * `{Service:DatabaseVendor}`  * `{Service:DetectedName}`  * `{Service:EndpointPath}`  * `{Service:EndpointPathGatewayUrl}`  * `{Service:IIBApplicationName}`  * `{Service:MessageListenerClassName}`  * `{Service:Port}`  * `{Service:PublicDomainName}`  * `{Service:RemoteEndpoint}`  * `{Service:RemoteName}`  * `{Service:WebApplicationId}`  * `{Service:WebContextRoot}`  * `{Service:WebServerName}`  * `{Service:WebServiceNamespace}`  * `{Service:WebServiceName}`  * `{VmwareDatacenter:Name}`  * `{VmwareVm:Name}
	Format *string `json:"format" tf:"format"`
	// The name of the rule
	Name *string `json:"name" tf:"name"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// NamingList is a list of Namings
type NamingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Naming CRD objects
	Items []Naming `json:"items,omitempty"`
}
