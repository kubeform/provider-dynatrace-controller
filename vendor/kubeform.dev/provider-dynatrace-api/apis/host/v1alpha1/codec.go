/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecConnections{}).Type1()):                                                 AnomaliesSpecConnectionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpu{}).Type1()):                                                         AnomaliesSpecCpuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpuThresholds{}).Type1()):                                               AnomaliesSpecCpuThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisks{}).Type1()):                                                       AnomaliesSpecDisksCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodes{}).Type1()):                                                 AnomaliesSpecDisksInodesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodesThresholds{}).Type1()):                                       AnomaliesSpecDisksInodesThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpace{}).Type1()):                                                  AnomaliesSpecDisksSpaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpaceThresholds{}).Type1()):                                        AnomaliesSpecDisksSpaceThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeed{}).Type1()):                                                  AnomaliesSpecDisksSpeedCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeedThresholds{}).Type1()):                                        AnomaliesSpecDisksSpeedThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGc{}).Type1()):                                                          AnomaliesSpecGcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGcThresholds{}).Type1()):                                                AnomaliesSpecGcThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJava{}).Type1()):                                                        AnomaliesSpecJavaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemory{}).Type1()):                                             AnomaliesSpecJavaOutOfMemoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemoryThresholds{}).Type1()):                                   AnomaliesSpecJavaOutOfMemoryThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreads{}).Type1()):                                            AnomaliesSpecJavaOutOfThreadsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreadsThresholds{}).Type1()):                                  AnomaliesSpecJavaOutOfThreadsThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemory{}).Type1()):                                                      AnomaliesSpecMemoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholds{}).Type1()):                                            AnomaliesSpecMemoryThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsLinux{}).Type1()):                                       AnomaliesSpecMemoryThresholdsLinuxCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsWindows{}).Type1()):                                     AnomaliesSpecMemoryThresholdsWindowsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetwork{}).Type1()):                                                     AnomaliesSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivity{}).Type1()):                                         AnomaliesSpecNetworkConnectivityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivityThresholds{}).Type1()):                               AnomaliesSpecNetworkConnectivityThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPackets{}).Type1()):                                       AnomaliesSpecNetworkDroppedPacketsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPacketsThresholds{}).Type1()):                             AnomaliesSpecNetworkDroppedPacketsThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrors{}).Type1()):                                               AnomaliesSpecNetworkErrorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrorsThresholds{}).Type1()):                                     AnomaliesSpecNetworkErrorsThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmission{}).Type1()):                                       AnomaliesSpecNetworkRetransmissionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmissionThresholds{}).Type1()):                             AnomaliesSpecNetworkRetransmissionThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilization{}).Type1()):                                          AnomaliesSpecNetworkUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilizationThresholds{}).Type1()):                                AnomaliesSpecNetworkUtilizationThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1()):                NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1()):             NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1()):                               NamingSpecConditionsConditionHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1()):                             NamingSpecConditionsConditionIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1()):                   NamingSpecConditionsConditionIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1()):               NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1()):                   NamingSpecConditionsConditionSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1()):                                    NamingSpecConditionsConditionTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1()):                          NamingSpecConditionsConditionTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1()):                                   NamingSpecConditionsConditionTechValueCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecConnections{}).Type1()):                                                 AnomaliesSpecConnectionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpu{}).Type1()):                                                         AnomaliesSpecCpuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpuThresholds{}).Type1()):                                               AnomaliesSpecCpuThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisks{}).Type1()):                                                       AnomaliesSpecDisksCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodes{}).Type1()):                                                 AnomaliesSpecDisksInodesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodesThresholds{}).Type1()):                                       AnomaliesSpecDisksInodesThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpace{}).Type1()):                                                  AnomaliesSpecDisksSpaceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpaceThresholds{}).Type1()):                                        AnomaliesSpecDisksSpaceThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeed{}).Type1()):                                                  AnomaliesSpecDisksSpeedCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeedThresholds{}).Type1()):                                        AnomaliesSpecDisksSpeedThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGc{}).Type1()):                                                          AnomaliesSpecGcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGcThresholds{}).Type1()):                                                AnomaliesSpecGcThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJava{}).Type1()):                                                        AnomaliesSpecJavaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemory{}).Type1()):                                             AnomaliesSpecJavaOutOfMemoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemoryThresholds{}).Type1()):                                   AnomaliesSpecJavaOutOfMemoryThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreads{}).Type1()):                                            AnomaliesSpecJavaOutOfThreadsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreadsThresholds{}).Type1()):                                  AnomaliesSpecJavaOutOfThreadsThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemory{}).Type1()):                                                      AnomaliesSpecMemoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholds{}).Type1()):                                            AnomaliesSpecMemoryThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsLinux{}).Type1()):                                       AnomaliesSpecMemoryThresholdsLinuxCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsWindows{}).Type1()):                                     AnomaliesSpecMemoryThresholdsWindowsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetwork{}).Type1()):                                                     AnomaliesSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivity{}).Type1()):                                         AnomaliesSpecNetworkConnectivityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivityThresholds{}).Type1()):                               AnomaliesSpecNetworkConnectivityThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPackets{}).Type1()):                                       AnomaliesSpecNetworkDroppedPacketsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPacketsThresholds{}).Type1()):                             AnomaliesSpecNetworkDroppedPacketsThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrors{}).Type1()):                                               AnomaliesSpecNetworkErrorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrorsThresholds{}).Type1()):                                     AnomaliesSpecNetworkErrorsThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmission{}).Type1()):                                       AnomaliesSpecNetworkRetransmissionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmissionThresholds{}).Type1()):                             AnomaliesSpecNetworkRetransmissionThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilization{}).Type1()):                                          AnomaliesSpecNetworkUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilizationThresholds{}).Type1()):                                AnomaliesSpecNetworkUtilizationThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1()):                NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1()):             NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1()):                               NamingSpecConditionsConditionHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1()):                             NamingSpecConditionsConditionIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1()):                   NamingSpecConditionsConditionIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1()):               NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1()):                   NamingSpecConditionsConditionSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1()):                                    NamingSpecConditionsConditionTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1()):                          NamingSpecConditionsConditionTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1()):                                   NamingSpecConditionsConditionTechValueCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecConnectionsCodec struct {
}

func (AnomaliesSpecConnectionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecConnections)(ptr) == nil
}

func (AnomaliesSpecConnectionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecConnections)(ptr)
	var objs []AnomaliesSpecConnections
	if obj != nil {
		objs = []AnomaliesSpecConnections{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecConnections{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecConnectionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecConnections)(ptr) = AnomaliesSpecConnections{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecConnections

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecConnections{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecConnections)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecConnections)(ptr) = AnomaliesSpecConnections{}
			}
		} else {
			*(*AnomaliesSpecConnections)(ptr) = AnomaliesSpecConnections{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecConnections

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecConnections{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecConnections)(ptr) = obj
		} else {
			*(*AnomaliesSpecConnections)(ptr) = AnomaliesSpecConnections{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecConnections", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecCpuCodec struct {
}

func (AnomaliesSpecCpuCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecCpu)(ptr) == nil
}

func (AnomaliesSpecCpuCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecCpu)(ptr)
	var objs []AnomaliesSpecCpu
	if obj != nil {
		objs = []AnomaliesSpecCpu{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpu{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecCpuCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecCpu)(ptr) = AnomaliesSpecCpu{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecCpu

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpu{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecCpu)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecCpu)(ptr) = AnomaliesSpecCpu{}
			}
		} else {
			*(*AnomaliesSpecCpu)(ptr) = AnomaliesSpecCpu{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecCpu

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpu{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecCpu)(ptr) = obj
		} else {
			*(*AnomaliesSpecCpu)(ptr) = AnomaliesSpecCpu{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecCpu", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecCpuThresholdsCodec struct {
}

func (AnomaliesSpecCpuThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecCpuThresholds)(ptr) == nil
}

func (AnomaliesSpecCpuThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecCpuThresholds)(ptr)
	var objs []AnomaliesSpecCpuThresholds
	if obj != nil {
		objs = []AnomaliesSpecCpuThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpuThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecCpuThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecCpuThresholds)(ptr) = AnomaliesSpecCpuThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecCpuThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpuThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecCpuThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecCpuThresholds)(ptr) = AnomaliesSpecCpuThresholds{}
			}
		} else {
			*(*AnomaliesSpecCpuThresholds)(ptr) = AnomaliesSpecCpuThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecCpuThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecCpuThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecCpuThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecCpuThresholds)(ptr) = AnomaliesSpecCpuThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecCpuThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksCodec struct {
}

func (AnomaliesSpecDisksCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisks)(ptr) == nil
}

func (AnomaliesSpecDisksCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisks)(ptr)
	var objs []AnomaliesSpecDisks
	if obj != nil {
		objs = []AnomaliesSpecDisks{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisks{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisks)(ptr) = AnomaliesSpecDisks{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisks

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisks{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisks)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisks)(ptr) = AnomaliesSpecDisks{}
			}
		} else {
			*(*AnomaliesSpecDisks)(ptr) = AnomaliesSpecDisks{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisks

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisks{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisks)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisks)(ptr) = AnomaliesSpecDisks{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisks", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksInodesCodec struct {
}

func (AnomaliesSpecDisksInodesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisksInodes)(ptr) == nil
}

func (AnomaliesSpecDisksInodesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisksInodes)(ptr)
	var objs []AnomaliesSpecDisksInodes
	if obj != nil {
		objs = []AnomaliesSpecDisksInodes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksInodesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisksInodes)(ptr) = AnomaliesSpecDisksInodes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisksInodes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisksInodes)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisksInodes)(ptr) = AnomaliesSpecDisksInodes{}
			}
		} else {
			*(*AnomaliesSpecDisksInodes)(ptr) = AnomaliesSpecDisksInodes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisksInodes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisksInodes)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisksInodes)(ptr) = AnomaliesSpecDisksInodes{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisksInodes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksInodesThresholdsCodec struct {
}

func (AnomaliesSpecDisksInodesThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisksInodesThresholds)(ptr) == nil
}

func (AnomaliesSpecDisksInodesThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisksInodesThresholds)(ptr)
	var objs []AnomaliesSpecDisksInodesThresholds
	if obj != nil {
		objs = []AnomaliesSpecDisksInodesThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodesThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksInodesThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisksInodesThresholds)(ptr) = AnomaliesSpecDisksInodesThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisksInodesThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodesThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisksInodesThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisksInodesThresholds)(ptr) = AnomaliesSpecDisksInodesThresholds{}
			}
		} else {
			*(*AnomaliesSpecDisksInodesThresholds)(ptr) = AnomaliesSpecDisksInodesThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisksInodesThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksInodesThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisksInodesThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisksInodesThresholds)(ptr) = AnomaliesSpecDisksInodesThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisksInodesThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksSpaceCodec struct {
}

func (AnomaliesSpecDisksSpaceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisksSpace)(ptr) == nil
}

func (AnomaliesSpecDisksSpaceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisksSpace)(ptr)
	var objs []AnomaliesSpecDisksSpace
	if obj != nil {
		objs = []AnomaliesSpecDisksSpace{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpace{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksSpaceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisksSpace)(ptr) = AnomaliesSpecDisksSpace{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisksSpace

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpace{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisksSpace)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisksSpace)(ptr) = AnomaliesSpecDisksSpace{}
			}
		} else {
			*(*AnomaliesSpecDisksSpace)(ptr) = AnomaliesSpecDisksSpace{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisksSpace

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpace{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisksSpace)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisksSpace)(ptr) = AnomaliesSpecDisksSpace{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisksSpace", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksSpaceThresholdsCodec struct {
}

func (AnomaliesSpecDisksSpaceThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisksSpaceThresholds)(ptr) == nil
}

func (AnomaliesSpecDisksSpaceThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisksSpaceThresholds)(ptr)
	var objs []AnomaliesSpecDisksSpaceThresholds
	if obj != nil {
		objs = []AnomaliesSpecDisksSpaceThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpaceThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksSpaceThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisksSpaceThresholds)(ptr) = AnomaliesSpecDisksSpaceThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisksSpaceThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpaceThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisksSpaceThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisksSpaceThresholds)(ptr) = AnomaliesSpecDisksSpaceThresholds{}
			}
		} else {
			*(*AnomaliesSpecDisksSpaceThresholds)(ptr) = AnomaliesSpecDisksSpaceThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisksSpaceThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpaceThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisksSpaceThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisksSpaceThresholds)(ptr) = AnomaliesSpecDisksSpaceThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisksSpaceThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksSpeedCodec struct {
}

func (AnomaliesSpecDisksSpeedCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisksSpeed)(ptr) == nil
}

func (AnomaliesSpecDisksSpeedCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisksSpeed)(ptr)
	var objs []AnomaliesSpecDisksSpeed
	if obj != nil {
		objs = []AnomaliesSpecDisksSpeed{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeed{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksSpeedCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisksSpeed)(ptr) = AnomaliesSpecDisksSpeed{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisksSpeed

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeed{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisksSpeed)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisksSpeed)(ptr) = AnomaliesSpecDisksSpeed{}
			}
		} else {
			*(*AnomaliesSpecDisksSpeed)(ptr) = AnomaliesSpecDisksSpeed{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisksSpeed

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeed{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisksSpeed)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisksSpeed)(ptr) = AnomaliesSpecDisksSpeed{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisksSpeed", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDisksSpeedThresholdsCodec struct {
}

func (AnomaliesSpecDisksSpeedThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDisksSpeedThresholds)(ptr) == nil
}

func (AnomaliesSpecDisksSpeedThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDisksSpeedThresholds)(ptr)
	var objs []AnomaliesSpecDisksSpeedThresholds
	if obj != nil {
		objs = []AnomaliesSpecDisksSpeedThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeedThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDisksSpeedThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDisksSpeedThresholds)(ptr) = AnomaliesSpecDisksSpeedThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDisksSpeedThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeedThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDisksSpeedThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDisksSpeedThresholds)(ptr) = AnomaliesSpecDisksSpeedThresholds{}
			}
		} else {
			*(*AnomaliesSpecDisksSpeedThresholds)(ptr) = AnomaliesSpecDisksSpeedThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDisksSpeedThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDisksSpeedThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDisksSpeedThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecDisksSpeedThresholds)(ptr) = AnomaliesSpecDisksSpeedThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDisksSpeedThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecGcCodec struct {
}

func (AnomaliesSpecGcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecGc)(ptr) == nil
}

func (AnomaliesSpecGcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecGc)(ptr)
	var objs []AnomaliesSpecGc
	if obj != nil {
		objs = []AnomaliesSpecGc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecGcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecGc)(ptr) = AnomaliesSpecGc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecGc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecGc)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecGc)(ptr) = AnomaliesSpecGc{}
			}
		} else {
			*(*AnomaliesSpecGc)(ptr) = AnomaliesSpecGc{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecGc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecGc)(ptr) = obj
		} else {
			*(*AnomaliesSpecGc)(ptr) = AnomaliesSpecGc{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecGc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecGcThresholdsCodec struct {
}

func (AnomaliesSpecGcThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecGcThresholds)(ptr) == nil
}

func (AnomaliesSpecGcThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecGcThresholds)(ptr)
	var objs []AnomaliesSpecGcThresholds
	if obj != nil {
		objs = []AnomaliesSpecGcThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGcThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecGcThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecGcThresholds)(ptr) = AnomaliesSpecGcThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecGcThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGcThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecGcThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecGcThresholds)(ptr) = AnomaliesSpecGcThresholds{}
			}
		} else {
			*(*AnomaliesSpecGcThresholds)(ptr) = AnomaliesSpecGcThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecGcThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecGcThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecGcThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecGcThresholds)(ptr) = AnomaliesSpecGcThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecGcThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecJavaCodec struct {
}

func (AnomaliesSpecJavaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecJava)(ptr) == nil
}

func (AnomaliesSpecJavaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecJava)(ptr)
	var objs []AnomaliesSpecJava
	if obj != nil {
		objs = []AnomaliesSpecJava{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJava{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecJavaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecJava)(ptr) = AnomaliesSpecJava{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecJava

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJava{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecJava)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecJava)(ptr) = AnomaliesSpecJava{}
			}
		} else {
			*(*AnomaliesSpecJava)(ptr) = AnomaliesSpecJava{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecJava

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJava{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecJava)(ptr) = obj
		} else {
			*(*AnomaliesSpecJava)(ptr) = AnomaliesSpecJava{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecJava", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecJavaOutOfMemoryCodec struct {
}

func (AnomaliesSpecJavaOutOfMemoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecJavaOutOfMemory)(ptr) == nil
}

func (AnomaliesSpecJavaOutOfMemoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecJavaOutOfMemory)(ptr)
	var objs []AnomaliesSpecJavaOutOfMemory
	if obj != nil {
		objs = []AnomaliesSpecJavaOutOfMemory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecJavaOutOfMemoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecJavaOutOfMemory)(ptr) = AnomaliesSpecJavaOutOfMemory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecJavaOutOfMemory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecJavaOutOfMemory)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecJavaOutOfMemory)(ptr) = AnomaliesSpecJavaOutOfMemory{}
			}
		} else {
			*(*AnomaliesSpecJavaOutOfMemory)(ptr) = AnomaliesSpecJavaOutOfMemory{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecJavaOutOfMemory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecJavaOutOfMemory)(ptr) = obj
		} else {
			*(*AnomaliesSpecJavaOutOfMemory)(ptr) = AnomaliesSpecJavaOutOfMemory{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecJavaOutOfMemory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecJavaOutOfMemoryThresholdsCodec struct {
}

func (AnomaliesSpecJavaOutOfMemoryThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) == nil
}

func (AnomaliesSpecJavaOutOfMemoryThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr)
	var objs []AnomaliesSpecJavaOutOfMemoryThresholds
	if obj != nil {
		objs = []AnomaliesSpecJavaOutOfMemoryThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemoryThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecJavaOutOfMemoryThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) = AnomaliesSpecJavaOutOfMemoryThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecJavaOutOfMemoryThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemoryThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) = AnomaliesSpecJavaOutOfMemoryThresholds{}
			}
		} else {
			*(*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) = AnomaliesSpecJavaOutOfMemoryThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecJavaOutOfMemoryThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfMemoryThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecJavaOutOfMemoryThresholds)(ptr) = AnomaliesSpecJavaOutOfMemoryThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecJavaOutOfMemoryThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecJavaOutOfThreadsCodec struct {
}

func (AnomaliesSpecJavaOutOfThreadsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecJavaOutOfThreads)(ptr) == nil
}

func (AnomaliesSpecJavaOutOfThreadsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecJavaOutOfThreads)(ptr)
	var objs []AnomaliesSpecJavaOutOfThreads
	if obj != nil {
		objs = []AnomaliesSpecJavaOutOfThreads{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreads{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecJavaOutOfThreadsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecJavaOutOfThreads)(ptr) = AnomaliesSpecJavaOutOfThreads{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecJavaOutOfThreads

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreads{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecJavaOutOfThreads)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecJavaOutOfThreads)(ptr) = AnomaliesSpecJavaOutOfThreads{}
			}
		} else {
			*(*AnomaliesSpecJavaOutOfThreads)(ptr) = AnomaliesSpecJavaOutOfThreads{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecJavaOutOfThreads

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreads{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecJavaOutOfThreads)(ptr) = obj
		} else {
			*(*AnomaliesSpecJavaOutOfThreads)(ptr) = AnomaliesSpecJavaOutOfThreads{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecJavaOutOfThreads", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecJavaOutOfThreadsThresholdsCodec struct {
}

func (AnomaliesSpecJavaOutOfThreadsThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) == nil
}

func (AnomaliesSpecJavaOutOfThreadsThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr)
	var objs []AnomaliesSpecJavaOutOfThreadsThresholds
	if obj != nil {
		objs = []AnomaliesSpecJavaOutOfThreadsThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreadsThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecJavaOutOfThreadsThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) = AnomaliesSpecJavaOutOfThreadsThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecJavaOutOfThreadsThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreadsThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) = AnomaliesSpecJavaOutOfThreadsThresholds{}
			}
		} else {
			*(*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) = AnomaliesSpecJavaOutOfThreadsThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecJavaOutOfThreadsThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecJavaOutOfThreadsThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecJavaOutOfThreadsThresholds)(ptr) = AnomaliesSpecJavaOutOfThreadsThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecJavaOutOfThreadsThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecMemoryCodec struct {
}

func (AnomaliesSpecMemoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecMemory)(ptr) == nil
}

func (AnomaliesSpecMemoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecMemory)(ptr)
	var objs []AnomaliesSpecMemory
	if obj != nil {
		objs = []AnomaliesSpecMemory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecMemoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecMemory)(ptr) = AnomaliesSpecMemory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecMemory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecMemory)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecMemory)(ptr) = AnomaliesSpecMemory{}
			}
		} else {
			*(*AnomaliesSpecMemory)(ptr) = AnomaliesSpecMemory{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecMemory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecMemory)(ptr) = obj
		} else {
			*(*AnomaliesSpecMemory)(ptr) = AnomaliesSpecMemory{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecMemory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecMemoryThresholdsCodec struct {
}

func (AnomaliesSpecMemoryThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecMemoryThresholds)(ptr) == nil
}

func (AnomaliesSpecMemoryThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecMemoryThresholds)(ptr)
	var objs []AnomaliesSpecMemoryThresholds
	if obj != nil {
		objs = []AnomaliesSpecMemoryThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecMemoryThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecMemoryThresholds)(ptr) = AnomaliesSpecMemoryThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecMemoryThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecMemoryThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecMemoryThresholds)(ptr) = AnomaliesSpecMemoryThresholds{}
			}
		} else {
			*(*AnomaliesSpecMemoryThresholds)(ptr) = AnomaliesSpecMemoryThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecMemoryThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecMemoryThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecMemoryThresholds)(ptr) = AnomaliesSpecMemoryThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecMemoryThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecMemoryThresholdsLinuxCodec struct {
}

func (AnomaliesSpecMemoryThresholdsLinuxCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecMemoryThresholdsLinux)(ptr) == nil
}

func (AnomaliesSpecMemoryThresholdsLinuxCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecMemoryThresholdsLinux)(ptr)
	var objs []AnomaliesSpecMemoryThresholdsLinux
	if obj != nil {
		objs = []AnomaliesSpecMemoryThresholdsLinux{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsLinux{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecMemoryThresholdsLinuxCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecMemoryThresholdsLinux)(ptr) = AnomaliesSpecMemoryThresholdsLinux{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecMemoryThresholdsLinux

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsLinux{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecMemoryThresholdsLinux)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecMemoryThresholdsLinux)(ptr) = AnomaliesSpecMemoryThresholdsLinux{}
			}
		} else {
			*(*AnomaliesSpecMemoryThresholdsLinux)(ptr) = AnomaliesSpecMemoryThresholdsLinux{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecMemoryThresholdsLinux

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsLinux{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecMemoryThresholdsLinux)(ptr) = obj
		} else {
			*(*AnomaliesSpecMemoryThresholdsLinux)(ptr) = AnomaliesSpecMemoryThresholdsLinux{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecMemoryThresholdsLinux", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecMemoryThresholdsWindowsCodec struct {
}

func (AnomaliesSpecMemoryThresholdsWindowsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecMemoryThresholdsWindows)(ptr) == nil
}

func (AnomaliesSpecMemoryThresholdsWindowsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecMemoryThresholdsWindows)(ptr)
	var objs []AnomaliesSpecMemoryThresholdsWindows
	if obj != nil {
		objs = []AnomaliesSpecMemoryThresholdsWindows{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsWindows{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecMemoryThresholdsWindowsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecMemoryThresholdsWindows)(ptr) = AnomaliesSpecMemoryThresholdsWindows{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecMemoryThresholdsWindows

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsWindows{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecMemoryThresholdsWindows)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecMemoryThresholdsWindows)(ptr) = AnomaliesSpecMemoryThresholdsWindows{}
			}
		} else {
			*(*AnomaliesSpecMemoryThresholdsWindows)(ptr) = AnomaliesSpecMemoryThresholdsWindows{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecMemoryThresholdsWindows

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecMemoryThresholdsWindows{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecMemoryThresholdsWindows)(ptr) = obj
		} else {
			*(*AnomaliesSpecMemoryThresholdsWindows)(ptr) = AnomaliesSpecMemoryThresholdsWindows{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecMemoryThresholdsWindows", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkCodec struct {
}

func (AnomaliesSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetwork)(ptr) == nil
}

func (AnomaliesSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetwork)(ptr)
	var objs []AnomaliesSpecNetwork
	if obj != nil {
		objs = []AnomaliesSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetwork)(ptr) = AnomaliesSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetwork)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetwork)(ptr) = AnomaliesSpecNetwork{}
			}
		} else {
			*(*AnomaliesSpecNetwork)(ptr) = AnomaliesSpecNetwork{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetwork)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetwork)(ptr) = AnomaliesSpecNetwork{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkConnectivityCodec struct {
}

func (AnomaliesSpecNetworkConnectivityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkConnectivity)(ptr) == nil
}

func (AnomaliesSpecNetworkConnectivityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkConnectivity)(ptr)
	var objs []AnomaliesSpecNetworkConnectivity
	if obj != nil {
		objs = []AnomaliesSpecNetworkConnectivity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkConnectivityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkConnectivity)(ptr) = AnomaliesSpecNetworkConnectivity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkConnectivity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkConnectivity)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkConnectivity)(ptr) = AnomaliesSpecNetworkConnectivity{}
			}
		} else {
			*(*AnomaliesSpecNetworkConnectivity)(ptr) = AnomaliesSpecNetworkConnectivity{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkConnectivity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkConnectivity)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkConnectivity)(ptr) = AnomaliesSpecNetworkConnectivity{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkConnectivity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkConnectivityThresholdsCodec struct {
}

func (AnomaliesSpecNetworkConnectivityThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkConnectivityThresholds)(ptr) == nil
}

func (AnomaliesSpecNetworkConnectivityThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkConnectivityThresholds)(ptr)
	var objs []AnomaliesSpecNetworkConnectivityThresholds
	if obj != nil {
		objs = []AnomaliesSpecNetworkConnectivityThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivityThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkConnectivityThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkConnectivityThresholds)(ptr) = AnomaliesSpecNetworkConnectivityThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkConnectivityThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivityThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkConnectivityThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkConnectivityThresholds)(ptr) = AnomaliesSpecNetworkConnectivityThresholds{}
			}
		} else {
			*(*AnomaliesSpecNetworkConnectivityThresholds)(ptr) = AnomaliesSpecNetworkConnectivityThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkConnectivityThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkConnectivityThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkConnectivityThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkConnectivityThresholds)(ptr) = AnomaliesSpecNetworkConnectivityThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkConnectivityThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkDroppedPacketsCodec struct {
}

func (AnomaliesSpecNetworkDroppedPacketsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkDroppedPackets)(ptr) == nil
}

func (AnomaliesSpecNetworkDroppedPacketsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkDroppedPackets)(ptr)
	var objs []AnomaliesSpecNetworkDroppedPackets
	if obj != nil {
		objs = []AnomaliesSpecNetworkDroppedPackets{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPackets{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkDroppedPacketsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkDroppedPackets)(ptr) = AnomaliesSpecNetworkDroppedPackets{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkDroppedPackets

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPackets{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkDroppedPackets)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkDroppedPackets)(ptr) = AnomaliesSpecNetworkDroppedPackets{}
			}
		} else {
			*(*AnomaliesSpecNetworkDroppedPackets)(ptr) = AnomaliesSpecNetworkDroppedPackets{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkDroppedPackets

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPackets{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkDroppedPackets)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkDroppedPackets)(ptr) = AnomaliesSpecNetworkDroppedPackets{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkDroppedPackets", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkDroppedPacketsThresholdsCodec struct {
}

func (AnomaliesSpecNetworkDroppedPacketsThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) == nil
}

func (AnomaliesSpecNetworkDroppedPacketsThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr)
	var objs []AnomaliesSpecNetworkDroppedPacketsThresholds
	if obj != nil {
		objs = []AnomaliesSpecNetworkDroppedPacketsThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPacketsThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkDroppedPacketsThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) = AnomaliesSpecNetworkDroppedPacketsThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkDroppedPacketsThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPacketsThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) = AnomaliesSpecNetworkDroppedPacketsThresholds{}
			}
		} else {
			*(*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) = AnomaliesSpecNetworkDroppedPacketsThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkDroppedPacketsThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkDroppedPacketsThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkDroppedPacketsThresholds)(ptr) = AnomaliesSpecNetworkDroppedPacketsThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkDroppedPacketsThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkErrorsCodec struct {
}

func (AnomaliesSpecNetworkErrorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkErrors)(ptr) == nil
}

func (AnomaliesSpecNetworkErrorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkErrors)(ptr)
	var objs []AnomaliesSpecNetworkErrors
	if obj != nil {
		objs = []AnomaliesSpecNetworkErrors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkErrorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkErrors)(ptr) = AnomaliesSpecNetworkErrors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkErrors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkErrors)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkErrors)(ptr) = AnomaliesSpecNetworkErrors{}
			}
		} else {
			*(*AnomaliesSpecNetworkErrors)(ptr) = AnomaliesSpecNetworkErrors{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkErrors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkErrors)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkErrors)(ptr) = AnomaliesSpecNetworkErrors{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkErrors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkErrorsThresholdsCodec struct {
}

func (AnomaliesSpecNetworkErrorsThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkErrorsThresholds)(ptr) == nil
}

func (AnomaliesSpecNetworkErrorsThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkErrorsThresholds)(ptr)
	var objs []AnomaliesSpecNetworkErrorsThresholds
	if obj != nil {
		objs = []AnomaliesSpecNetworkErrorsThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrorsThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkErrorsThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkErrorsThresholds)(ptr) = AnomaliesSpecNetworkErrorsThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkErrorsThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrorsThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkErrorsThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkErrorsThresholds)(ptr) = AnomaliesSpecNetworkErrorsThresholds{}
			}
		} else {
			*(*AnomaliesSpecNetworkErrorsThresholds)(ptr) = AnomaliesSpecNetworkErrorsThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkErrorsThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkErrorsThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkErrorsThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkErrorsThresholds)(ptr) = AnomaliesSpecNetworkErrorsThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkErrorsThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkRetransmissionCodec struct {
}

func (AnomaliesSpecNetworkRetransmissionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkRetransmission)(ptr) == nil
}

func (AnomaliesSpecNetworkRetransmissionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkRetransmission)(ptr)
	var objs []AnomaliesSpecNetworkRetransmission
	if obj != nil {
		objs = []AnomaliesSpecNetworkRetransmission{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmission{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkRetransmissionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkRetransmission)(ptr) = AnomaliesSpecNetworkRetransmission{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkRetransmission

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmission{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkRetransmission)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkRetransmission)(ptr) = AnomaliesSpecNetworkRetransmission{}
			}
		} else {
			*(*AnomaliesSpecNetworkRetransmission)(ptr) = AnomaliesSpecNetworkRetransmission{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkRetransmission

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmission{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkRetransmission)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkRetransmission)(ptr) = AnomaliesSpecNetworkRetransmission{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkRetransmission", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkRetransmissionThresholdsCodec struct {
}

func (AnomaliesSpecNetworkRetransmissionThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) == nil
}

func (AnomaliesSpecNetworkRetransmissionThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkRetransmissionThresholds)(ptr)
	var objs []AnomaliesSpecNetworkRetransmissionThresholds
	if obj != nil {
		objs = []AnomaliesSpecNetworkRetransmissionThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmissionThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkRetransmissionThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) = AnomaliesSpecNetworkRetransmissionThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkRetransmissionThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmissionThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) = AnomaliesSpecNetworkRetransmissionThresholds{}
			}
		} else {
			*(*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) = AnomaliesSpecNetworkRetransmissionThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkRetransmissionThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkRetransmissionThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkRetransmissionThresholds)(ptr) = AnomaliesSpecNetworkRetransmissionThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkRetransmissionThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkUtilizationCodec struct {
}

func (AnomaliesSpecNetworkUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkUtilization)(ptr) == nil
}

func (AnomaliesSpecNetworkUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkUtilization)(ptr)
	var objs []AnomaliesSpecNetworkUtilization
	if obj != nil {
		objs = []AnomaliesSpecNetworkUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkUtilization)(ptr) = AnomaliesSpecNetworkUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkUtilization)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkUtilization)(ptr) = AnomaliesSpecNetworkUtilization{}
			}
		} else {
			*(*AnomaliesSpecNetworkUtilization)(ptr) = AnomaliesSpecNetworkUtilization{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkUtilization)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkUtilization)(ptr) = AnomaliesSpecNetworkUtilization{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecNetworkUtilizationThresholdsCodec struct {
}

func (AnomaliesSpecNetworkUtilizationThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecNetworkUtilizationThresholds)(ptr) == nil
}

func (AnomaliesSpecNetworkUtilizationThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecNetworkUtilizationThresholds)(ptr)
	var objs []AnomaliesSpecNetworkUtilizationThresholds
	if obj != nil {
		objs = []AnomaliesSpecNetworkUtilizationThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilizationThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecNetworkUtilizationThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecNetworkUtilizationThresholds)(ptr) = AnomaliesSpecNetworkUtilizationThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecNetworkUtilizationThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilizationThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecNetworkUtilizationThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecNetworkUtilizationThresholds)(ptr) = AnomaliesSpecNetworkUtilizationThresholds{}
			}
		} else {
			*(*AnomaliesSpecNetworkUtilizationThresholds)(ptr) = AnomaliesSpecNetworkUtilizationThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecNetworkUtilizationThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecNetworkUtilizationThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecNetworkUtilizationThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecNetworkUtilizationThresholds)(ptr) = AnomaliesSpecNetworkUtilizationThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecNetworkUtilizationThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomHostMetadataDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomHostMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomHostMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomProcessMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionHostTechValueCodec struct {
}

func (NamingSpecConditionsConditionHostTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionHostTechValue)(ptr) == nil
}

func (NamingSpecConditionsConditionHostTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionHostTechValue)(ptr)
	var objs []NamingSpecConditionsConditionHostTechValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionHostTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionHostTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionHostTechValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionHostTechValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionIndexedTagValueCodec struct {
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionIndexedTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionIndexedTagValue)(ptr)
	var objs []NamingSpecConditionsConditionIndexedTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionIndexedTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionIndexedTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionIndexedTagComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionIndexedTagComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionIndexedTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionIndexedTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionSimpleHostTechComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionSimpleHostTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionSimpleHostTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionSimpleTechComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionSimpleTechComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionSimpleTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionSimpleTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTagValueCodec struct {
}

func (NamingSpecConditionsConditionTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTagValue)(ptr)
	var objs []NamingSpecConditionsConditionTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTagComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTagComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTagComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionTagComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTechValueCodec struct {
}

func (NamingSpecConditionsConditionTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTechValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTechValue)(ptr)
	var objs []NamingSpecConditionsConditionTechValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTechValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTechValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTechValue", "unexpected JSON type")
	}
}
