/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRates{}).Type1()):                                                AnomaliesSpecFailureRatesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesAuto{}).Type1()):                                            AnomaliesSpecFailureRatesAutoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesThresholds{}).Type1()):                                      AnomaliesSpecFailureRatesThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoad{}).Type1()):                                                        AnomaliesSpecLoadCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops{}).Type1()):                                                   AnomaliesSpecLoadDropsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadSpikes{}).Type1()):                                                  AnomaliesSpecLoadSpikesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops2{}).Type1()):                                                  AnomaliesSpecLoadDrops2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimes{}).Type1()):                                               AnomaliesSpecResponseTimesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesAuto{}).Type1()):                                           AnomaliesSpecResponseTimesAutoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesThresholds{}).Type1()):                                     AnomaliesSpecResponseTimesThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1()):                NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1()):             NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1()):                               NamingSpecConditionsConditionHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1()):                             NamingSpecConditionsConditionIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1()):                   NamingSpecConditionsConditionIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1()):               NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1()):                   NamingSpecConditionsConditionSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1()):                                    NamingSpecConditionsConditionTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1()):                          NamingSpecConditionsConditionTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1()):                                   NamingSpecConditionsConditionTechValueCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRates{}).Type1()):                                                AnomaliesSpecFailureRatesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesAuto{}).Type1()):                                            AnomaliesSpecFailureRatesAutoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesThresholds{}).Type1()):                                      AnomaliesSpecFailureRatesThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoad{}).Type1()):                                                        AnomaliesSpecLoadCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops{}).Type1()):                                                   AnomaliesSpecLoadDropsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadSpikes{}).Type1()):                                                  AnomaliesSpecLoadSpikesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops2{}).Type1()):                                                  AnomaliesSpecLoadDrops2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimes{}).Type1()):                                               AnomaliesSpecResponseTimesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesAuto{}).Type1()):                                           AnomaliesSpecResponseTimesAutoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesThresholds{}).Type1()):                                     AnomaliesSpecResponseTimesThresholdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1()):                NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1()):             NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1()):                               NamingSpecConditionsConditionHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1()):                             NamingSpecConditionsConditionIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1()):                   NamingSpecConditionsConditionIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1()):               NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1()):                   NamingSpecConditionsConditionSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1()):                                    NamingSpecConditionsConditionTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1()):                          NamingSpecConditionsConditionTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1()):                                   NamingSpecConditionsConditionTechValueCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecFailureRatesCodec struct {
}

func (AnomaliesSpecFailureRatesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecFailureRates)(ptr) == nil
}

func (AnomaliesSpecFailureRatesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecFailureRates)(ptr)
	var objs []AnomaliesSpecFailureRates
	if obj != nil {
		objs = []AnomaliesSpecFailureRates{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRates{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecFailureRatesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecFailureRates)(ptr) = AnomaliesSpecFailureRates{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecFailureRates

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRates{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecFailureRates)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecFailureRates)(ptr) = AnomaliesSpecFailureRates{}
			}
		} else {
			*(*AnomaliesSpecFailureRates)(ptr) = AnomaliesSpecFailureRates{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecFailureRates

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRates{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecFailureRates)(ptr) = obj
		} else {
			*(*AnomaliesSpecFailureRates)(ptr) = AnomaliesSpecFailureRates{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecFailureRates", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecFailureRatesAutoCodec struct {
}

func (AnomaliesSpecFailureRatesAutoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecFailureRatesAuto)(ptr) == nil
}

func (AnomaliesSpecFailureRatesAutoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecFailureRatesAuto)(ptr)
	var objs []AnomaliesSpecFailureRatesAuto
	if obj != nil {
		objs = []AnomaliesSpecFailureRatesAuto{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesAuto{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecFailureRatesAutoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecFailureRatesAuto)(ptr) = AnomaliesSpecFailureRatesAuto{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecFailureRatesAuto

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesAuto{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecFailureRatesAuto)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecFailureRatesAuto)(ptr) = AnomaliesSpecFailureRatesAuto{}
			}
		} else {
			*(*AnomaliesSpecFailureRatesAuto)(ptr) = AnomaliesSpecFailureRatesAuto{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecFailureRatesAuto

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesAuto{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecFailureRatesAuto)(ptr) = obj
		} else {
			*(*AnomaliesSpecFailureRatesAuto)(ptr) = AnomaliesSpecFailureRatesAuto{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecFailureRatesAuto", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecFailureRatesThresholdsCodec struct {
}

func (AnomaliesSpecFailureRatesThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecFailureRatesThresholds)(ptr) == nil
}

func (AnomaliesSpecFailureRatesThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecFailureRatesThresholds)(ptr)
	var objs []AnomaliesSpecFailureRatesThresholds
	if obj != nil {
		objs = []AnomaliesSpecFailureRatesThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecFailureRatesThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecFailureRatesThresholds)(ptr) = AnomaliesSpecFailureRatesThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecFailureRatesThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecFailureRatesThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecFailureRatesThresholds)(ptr) = AnomaliesSpecFailureRatesThresholds{}
			}
		} else {
			*(*AnomaliesSpecFailureRatesThresholds)(ptr) = AnomaliesSpecFailureRatesThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecFailureRatesThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecFailureRatesThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecFailureRatesThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecFailureRatesThresholds)(ptr) = AnomaliesSpecFailureRatesThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecFailureRatesThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecLoadCodec struct {
}

func (AnomaliesSpecLoadCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecLoad)(ptr) == nil
}

func (AnomaliesSpecLoadCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecLoad)(ptr)
	var objs []AnomaliesSpecLoad
	if obj != nil {
		objs = []AnomaliesSpecLoad{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoad{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecLoadCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecLoad)(ptr) = AnomaliesSpecLoad{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecLoad

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoad{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecLoad)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecLoad)(ptr) = AnomaliesSpecLoad{}
			}
		} else {
			*(*AnomaliesSpecLoad)(ptr) = AnomaliesSpecLoad{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecLoad

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoad{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecLoad)(ptr) = obj
		} else {
			*(*AnomaliesSpecLoad)(ptr) = AnomaliesSpecLoad{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecLoad", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecLoadDropsCodec struct {
}

func (AnomaliesSpecLoadDropsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecLoadDrops)(ptr) == nil
}

func (AnomaliesSpecLoadDropsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecLoadDrops)(ptr)
	var objs []AnomaliesSpecLoadDrops
	if obj != nil {
		objs = []AnomaliesSpecLoadDrops{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecLoadDropsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecLoadDrops)(ptr) = AnomaliesSpecLoadDrops{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecLoadDrops

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecLoadDrops)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecLoadDrops)(ptr) = AnomaliesSpecLoadDrops{}
			}
		} else {
			*(*AnomaliesSpecLoadDrops)(ptr) = AnomaliesSpecLoadDrops{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecLoadDrops

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecLoadDrops)(ptr) = obj
		} else {
			*(*AnomaliesSpecLoadDrops)(ptr) = AnomaliesSpecLoadDrops{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecLoadDrops", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecLoadSpikesCodec struct {
}

func (AnomaliesSpecLoadSpikesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecLoadSpikes)(ptr) == nil
}

func (AnomaliesSpecLoadSpikesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecLoadSpikes)(ptr)
	var objs []AnomaliesSpecLoadSpikes
	if obj != nil {
		objs = []AnomaliesSpecLoadSpikes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadSpikes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecLoadSpikesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecLoadSpikes)(ptr) = AnomaliesSpecLoadSpikes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecLoadSpikes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadSpikes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecLoadSpikes)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecLoadSpikes)(ptr) = AnomaliesSpecLoadSpikes{}
			}
		} else {
			*(*AnomaliesSpecLoadSpikes)(ptr) = AnomaliesSpecLoadSpikes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecLoadSpikes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadSpikes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecLoadSpikes)(ptr) = obj
		} else {
			*(*AnomaliesSpecLoadSpikes)(ptr) = AnomaliesSpecLoadSpikes{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecLoadSpikes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecLoadDrops2Codec struct {
}

func (AnomaliesSpecLoadDrops2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecLoadDrops2)(ptr) == nil
}

func (AnomaliesSpecLoadDrops2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecLoadDrops2)(ptr)
	var objs []AnomaliesSpecLoadDrops2
	if obj != nil {
		objs = []AnomaliesSpecLoadDrops2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecLoadDrops2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecLoadDrops2)(ptr) = AnomaliesSpecLoadDrops2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecLoadDrops2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecLoadDrops2)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecLoadDrops2)(ptr) = AnomaliesSpecLoadDrops2{}
			}
		} else {
			*(*AnomaliesSpecLoadDrops2)(ptr) = AnomaliesSpecLoadDrops2{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecLoadDrops2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecLoadDrops2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecLoadDrops2)(ptr) = obj
		} else {
			*(*AnomaliesSpecLoadDrops2)(ptr) = AnomaliesSpecLoadDrops2{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecLoadDrops2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecResponseTimesCodec struct {
}

func (AnomaliesSpecResponseTimesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecResponseTimes)(ptr) == nil
}

func (AnomaliesSpecResponseTimesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecResponseTimes)(ptr)
	var objs []AnomaliesSpecResponseTimes
	if obj != nil {
		objs = []AnomaliesSpecResponseTimes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecResponseTimesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecResponseTimes)(ptr) = AnomaliesSpecResponseTimes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecResponseTimes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecResponseTimes)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecResponseTimes)(ptr) = AnomaliesSpecResponseTimes{}
			}
		} else {
			*(*AnomaliesSpecResponseTimes)(ptr) = AnomaliesSpecResponseTimes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecResponseTimes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecResponseTimes)(ptr) = obj
		} else {
			*(*AnomaliesSpecResponseTimes)(ptr) = AnomaliesSpecResponseTimes{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecResponseTimes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecResponseTimesAutoCodec struct {
}

func (AnomaliesSpecResponseTimesAutoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecResponseTimesAuto)(ptr) == nil
}

func (AnomaliesSpecResponseTimesAutoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecResponseTimesAuto)(ptr)
	var objs []AnomaliesSpecResponseTimesAuto
	if obj != nil {
		objs = []AnomaliesSpecResponseTimesAuto{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesAuto{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecResponseTimesAutoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecResponseTimesAuto)(ptr) = AnomaliesSpecResponseTimesAuto{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecResponseTimesAuto

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesAuto{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecResponseTimesAuto)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecResponseTimesAuto)(ptr) = AnomaliesSpecResponseTimesAuto{}
			}
		} else {
			*(*AnomaliesSpecResponseTimesAuto)(ptr) = AnomaliesSpecResponseTimesAuto{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecResponseTimesAuto

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesAuto{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecResponseTimesAuto)(ptr) = obj
		} else {
			*(*AnomaliesSpecResponseTimesAuto)(ptr) = AnomaliesSpecResponseTimesAuto{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecResponseTimesAuto", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecResponseTimesThresholdsCodec struct {
}

func (AnomaliesSpecResponseTimesThresholdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecResponseTimesThresholds)(ptr) == nil
}

func (AnomaliesSpecResponseTimesThresholdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecResponseTimesThresholds)(ptr)
	var objs []AnomaliesSpecResponseTimesThresholds
	if obj != nil {
		objs = []AnomaliesSpecResponseTimesThresholds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesThresholds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecResponseTimesThresholdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecResponseTimesThresholds)(ptr) = AnomaliesSpecResponseTimesThresholds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecResponseTimesThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecResponseTimesThresholds)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecResponseTimesThresholds)(ptr) = AnomaliesSpecResponseTimesThresholds{}
			}
		} else {
			*(*AnomaliesSpecResponseTimesThresholds)(ptr) = AnomaliesSpecResponseTimesThresholds{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecResponseTimesThresholds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecResponseTimesThresholds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecResponseTimesThresholds)(ptr) = obj
		} else {
			*(*AnomaliesSpecResponseTimesThresholds)(ptr) = AnomaliesSpecResponseTimesThresholds{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecResponseTimesThresholds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomHostMetadataDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomHostMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomHostMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomProcessMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionHostTechValueCodec struct {
}

func (NamingSpecConditionsConditionHostTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionHostTechValue)(ptr) == nil
}

func (NamingSpecConditionsConditionHostTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionHostTechValue)(ptr)
	var objs []NamingSpecConditionsConditionHostTechValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionHostTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionHostTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionHostTechValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionHostTechValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionIndexedTagValueCodec struct {
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionIndexedTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionIndexedTagValue)(ptr)
	var objs []NamingSpecConditionsConditionIndexedTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionIndexedTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionIndexedTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionIndexedTagComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionIndexedTagComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionIndexedTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionIndexedTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionSimpleHostTechComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionSimpleHostTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionSimpleHostTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionSimpleTechComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionSimpleTechComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionSimpleTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionSimpleTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTagValueCodec struct {
}

func (NamingSpecConditionsConditionTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTagValue)(ptr)
	var objs []NamingSpecConditionsConditionTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTagComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTagComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTagComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionTagComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTechValueCodec struct {
}

func (NamingSpecConditionsConditionTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTechValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTechValue)(ptr)
	var objs []NamingSpecConditionsConditionTechValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTechValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTechValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTechValue", "unexpected JSON type")
	}
}
