/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecMetadata{}).Type1()):                                                   ZoneSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1()):                ZoneSpecRulesConditionsCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1()):             ZoneSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsHostTechValue{}).Type1()):                               ZoneSpecRulesConditionsHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagValue{}).Type1()):                             ZoneSpecRulesConditionsIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagComparisonValue{}).Type1()):                   ZoneSpecRulesConditionsIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1()):               ZoneSpecRulesConditionsSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleTechComparisonValue{}).Type1()):                   ZoneSpecRulesConditionsSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagValue{}).Type1()):                                    ZoneSpecRulesConditionsTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagComparisonValue{}).Type1()):                          ZoneSpecRulesConditionsTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTechValue{}).Type1()):                                   ZoneSpecRulesConditionsTechValueCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecMetadata{}).Type1()):                                                   ZoneSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1()):                ZoneSpecRulesConditionsCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1()):             ZoneSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsHostTechValue{}).Type1()):                               ZoneSpecRulesConditionsHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagValue{}).Type1()):                             ZoneSpecRulesConditionsIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagComparisonValue{}).Type1()):                   ZoneSpecRulesConditionsIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1()):               ZoneSpecRulesConditionsSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleTechComparisonValue{}).Type1()):                   ZoneSpecRulesConditionsSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagValue{}).Type1()):                                    ZoneSpecRulesConditionsTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagComparisonValue{}).Type1()):                          ZoneSpecRulesConditionsTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTechValue{}).Type1()):                                   ZoneSpecRulesConditionsTechValueCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ZoneSpecMetadataCodec struct {
}

func (ZoneSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecMetadata)(ptr) == nil
}

func (ZoneSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecMetadata)(ptr)
	var objs []ZoneSpecMetadata
	if obj != nil {
		objs = []ZoneSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecMetadata)(ptr) = ZoneSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecMetadata)(ptr) = objs[0]
			} else {
				*(*ZoneSpecMetadata)(ptr) = ZoneSpecMetadata{}
			}
		} else {
			*(*ZoneSpecMetadata)(ptr) = ZoneSpecMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecMetadata)(ptr) = obj
		} else {
			*(*ZoneSpecMetadata)(ptr) = ZoneSpecMetadata{}
		}
	default:
		iter.ReportError("decode ZoneSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsCustomHostMetadataDynamicKeyCodec struct {
}

func (ZoneSpecRulesConditionsCustomHostMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) == nil
}

func (ZoneSpecRulesConditionsCustomHostMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr)
	var objs []ZoneSpecRulesConditionsCustomHostMetadataDynamicKey
	if obj != nil {
		objs = []ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsCustomHostMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}
			}
		} else {
			*(*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsCustomHostMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec struct {
}

func (ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr)
	var objs []ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec struct {
}

func (ZoneSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) == nil
}

func (ZoneSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr)
	var objs []ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey
	if obj != nil {
		objs = []ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}
			}
		} else {
			*(*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec struct {
}

func (ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr)
	var objs []ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsHostTechValueCodec struct {
}

func (ZoneSpecRulesConditionsHostTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsHostTechValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsHostTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsHostTechValue)(ptr)
	var objs []ZoneSpecRulesConditionsHostTechValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsHostTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsHostTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsHostTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsHostTechValue)(ptr) = ZoneSpecRulesConditionsHostTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsHostTechValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsHostTechValue)(ptr) = ZoneSpecRulesConditionsHostTechValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsHostTechValue)(ptr) = ZoneSpecRulesConditionsHostTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsHostTechValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsHostTechValue)(ptr) = ZoneSpecRulesConditionsHostTechValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsHostTechValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsIndexedTagValueCodec struct {
}

func (ZoneSpecRulesConditionsIndexedTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsIndexedTagValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsIndexedTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsIndexedTagValue)(ptr)
	var objs []ZoneSpecRulesConditionsIndexedTagValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsIndexedTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsIndexedTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsIndexedTagValue)(ptr) = ZoneSpecRulesConditionsIndexedTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsIndexedTagValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsIndexedTagValue)(ptr) = ZoneSpecRulesConditionsIndexedTagValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsIndexedTagValue)(ptr) = ZoneSpecRulesConditionsIndexedTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsIndexedTagValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsIndexedTagValue)(ptr) = ZoneSpecRulesConditionsIndexedTagValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsIndexedTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsIndexedTagComparisonValueCodec struct {
}

func (ZoneSpecRulesConditionsIndexedTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsIndexedTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr)
	var objs []ZoneSpecRulesConditionsIndexedTagComparisonValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsIndexedTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsIndexedTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) = ZoneSpecRulesConditionsIndexedTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) = ZoneSpecRulesConditionsIndexedTagComparisonValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) = ZoneSpecRulesConditionsIndexedTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsIndexedTagComparisonValue)(ptr) = ZoneSpecRulesConditionsIndexedTagComparisonValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsIndexedTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsSimpleHostTechComparisonValueCodec struct {
}

func (ZoneSpecRulesConditionsSimpleHostTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsSimpleHostTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr)
	var objs []ZoneSpecRulesConditionsSimpleHostTechComparisonValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsSimpleHostTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsSimpleHostTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleHostTechComparisonValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsSimpleHostTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsSimpleTechComparisonValueCodec struct {
}

func (ZoneSpecRulesConditionsSimpleTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsSimpleTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr)
	var objs []ZoneSpecRulesConditionsSimpleTechComparisonValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsSimpleTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsSimpleTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleTechComparisonValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsSimpleTechComparisonValue)(ptr) = ZoneSpecRulesConditionsSimpleTechComparisonValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsSimpleTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsTagValueCodec struct {
}

func (ZoneSpecRulesConditionsTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsTagValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsTagValue)(ptr)
	var objs []ZoneSpecRulesConditionsTagValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsTagValue)(ptr) = ZoneSpecRulesConditionsTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsTagValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsTagValue)(ptr) = ZoneSpecRulesConditionsTagValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsTagValue)(ptr) = ZoneSpecRulesConditionsTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsTagValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsTagValue)(ptr) = ZoneSpecRulesConditionsTagValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsTagComparisonValueCodec struct {
}

func (ZoneSpecRulesConditionsTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsTagComparisonValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsTagComparisonValue)(ptr)
	var objs []ZoneSpecRulesConditionsTagComparisonValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsTagComparisonValue)(ptr) = ZoneSpecRulesConditionsTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsTagComparisonValue)(ptr) = ZoneSpecRulesConditionsTagComparisonValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsTagComparisonValue)(ptr) = ZoneSpecRulesConditionsTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsTagComparisonValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsTagComparisonValue)(ptr) = ZoneSpecRulesConditionsTagComparisonValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ZoneSpecRulesConditionsTechValueCodec struct {
}

func (ZoneSpecRulesConditionsTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ZoneSpecRulesConditionsTechValue)(ptr) == nil
}

func (ZoneSpecRulesConditionsTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ZoneSpecRulesConditionsTechValue)(ptr)
	var objs []ZoneSpecRulesConditionsTechValue
	if obj != nil {
		objs = []ZoneSpecRulesConditionsTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ZoneSpecRulesConditionsTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ZoneSpecRulesConditionsTechValue)(ptr) = ZoneSpecRulesConditionsTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ZoneSpecRulesConditionsTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ZoneSpecRulesConditionsTechValue)(ptr) = objs[0]
			} else {
				*(*ZoneSpecRulesConditionsTechValue)(ptr) = ZoneSpecRulesConditionsTechValue{}
			}
		} else {
			*(*ZoneSpecRulesConditionsTechValue)(ptr) = ZoneSpecRulesConditionsTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ZoneSpecRulesConditionsTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ZoneSpecRulesConditionsTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ZoneSpecRulesConditionsTechValue)(ptr) = obj
		} else {
			*(*ZoneSpecRulesConditionsTechValue)(ptr) = ZoneSpecRulesConditionsTechValue{}
		}
	default:
		iter.ReportError("decode ZoneSpecRulesConditionsTechValue", "unexpected JSON type")
	}
}
