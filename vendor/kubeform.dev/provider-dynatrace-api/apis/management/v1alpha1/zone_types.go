/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Zone struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ZoneSpec   `json:"spec,omitempty"`
	Status            ZoneStatus `json:"status,omitempty"`
}

type ZoneSpecDimensionalRuleCondition struct {
	// The reference value for comparison. For conditions of the `DIMENSION` type, specify the key here
	Key *string `json:"key" tf:"key"`
	// How to compare. Possible values are
	//    - `BEGINS_WITH`
	//    - `EQUALS`
	Match *string `json:"match" tf:"match"`
	// The type of the condition. Possible values are
	//    - `DIMENSION`
	//    - `LOG_FILE_NAME`
	//    - `METRIC_KEY`
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the dimension. Only applicable when type is set to `DIMENSION`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecDimensionalRule struct {
	// The target of the rule. Possible values are
	//    - `ANY`
	//    - `LOG`
	//    - `METRIC`
	AppliesTo *string `json:"appliesTo" tf:"applies_to"`
	// A list of conditions for the management zone. The management zone applies only if **all** conditions are fulfilled
	// +optional
	Condition []ZoneSpecDimensionalRuleCondition `json:"condition,omitempty" tf:"condition"`
	// The rule is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecEntitySelectorBasedRule struct {
	// The rule is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// The entity selector string, by which the entities are selected
	// +optional
	Selector *string `json:"selector,omitempty" tf:"selector"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecMetadata struct {
	// Dynatrace server version
	// +optional
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version"`
	// A Sorted list of the version numbers of the configuration
	// +optional
	ConfigurationVersions []int64 `json:"configurationVersions,omitempty" tf:"configuration_versions"`
	// A Sorted list of the version numbers of the configuration
	// +optional
	CurrentConfigurationVersions []string `json:"currentConfigurationVersions,omitempty" tf:"current_configuration_versions"`
}

type ZoneSpecRulesConditionsApplicationType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsApplicationTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be APPLICATION_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsAzureComputeMode struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsAzureComputeModeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsAzureSku struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsAzureSkuComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be AZURE_SKU
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsBaseComparisonBasic struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// The type of comparison
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsBaseConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// Defines the actual set of fields depending on the value
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsBitness struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are 32 and 64.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsBitnessComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be BITNESS
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are 32 and 64.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsCloudType struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsCloudTypeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be CLOUD_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// The type of comparison
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomApplicationType struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsCustomApplicationTypeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be CUSTOM_APPLICATION_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsCustomHostMetadataDynamicKey struct {
	// The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomHostMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *ZoneSpecRulesConditionsCustomHostMetadataDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey struct {
	// The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomHostMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *ZoneSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be HOST_CUSTOM_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey struct {
	//  The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomProcessMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *ZoneSpecRulesConditionsCustomProcessMetadataDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey struct {
	//  The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsCustomProcessMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *ZoneSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsDatabaseTopology struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsDatabaseTopologyComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be DATABASE_TOPOLOGY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsDcrumDecoder struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsDcrumDecoderComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be DCRUM_DECODER_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsEntity struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsEntityIDComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be ENTITY_ID
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsHostTechValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type ZoneSpecRulesConditionsHostTech struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *ZoneSpecRulesConditionsHostTechValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsHypervisor struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsHypervisorTypeComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be HYPERVISOR_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedName struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedNameComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_NAME
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedString struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedStringComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_STRING
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedTag struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *ZoneSpecRulesConditionsIndexedTagValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedTagComparisonValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIndexedTagComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_TAG
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *ZoneSpecRulesConditionsIndexedTagComparisonValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsInteger struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *int64 `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIntegerComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INTEGER
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *int64 `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIpaddress struct {
	//  The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsIpaddressComparison struct {
	//  The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be IP_ADDRESS
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// Defines the actual set of fields depending on the value
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsMobilePlatform struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsMobilePlatformComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be MOBILE_PLATFORM
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsOsArch struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsOsType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsOsarchitectureComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be OS_ARCHITECTURE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsOstypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be OS_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsPaasType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsPaasTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be PAAS_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsProcessMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsProcessMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsServiceTopology struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsServiceTopologyComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SERVICE_TOPOLOGY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsServiceType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsServiceTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SERVICE_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsSimpleHostTechComparisonValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type ZoneSpecRulesConditionsSimpleHostTechComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SIMPLE_HOST_TECH
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *ZoneSpecRulesConditionsSimpleHostTechComparisonValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsSimpleTechComparisonValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type ZoneSpecRulesConditionsSimpleTechComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SIMPLE_TECH
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *ZoneSpecRulesConditionsSimpleTechComparisonValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsString struct {
	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsStringComparison struct {
	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be STRING
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsStringConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	//    - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	//    - `AMAZON_ECR_IMAGE_REGION`
	//    - `AMAZON_LAMBDA_FUNCTION_NAME`
	//    - `AMAZON_REGION`
	//    - `APACHE_CONFIG_PATH`
	//    - `APACHE_SPARK_MASTER_IP_ADDRESS`
	//    - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	//    - `AWS_ECS_CLUSTER`
	//    - `AWS_ECS_CONTAINERNAME`
	//    - `AWS_ECS_FAMILY`
	//    - `AWS_ECS_REVISION`
	//    - `CASSANDRA_CLUSTER_NAME`
	//    - `CATALINA_BASE`
	//    - `CATALINA_HOME`
	//    - `CLOUD_FOUNDRY_APP_ID`
	//    - `CLOUD_FOUNDRY_APP_NAME`
	//    - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	//    - `CLOUD_FOUNDRY_SPACE_ID`
	//    - `CLOUD_FOUNDRY_SPACE_NAME`
	//    - `COLDFUSION_JVM_CONFIG_FILE`
	//    - `COLDFUSION_SERVICE_NAME`
	//    - `COMMAND_LINE_ARGS`
	//    - `DOTNET_COMMAND`
	//    - `DOTNET_COMMAND_PATH`
	//    - `DYNATRACE_CLUSTER_ID`
	//    - `DYNATRACE_NODE_ID`
	//    - `ELASTICSEARCH_CLUSTER_NAME`
	//    - `ELASTICSEARCH_NODE_NAME`
	//    - `EQUINOX_CONFIG_PATH`
	//    - `EXE_NAME`
	//    - `EXE_PATH`
	//    - `GLASS_FISH_DOMAIN_NAME`
	//    - `GLASS_FISH_INSTANCE_NAME`
	//    - `GOOGLE_APP_ENGINE_INSTANCE`
	//    - `GOOGLE_APP_ENGINE_SERVICE`
	//    - `GOOGLE_CLOUD_PROJECT`
	//    - `HYBRIS_BIN_DIRECTORY`
	//    - `HYBRIS_CONFIG_DIRECTORY`
	//    - `HYBRIS_DATA_DIRECTORY`
	//    - `IBM_CICS_REGION`
	//    - `IBM_CTG_NAME`
	//    - `IBM_IMS_CONNECT_REGION`
	//    - `IBM_IMS_CONTROL_REGION`
	//    - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	//    - `IBM_IMS_SOAP_GW_NAME`
	//    - `IBM_INTEGRATION_NODE_NAME`
	//    - `IBM_INTEGRATION_SERVER_NAME`
	//    - `IIS_APP_POOL`
	//    - `IIS_ROLE_NAME`
	//    - `JAVA_JAR_FILE`
	//    - `JAVA_JAR_PATH`
	//    - `JAVA_MAIN_CLASS`
	//    - `JAVA_MAIN_MODULE`
	//    - `JBOSS_HOME`
	//    - `JBOSS_MODE`
	//    - `JBOSS_SERVER_NAME`
	//    - `KUBERNETES_BASE_POD_NAME`
	//    - `KUBERNETES_CONTAINER_NAME`
	//    - `KUBERNETES_FULL_POD_NAME`
	//    - `KUBERNETES_NAMESPACE`
	//    - `KUBERNETES_POD_UID`
	//    - `MSSQL_INSTANCE_NAME`
	//    - `NODE_JS_APP_BASE_DIRECTORY`
	//    - `NODE_JS_APP_NAME`
	//    - `NODE_JS_SCRIPT_NAME`
	//    - `ORACLE_SID`
	//    - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	//    - `PHP_SCRIPT_PATH`
	//    - `PHP_WORKING_DIRECTORY`
	//    - `RUBY_APP_ROOT_PATH`
	//    - `RUBY_SCRIPT_PATH`
	//    - `RULE_RESULT`
	//    - `SOFTWAREAG_INSTALL_ROOT`
	//    - `SOFTWAREAG_PRODUCTPROPNAME`
	//    - `SPRINGBOOT_APP_NAME`
	//    - `SPRINGBOOT_PROFILE_NAME`
	//    - `SPRINGBOOT_STARTUP_CLASS`
	//    - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	//    - `TIBCO_BUSINESSWORKS_CE_VERSION`
	//    - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	//    - `TIBCO_BUSINESS_WORKS_HOME`
	//    - `VARNISH_INSTANCE_NAME`
	//    - `WEB_LOGIC_CLUSTER_NAME`
	//    - `WEB_LOGIC_DOMAIN_NAME`
	//    - `WEB_LOGIC_HOME`
	//    - `WEB_LOGIC_NAME`
	//    - `WEB_SPHERE_CELL_NAME`
	//    - `WEB_SPHERE_CLUSTER_NAME`
	//    - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be `STRING`
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsStringKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	//    - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	//    - `AMAZON_ECR_IMAGE_REGION`
	//    - `AMAZON_LAMBDA_FUNCTION_NAME`
	//    - `AMAZON_REGION`
	//    - `APACHE_CONFIG_PATH`
	//    - `APACHE_SPARK_MASTER_IP_ADDRESS`
	//    - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	//    - `AWS_ECS_CLUSTER`
	//    - `AWS_ECS_CONTAINERNAME`
	//    - `AWS_ECS_FAMILY`
	//    - `AWS_ECS_REVISION`
	//    - `CASSANDRA_CLUSTER_NAME`
	//    - `CATALINA_BASE`
	//    - `CATALINA_HOME`
	//    - `CLOUD_FOUNDRY_APP_ID`
	//    - `CLOUD_FOUNDRY_APP_NAME`
	//    - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	//    - `CLOUD_FOUNDRY_SPACE_ID`
	//    - `CLOUD_FOUNDRY_SPACE_NAME`
	//    - `COLDFUSION_JVM_CONFIG_FILE`
	//    - `COLDFUSION_SERVICE_NAME`
	//    - `COMMAND_LINE_ARGS`
	//    - `DOTNET_COMMAND`
	//    - `DOTNET_COMMAND_PATH`
	//    - `DYNATRACE_CLUSTER_ID`
	//    - `DYNATRACE_NODE_ID`
	//    - `ELASTICSEARCH_CLUSTER_NAME`
	//    - `ELASTICSEARCH_NODE_NAME`
	//    - `EQUINOX_CONFIG_PATH`
	//    - `EXE_NAME`
	//    - `EXE_PATH`
	//    - `GLASS_FISH_DOMAIN_NAME`
	//    - `GLASS_FISH_INSTANCE_NAME`
	//    - `GOOGLE_APP_ENGINE_INSTANCE`
	//    - `GOOGLE_APP_ENGINE_SERVICE`
	//    - `GOOGLE_CLOUD_PROJECT`
	//    - `HYBRIS_BIN_DIRECTORY`
	//    - `HYBRIS_CONFIG_DIRECTORY`
	//    - `HYBRIS_DATA_DIRECTORY`
	//    - `IBM_CICS_REGION`
	//    - `IBM_CTG_NAME`
	//    - `IBM_IMS_CONNECT_REGION`
	//    - `IBM_IMS_CONTROL_REGION`
	//    - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	//    - `IBM_IMS_SOAP_GW_NAME`
	//    - `IBM_INTEGRATION_NODE_NAME`
	//    - `IBM_INTEGRATION_SERVER_NAME`
	//    - `IIS_APP_POOL`
	//    - `IIS_ROLE_NAME`
	//    - `JAVA_JAR_FILE`
	//    - `JAVA_JAR_PATH`
	//    - `JAVA_MAIN_CLASS`
	//    - `JAVA_MAIN_MODULE`
	//    - `JBOSS_HOME`
	//    - `JBOSS_MODE`
	//    - `JBOSS_SERVER_NAME`
	//    - `KUBERNETES_BASE_POD_NAME`
	//    - `KUBERNETES_CONTAINER_NAME`
	//    - `KUBERNETES_FULL_POD_NAME`
	//    - `KUBERNETES_NAMESPACE`
	//    - `KUBERNETES_POD_UID`
	//    - `MSSQL_INSTANCE_NAME`
	//    - `NODE_JS_APP_BASE_DIRECTORY`
	//    - `NODE_JS_APP_NAME`
	//    - `NODE_JS_SCRIPT_NAME`
	//    - `ORACLE_SID`
	//    - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	//    - `PHP_SCRIPT_PATH`
	//    - `PHP_WORKING_DIRECTORY`
	//    - `RUBY_APP_ROOT_PATH`
	//    - `RUBY_SCRIPT_PATH`
	//    - `RULE_RESULT`
	//    - `SOFTWAREAG_INSTALL_ROOT`
	//    - `SOFTWAREAG_PRODUCTPROPNAME`
	//    - `SPRINGBOOT_APP_NAME`
	//    - `SPRINGBOOT_PROFILE_NAME`
	//    - `SPRINGBOOT_STARTUP_CLASS`
	//    - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	//    - `TIBCO_BUSINESSWORKS_CE_VERSION`
	//    - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	//    - `TIBCO_BUSINESS_WORKS_HOME`
	//    - `VARNISH_INSTANCE_NAME`
	//    - `WEB_LOGIC_CLUSTER_NAME`
	//    - `WEB_LOGIC_DOMAIN_NAME`
	//    - `WEB_LOGIC_HOME`
	//    - `WEB_LOGIC_NAME`
	//    - `WEB_SPHERE_CELL_NAME`
	//    - `WEB_SPHERE_CLUSTER_NAME`
	//    - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRulesConditionsSyntheticEngine struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsSyntheticEngineTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SYNTHETIC_ENGINE_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsTag struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *ZoneSpecRulesConditionsTagValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsTagComparisonValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsTagComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be TAG
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *ZoneSpecRulesConditionsTagComparisonValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditionsTechValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type ZoneSpecRulesConditionsTech struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *ZoneSpecRulesConditionsTechValue `json:"value,omitempty" tf:"value"`
}

type ZoneSpecRulesConditions struct {
	// Comparison for `APPLICATION_TYPE` attributes
	// +optional
	ApplicationType []ZoneSpecRulesConditionsApplicationType `json:"applicationType,omitempty" tf:"application_type"`
	// Comparison for `APPLICATION_TYPE` attributes
	// +optional
	// Deprecated
	ApplicationTypeComparison []ZoneSpecRulesConditionsApplicationTypeComparison `json:"applicationTypeComparison,omitempty" tf:"application_type_comparison"`
	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +optional
	// Deprecated
	AzureComputeMode []ZoneSpecRulesConditionsAzureComputeMode `json:"azureComputeMode,omitempty" tf:"azure_compute_mode"`
	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +optional
	AzureComputeModeComparison []ZoneSpecRulesConditionsAzureComputeModeComparison `json:"azureComputeModeComparison,omitempty" tf:"azure_compute_mode_comparison"`
	// Comparison for `AZURE_SKU` attributes
	// +optional
	AzureSku []ZoneSpecRulesConditionsAzureSku `json:"azureSku,omitempty" tf:"azure_sku"`
	// Comparison for `AZURE_SKU` attributes
	// +optional
	// Deprecated
	AzureSkuComparision []ZoneSpecRulesConditionsAzureSkuComparision `json:"azureSkuComparision,omitempty" tf:"azure_sku_comparision"`
	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +optional
	// Deprecated
	BaseComparisonBasic []ZoneSpecRulesConditionsBaseComparisonBasic `json:"baseComparisonBasic,omitempty" tf:"base_comparison_basic"`
	// Fallback for not yet known type
	// +optional
	// Deprecated
	BaseConditionKey []ZoneSpecRulesConditionsBaseConditionKey `json:"baseConditionKey,omitempty" tf:"base_condition_key"`
	// Comparison for `BITNESS` attributes
	// +optional
	Bitness []ZoneSpecRulesConditionsBitness `json:"bitness,omitempty" tf:"bitness"`
	// Comparison for `BITNESS` attributes
	// +optional
	// Deprecated
	BitnessComparision []ZoneSpecRulesConditionsBitnessComparision `json:"bitnessComparision,omitempty" tf:"bitness_comparision"`
	// Comparison for `CLOUD_TYPE` attributes
	// +optional
	CloudType []ZoneSpecRulesConditionsCloudType `json:"cloudType,omitempty" tf:"cloud_type"`
	// Comparison for `CLOUD_TYPE` attributes
	// +optional
	// Deprecated
	CloudTypeComparison []ZoneSpecRulesConditionsCloudTypeComparison `json:"cloudTypeComparison,omitempty" tf:"cloud_type_comparison"`
	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +optional
	Comparison []ZoneSpecRulesConditionsComparison `json:"comparison,omitempty" tf:"comparison"`
	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +optional
	CustomApplicationType []ZoneSpecRulesConditionsCustomApplicationType `json:"customApplicationType,omitempty" tf:"custom_application_type"`
	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +optional
	// Deprecated
	CustomApplicationTypeComparison []ZoneSpecRulesConditionsCustomApplicationTypeComparison `json:"customApplicationTypeComparison,omitempty" tf:"custom_application_type_comparison"`
	// Key for Custom Host Metadata
	// +optional
	CustomHostMetadata []ZoneSpecRulesConditionsCustomHostMetadata `json:"customHostMetadata,omitempty" tf:"custom_host_metadata"`
	// Key for Custom Host Metadata
	// +optional
	// Deprecated
	CustomHostMetadataConditionKey []ZoneSpecRulesConditionsCustomHostMetadataConditionKey `json:"customHostMetadataConditionKey,omitempty" tf:"custom_host_metadata_condition_key"`
	// Key for Custom Process Metadata
	// +optional
	CustomProcessMetadata []ZoneSpecRulesConditionsCustomProcessMetadata `json:"customProcessMetadata,omitempty" tf:"custom_process_metadata"`
	// Key for Custom Process Metadata
	// +optional
	// Deprecated
	CustomProcessMetadataConditionKey []ZoneSpecRulesConditionsCustomProcessMetadataConditionKey `json:"customProcessMetadataConditionKey,omitempty" tf:"custom_process_metadata_condition_key"`
	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +optional
	DatabaseTopology []ZoneSpecRulesConditionsDatabaseTopology `json:"databaseTopology,omitempty" tf:"database_topology"`
	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +optional
	// Deprecated
	DatabaseTopologyComparison []ZoneSpecRulesConditionsDatabaseTopologyComparison `json:"databaseTopologyComparison,omitempty" tf:"database_topology_comparison"`
	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +optional
	DcrumDecoder []ZoneSpecRulesConditionsDcrumDecoder `json:"dcrumDecoder,omitempty" tf:"dcrum_decoder"`
	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +optional
	// Deprecated
	DcrumDecoderComparison []ZoneSpecRulesConditionsDcrumDecoderComparison `json:"dcrumDecoderComparison,omitempty" tf:"dcrum_decoder_comparison"`
	// Comparison for `ENTITY_ID` attributes
	// +optional
	Entity []ZoneSpecRulesConditionsEntity `json:"entity,omitempty" tf:"entity"`
	// Comparison for `ENTITY_ID` attributes
	// +optional
	// Deprecated
	EntityIDComparison []ZoneSpecRulesConditionsEntityIDComparison `json:"entityIDComparison,omitempty" tf:"entity_id_comparison"`
	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +optional
	HostTech []ZoneSpecRulesConditionsHostTech `json:"hostTech,omitempty" tf:"host_tech"`
	// Comparison for `HYPERVISOR_TYPE` attributes
	// +optional
	Hypervisor []ZoneSpecRulesConditionsHypervisor `json:"hypervisor,omitempty" tf:"hypervisor"`
	// `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
	// +optional
	// Deprecated
	HypervisorTypeComparision []ZoneSpecRulesConditionsHypervisorTypeComparision `json:"hypervisorTypeComparision,omitempty" tf:"hypervisor_type_comparision"`
	// Comparison for `INDEXED_NAME` attributes
	// +optional
	IndexedName []ZoneSpecRulesConditionsIndexedName `json:"indexedName,omitempty" tf:"indexed_name"`
	// Comparison for `INDEXED_NAME` attributes
	// +optional
	// Deprecated
	IndexedNameComparison []ZoneSpecRulesConditionsIndexedNameComparison `json:"indexedNameComparison,omitempty" tf:"indexed_name_comparison"`
	// Comparison for `INDEXED_STRING` attributes
	// +optional
	IndexedString []ZoneSpecRulesConditionsIndexedString `json:"indexedString,omitempty" tf:"indexed_string"`
	// Comparison for `INDEXED_STRING` attributes
	// +optional
	// Deprecated
	IndexedStringComparison []ZoneSpecRulesConditionsIndexedStringComparison `json:"indexedStringComparison,omitempty" tf:"indexed_string_comparison"`
	// Comparison for `INDEXED_TAG` attributes
	// +optional
	IndexedTag []ZoneSpecRulesConditionsIndexedTag `json:"indexedTag,omitempty" tf:"indexed_tag"`
	// Comparison for `INDEXED_TAG` attributes
	// +optional
	// Deprecated
	IndexedTagComparison []ZoneSpecRulesConditionsIndexedTagComparison `json:"indexedTagComparison,omitempty" tf:"indexed_tag_comparison"`
	// Comparison for `INTEGER` attributes
	// +optional
	Integer []ZoneSpecRulesConditionsInteger `json:"integer,omitempty" tf:"integer"`
	// Comparison for `INTEGER` attributes
	// +optional
	// Deprecated
	IntegerComparison []ZoneSpecRulesConditionsIntegerComparison `json:"integerComparison,omitempty" tf:"integer_comparison"`
	// Comparison for `IP_ADDRESS` attributes
	// +optional
	Ipaddress []ZoneSpecRulesConditionsIpaddress `json:"ipaddress,omitempty" tf:"ipaddress"`
	// Comparison for `IP_ADDRESS` attributes
	// +optional
	// Deprecated
	IpaddressComparison []ZoneSpecRulesConditionsIpaddressComparison `json:"ipaddressComparison,omitempty" tf:"ipaddress_comparison"`
	// Fallback for not yet known type
	// +optional
	Key []ZoneSpecRulesConditionsKey `json:"key,omitempty" tf:"key"`
	// Comparison for `MOBILE_PLATFORM` attributes
	// +optional
	MobilePlatform []ZoneSpecRulesConditionsMobilePlatform `json:"mobilePlatform,omitempty" tf:"mobile_platform"`
	// Comparison for `MOBILE_PLATFORM` attributes
	// +optional
	// Deprecated
	MobilePlatformComparison []ZoneSpecRulesConditionsMobilePlatformComparison `json:"mobilePlatformComparison,omitempty" tf:"mobile_platform_comparison"`
	// Comparison for `OS_ARCHITECTURE` attributes
	// +optional
	OsArch []ZoneSpecRulesConditionsOsArch `json:"osArch,omitempty" tf:"os_arch"`
	// Comparison for `OS_TYPE` attributes
	// +optional
	OsType []ZoneSpecRulesConditionsOsType `json:"osType,omitempty" tf:"os_type"`
	// Comparison for `OS_ARCHITECTURE` attributes
	// +optional
	// Deprecated
	OsarchitectureComparison []ZoneSpecRulesConditionsOsarchitectureComparison `json:"osarchitectureComparison,omitempty" tf:"osarchitecture_comparison"`
	// Comparison for `OS_TYPE` attributes
	// +optional
	// Deprecated
	OstypeComparison []ZoneSpecRulesConditionsOstypeComparison `json:"ostypeComparison,omitempty" tf:"ostype_comparison"`
	// Comparison for `PAAS_TYPE` attributes
	// +optional
	PaasType []ZoneSpecRulesConditionsPaasType `json:"paasType,omitempty" tf:"paas_type"`
	// Comparison for `PAAS_TYPE` attributes
	// +optional
	// Deprecated
	PaasTypeComparison []ZoneSpecRulesConditionsPaasTypeComparison `json:"paasTypeComparison,omitempty" tf:"paas_type_comparison"`
	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +optional
	ProcessMetadata []ZoneSpecRulesConditionsProcessMetadata `json:"processMetadata,omitempty" tf:"process_metadata"`
	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +optional
	// Deprecated
	ProcessMetadataConditionKey []ZoneSpecRulesConditionsProcessMetadataConditionKey `json:"processMetadataConditionKey,omitempty" tf:"process_metadata_condition_key"`
	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +optional
	ServiceTopology []ZoneSpecRulesConditionsServiceTopology `json:"serviceTopology,omitempty" tf:"service_topology"`
	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +optional
	// Deprecated
	ServiceTopologyComparison []ZoneSpecRulesConditionsServiceTopologyComparison `json:"serviceTopologyComparison,omitempty" tf:"service_topology_comparison"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	ServiceType []ZoneSpecRulesConditionsServiceType `json:"serviceType,omitempty" tf:"service_type"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	// Deprecated
	ServiceTypeComparison []ZoneSpecRulesConditionsServiceTypeComparison `json:"serviceTypeComparison,omitempty" tf:"service_type_comparison"`
	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +optional
	// Deprecated
	SimpleHostTechComparison []ZoneSpecRulesConditionsSimpleHostTechComparison `json:"simpleHostTechComparison,omitempty" tf:"simple_host_tech_comparison"`
	// Comparison for `SIMPLE_TECH` attributes
	// +optional
	// Deprecated
	SimpleTechComparison []ZoneSpecRulesConditionsSimpleTechComparison `json:"simpleTechComparison,omitempty" tf:"simple_tech_comparison"`
	// Comparison for `STRING` attributes
	// +optional
	String []ZoneSpecRulesConditionsString `json:"string,omitempty" tf:"string"`
	// Comparison for `STRING` attributes
	// +optional
	// Deprecated
	StringComparison []ZoneSpecRulesConditionsStringComparison `json:"stringComparison,omitempty" tf:"string_comparison"`
	//  The key for dynamic attributes of the `STRING` type
	// +optional
	// Deprecated
	StringConditionKey []ZoneSpecRulesConditionsStringConditionKey `json:"stringConditionKey,omitempty" tf:"string_condition_key"`
	//  The key for dynamic attributes of the `STRING` type
	// +optional
	StringKey []ZoneSpecRulesConditionsStringKey `json:"stringKey,omitempty" tf:"string_key"`
	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +optional
	SyntheticEngine []ZoneSpecRulesConditionsSyntheticEngine `json:"syntheticEngine,omitempty" tf:"synthetic_engine"`
	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +optional
	// Deprecated
	SyntheticEngineTypeComparison []ZoneSpecRulesConditionsSyntheticEngineTypeComparison `json:"syntheticEngineTypeComparison,omitempty" tf:"synthetic_engine_type_comparison"`
	// Comparison for `TAG` attributes
	// +optional
	Tag []ZoneSpecRulesConditionsTag `json:"tag,omitempty" tf:"tag"`
	// Comparison for `TAG` attributes
	// +optional
	// Deprecated
	TagComparison []ZoneSpecRulesConditionsTagComparison `json:"tagComparison,omitempty" tf:"tag_comparison"`
	// Comparison for `SIMPLE_TECH` attributes
	// +optional
	Tech []ZoneSpecRulesConditionsTech `json:"tech,omitempty" tf:"tech"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpecRules struct {
	// A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
	// +optional
	// +kubebuilder:validation:MinItems=1
	Conditions []ZoneSpecRulesConditions `json:"conditions,omitempty" tf:"conditions"`
	// The rule is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// How to apply the management zone to underlying entities:
	//    - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
	//    - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
	//    - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
	//    - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
	//    - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
	//    - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
	//    - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
	//    - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
	// +optional
	PropagationTypes []string `json:"propagationTypes,omitempty" tf:"propagation_types"`
	// The type of Dynatrace entities the management zone can be applied to
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneSpec struct {
	State *ZoneSpecResource `json:"state,omitempty" tf:"-"`

	Resource ZoneSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type ZoneSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The description of the management zone
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// A list of dimensional data rules for management zone usage. If several rules are specified, the `or` logic applies
	// +optional
	// +kubebuilder:validation:MinItems=1
	DimensionalRule []ZoneSpecDimensionalRule `json:"dimensionalRule,omitempty" tf:"dimensional_rule"`
	// A list of entity-selector based rules for management zone usage. If several rules are specified, the `or` logic applies
	// +optional
	// +kubebuilder:validation:MinItems=1
	EntitySelectorBasedRule []ZoneSpecEntitySelectorBasedRule `json:"entitySelectorBasedRule,omitempty" tf:"entity_selector_based_rule"`
	// `metadata` exists for backwards compatibility but shouldn't get specified anymore
	// +optional
	// Deprecated
	Metadata *ZoneSpecMetadata `json:"metadata,omitempty" tf:"metadata"`
	// The name of the management zone
	Name *string `json:"name" tf:"name"`
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	// +optional
	// +kubebuilder:validation:MinItems=1
	Rules []ZoneSpecRules `json:"rules,omitempty" tf:"rules"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ZoneStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ZoneList is a list of Zones
type ZoneList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Zone CRD objects
	Items []Zone `json:"items,omitempty"`
}
