/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Anomalies struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AnomaliesSpec   `json:"spec,omitempty"`
	Status            AnomaliesStatus `json:"status,omitempty"`
}

type AnomaliesSpecDimensionsDimension struct {
	// The dimensions key on the metric
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// Defines the actual set of fields depending on the value
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecDimensionsEntityFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecDimensionsEntity struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecDimensionsEntityFilter `json:"filter" tf:"filter"`
	// The dimensions key on the metric
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecDimensionsStringFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecDimensionsString struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecDimensionsStringFilter `json:"filter" tf:"filter"`
	// The dimensions key on the metric
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecDimensions struct {
	// A generic definition for a filter
	// +optional
	Dimension []AnomaliesSpecDimensionsDimension `json:"dimension,omitempty" tf:"dimension"`
	// A filter for the metrics entity dimensions
	// +optional
	Entity []AnomaliesSpecDimensionsEntity `json:"entity,omitempty" tf:"entity"`
	// A filter for the metrics string dimensions
	// +optional
	String []AnomaliesSpecDimensionsString `json:"string,omitempty" tf:"string"`
}

type AnomaliesSpecScopesCustomDeviceGroupNameFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecScopesCustomDeviceGroupName struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecScopesCustomDeviceGroupNameFilter `json:"filter" tf:"filter"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesEntity struct {
	// The monitored entities id to match on
	ID *string `json:"ID" tf:"id"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesHostGroupNameFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecScopesHostGroupName struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecScopesHostGroupNameFilter `json:"filter" tf:"filter"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesHostNameFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecScopesHostName struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecScopesHostNameFilter `json:"filter" tf:"filter"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesManagementZone struct {
	// The management zone id to match on
	// +optional
	ID *string `json:"ID,omitempty" tf:"id"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesNameFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecScopesName struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecScopesNameFilter `json:"filter" tf:"filter"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesProcessGroupID struct {
	// The process groups id to match on
	ID *string `json:"ID" tf:"id"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesProcessGroupNameFilter struct {
	// The operator to match on
	Operator *string `json:"operator" tf:"operator"`
	// The value to match on
	Value *string `json:"value" tf:"value"`
}

type AnomaliesSpecScopesProcessGroupName struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecScopesProcessGroupNameFilter `json:"filter" tf:"filter"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesScope struct {
	// Defines the actual set of fields depending on the value
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopesTagFilter struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AnomaliesSpecScopesTag struct {
	// A filter for a string value based on the given operator
	Filter *AnomaliesSpecScopesTagFilter `json:"filter" tf:"filter"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecScopes struct {
	// A scope filter for the related custom device group name
	// +optional
	CustomDeviceGroupName []AnomaliesSpecScopesCustomDeviceGroupName `json:"customDeviceGroupName,omitempty" tf:"custom_device_group_name"`
	// A scope filter for a monitored entity identifier
	// +optional
	Entity []AnomaliesSpecScopesEntity `json:"entity,omitempty" tf:"entity"`
	// A scope filter for the related host group name
	// +optional
	HostGroupName []AnomaliesSpecScopesHostGroupName `json:"hostGroupName,omitempty" tf:"host_group_name"`
	// A scope filter for the related host name
	// +optional
	HostName []AnomaliesSpecScopesHostName `json:"hostName,omitempty" tf:"host_name"`
	// A scope filter for a management zone identifier
	// +optional
	ManagementZone []AnomaliesSpecScopesManagementZone `json:"managementZone,omitempty" tf:"management_zone"`
	// A scope filter for a monitored entity name
	// +optional
	Name []AnomaliesSpecScopesName `json:"name,omitempty" tf:"name"`
	// A scope filter for a process group identifier
	// +optional
	ProcessGroupID []AnomaliesSpecScopesProcessGroupID `json:"processGroupID,omitempty" tf:"process_group_id"`
	// A scope filter for the related process group name
	// +optional
	ProcessGroupName []AnomaliesSpecScopesProcessGroupName `json:"processGroupName,omitempty" tf:"process_group_name"`
	// A generic scope filter
	// +optional
	Scope []AnomaliesSpecScopesScope `json:"scope,omitempty" tf:"scope"`
	// A scope filter for tags on entities
	// +optional
	Tag []AnomaliesSpecScopesTag `json:"tag,omitempty" tf:"tag"`
}

type AnomaliesSpecStrategyAuto struct {
	// The condition for the **threshold** value check: `ABOVE` or `BELOW`
	AlertCondition *string `json:"alertCondition" tf:"alert_condition"`
	// If true, also one-minute samples without data are counted as violating samples
	// +optional
	AlertingOnMissingData *bool `json:"alertingOnMissingData,omitempty" tf:"alerting_on_missing_data"`
	// The number of one-minute samples within the evaluation window that must go back to normal to close the event
	DealertingSamples *int64 `json:"dealertingSamples" tf:"dealerting_samples"`
	// The number of one-minute samples that form the sliding evaluation window
	Samples *int64 `json:"samples" tf:"samples"`
	// Defines the factor of how many signal fluctuations are valid. Values above the baseline plus the signal fluctuation times the number of tolerated signal fluctuations are alerted
	SignalFluctuations *float64 `json:"signalFluctuations" tf:"signal_fluctuations"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event
	ViolatingSamples *int64 `json:"violatingSamples" tf:"violating_samples"`
}

type AnomaliesSpecStrategyGeneric struct {
	// Defines the actual set of fields depending on the value
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AnomaliesSpecStrategyStatic struct {
	// The condition for the **threshold** value check: `ABOVE` or `BELOW`
	AlertCondition *string `json:"alertCondition" tf:"alert_condition"`
	// If true, also one-minute samples without data are counted as violating samples
	// +optional
	AlertingOnMissingData *bool `json:"alertingOnMissingData,omitempty" tf:"alerting_on_missing_data"`
	// The number of one-minute samples within the evaluation window that must go back to normal to close the event
	DealertingSamples *int64 `json:"dealertingSamples" tf:"dealerting_samples"`
	// The number of one-minute samples that form the sliding evaluation window
	Samples *int64 `json:"samples" tf:"samples"`
	// The value of the static threshold based on the specified unit
	Threshold *float64 `json:"threshold" tf:"threshold"`
	// The unit of the threshold, matching the metric definition
	Unit *string `json:"unit" tf:"unit"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event
	ViolatingSamples *int64 `json:"violatingSamples" tf:"violating_samples"`
}

type AnomaliesSpecStrategy struct {
	// An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time
	// +optional
	Auto *AnomaliesSpecStrategyAuto `json:"auto,omitempty" tf:"auto"`
	// A generic monitoring strategy
	// +optional
	Generic []AnomaliesSpecStrategyGeneric `json:"generic,omitempty" tf:"generic"`
	// A static threshold monitoring strategy to alert on hard limits within a given metric. An example is the violation of a critical memory limit
	// +optional
	Static *AnomaliesSpecStrategyStatic `json:"static,omitempty" tf:"static"`
}

type AnomaliesSpec struct {
	State *AnomaliesSpecResource `json:"state,omitempty" tf:"-"`

	Resource AnomaliesSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type AnomaliesSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// How the metric data points are aggregated for the evaluation. The timeseries must support this aggregation
	// +optional
	AggregationType *string `json:"aggregationType,omitempty" tf:"aggregation_type"`
	// The description of the metric event
	Description *string `json:"description" tf:"description"`
	// Defines the dimensions of the metric to alert on. The filters are combined by conjunction
	// +optional
	Dimensions []AnomaliesSpecDimensions `json:"dimensions,omitempty" tf:"dimensions"`
	// The reason of automatic disabling.  The `NONE` means config was not disabled automatically. Possible values are `METRIC_DEFINITION_INCONSISTENCY`, `NONE`, `TOO_MANY_DIMS` and `TOPX_FORCIBLY_DEACTIVATED`
	// +optional
	DisabledReason *string `json:"disabledReason,omitempty" tf:"disabled_reason"`
	// The metric event is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled" tf:"enabled"`
	// The ID of the metric evaluated by the metric event
	MetricID *string `json:"metricID" tf:"metric_id"`
	// The name of the metric event displayed in the UI
	Name *string `json:"name" tf:"name"`
	// Defines which dimension key should be used for the **alertingScope**
	// +optional
	PrimaryDimensionKey *string `json:"primaryDimensionKey,omitempty" tf:"primary_dimension_key"`
	// Defines the scope of the metric event. Only one filter is allowed per filter type, except for tags, where up to 3 are allowed. The filters are combined by conjunction
	// +optional
	Scopes []AnomaliesSpecScopes `json:"scopes,omitempty" tf:"scopes"`
	// The type of the event to trigger on the threshold violation.  The `CUSTOM_ALERT` type is not correlated with other alerts. The `INFO` type does not open a problem
	// +optional
	Severity *string `json:"severity,omitempty" tf:"severity"`
	// A monitoring strategy for a metric event config. This is the base version of the monitoring strategy, depending on the type,  the actual JSON may contain additional fields
	Strategy *AnomaliesSpecStrategy `json:"strategy" tf:"strategy"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The reason of a warning set on the config. The `NONE` means config has no warnings. The other supported value is `TOO_MANY_DIMS`
	// +optional
	WarningReason *string `json:"warningReason,omitempty" tf:"warning_reason"`
}

type AnomaliesStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// AnomaliesList is a list of Anomaliess
type AnomaliesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Anomalies CRD objects
	Items []Anomalies `json:"items,omitempty"`
}
