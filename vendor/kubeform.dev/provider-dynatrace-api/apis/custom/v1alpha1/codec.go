/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsEntityFilter{}).Type1()):            AnomaliesSpecDimensionsEntityFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsStringFilter{}).Type1()):            AnomaliesSpecDimensionsStringFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesCustomDeviceGroupNameFilter{}).Type1()): AnomaliesSpecScopesCustomDeviceGroupNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostGroupNameFilter{}).Type1()):         AnomaliesSpecScopesHostGroupNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostNameFilter{}).Type1()):              AnomaliesSpecScopesHostNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesNameFilter{}).Type1()):                  AnomaliesSpecScopesNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesProcessGroupNameFilter{}).Type1()):      AnomaliesSpecScopesProcessGroupNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesTagFilter{}).Type1()):                   AnomaliesSpecScopesTagFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategy{}).Type1()):                          AnomaliesSpecStrategyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyAuto{}).Type1()):                      AnomaliesSpecStrategyAutoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyStatic{}).Type1()):                    AnomaliesSpecStrategyStaticCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleClass{}).Type1()):                           ServiceSpecRuleClassCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleFile{}).Type1()):                            ServiceSpecRuleFileCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsEntityFilter{}).Type1()):            AnomaliesSpecDimensionsEntityFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsStringFilter{}).Type1()):            AnomaliesSpecDimensionsStringFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesCustomDeviceGroupNameFilter{}).Type1()): AnomaliesSpecScopesCustomDeviceGroupNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostGroupNameFilter{}).Type1()):         AnomaliesSpecScopesHostGroupNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostNameFilter{}).Type1()):              AnomaliesSpecScopesHostNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesNameFilter{}).Type1()):                  AnomaliesSpecScopesNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesProcessGroupNameFilter{}).Type1()):      AnomaliesSpecScopesProcessGroupNameFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesTagFilter{}).Type1()):                   AnomaliesSpecScopesTagFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategy{}).Type1()):                          AnomaliesSpecStrategyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyAuto{}).Type1()):                      AnomaliesSpecStrategyAutoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyStatic{}).Type1()):                    AnomaliesSpecStrategyStaticCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleClass{}).Type1()):                           ServiceSpecRuleClassCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleFile{}).Type1()):                            ServiceSpecRuleFileCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDimensionsEntityFilterCodec struct {
}

func (AnomaliesSpecDimensionsEntityFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDimensionsEntityFilter)(ptr) == nil
}

func (AnomaliesSpecDimensionsEntityFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDimensionsEntityFilter)(ptr)
	var objs []AnomaliesSpecDimensionsEntityFilter
	if obj != nil {
		objs = []AnomaliesSpecDimensionsEntityFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsEntityFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDimensionsEntityFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDimensionsEntityFilter)(ptr) = AnomaliesSpecDimensionsEntityFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDimensionsEntityFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsEntityFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDimensionsEntityFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDimensionsEntityFilter)(ptr) = AnomaliesSpecDimensionsEntityFilter{}
			}
		} else {
			*(*AnomaliesSpecDimensionsEntityFilter)(ptr) = AnomaliesSpecDimensionsEntityFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDimensionsEntityFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsEntityFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDimensionsEntityFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecDimensionsEntityFilter)(ptr) = AnomaliesSpecDimensionsEntityFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDimensionsEntityFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecDimensionsStringFilterCodec struct {
}

func (AnomaliesSpecDimensionsStringFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecDimensionsStringFilter)(ptr) == nil
}

func (AnomaliesSpecDimensionsStringFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecDimensionsStringFilter)(ptr)
	var objs []AnomaliesSpecDimensionsStringFilter
	if obj != nil {
		objs = []AnomaliesSpecDimensionsStringFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsStringFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecDimensionsStringFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecDimensionsStringFilter)(ptr) = AnomaliesSpecDimensionsStringFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecDimensionsStringFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsStringFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecDimensionsStringFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecDimensionsStringFilter)(ptr) = AnomaliesSpecDimensionsStringFilter{}
			}
		} else {
			*(*AnomaliesSpecDimensionsStringFilter)(ptr) = AnomaliesSpecDimensionsStringFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecDimensionsStringFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecDimensionsStringFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecDimensionsStringFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecDimensionsStringFilter)(ptr) = AnomaliesSpecDimensionsStringFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecDimensionsStringFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecScopesCustomDeviceGroupNameFilterCodec struct {
}

func (AnomaliesSpecScopesCustomDeviceGroupNameFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) == nil
}

func (AnomaliesSpecScopesCustomDeviceGroupNameFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr)
	var objs []AnomaliesSpecScopesCustomDeviceGroupNameFilter
	if obj != nil {
		objs = []AnomaliesSpecScopesCustomDeviceGroupNameFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesCustomDeviceGroupNameFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecScopesCustomDeviceGroupNameFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) = AnomaliesSpecScopesCustomDeviceGroupNameFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecScopesCustomDeviceGroupNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesCustomDeviceGroupNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) = AnomaliesSpecScopesCustomDeviceGroupNameFilter{}
			}
		} else {
			*(*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) = AnomaliesSpecScopesCustomDeviceGroupNameFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecScopesCustomDeviceGroupNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesCustomDeviceGroupNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecScopesCustomDeviceGroupNameFilter)(ptr) = AnomaliesSpecScopesCustomDeviceGroupNameFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecScopesCustomDeviceGroupNameFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecScopesHostGroupNameFilterCodec struct {
}

func (AnomaliesSpecScopesHostGroupNameFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecScopesHostGroupNameFilter)(ptr) == nil
}

func (AnomaliesSpecScopesHostGroupNameFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecScopesHostGroupNameFilter)(ptr)
	var objs []AnomaliesSpecScopesHostGroupNameFilter
	if obj != nil {
		objs = []AnomaliesSpecScopesHostGroupNameFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostGroupNameFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecScopesHostGroupNameFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecScopesHostGroupNameFilter)(ptr) = AnomaliesSpecScopesHostGroupNameFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecScopesHostGroupNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostGroupNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecScopesHostGroupNameFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecScopesHostGroupNameFilter)(ptr) = AnomaliesSpecScopesHostGroupNameFilter{}
			}
		} else {
			*(*AnomaliesSpecScopesHostGroupNameFilter)(ptr) = AnomaliesSpecScopesHostGroupNameFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecScopesHostGroupNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostGroupNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecScopesHostGroupNameFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecScopesHostGroupNameFilter)(ptr) = AnomaliesSpecScopesHostGroupNameFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecScopesHostGroupNameFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecScopesHostNameFilterCodec struct {
}

func (AnomaliesSpecScopesHostNameFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecScopesHostNameFilter)(ptr) == nil
}

func (AnomaliesSpecScopesHostNameFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecScopesHostNameFilter)(ptr)
	var objs []AnomaliesSpecScopesHostNameFilter
	if obj != nil {
		objs = []AnomaliesSpecScopesHostNameFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostNameFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecScopesHostNameFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecScopesHostNameFilter)(ptr) = AnomaliesSpecScopesHostNameFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecScopesHostNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecScopesHostNameFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecScopesHostNameFilter)(ptr) = AnomaliesSpecScopesHostNameFilter{}
			}
		} else {
			*(*AnomaliesSpecScopesHostNameFilter)(ptr) = AnomaliesSpecScopesHostNameFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecScopesHostNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesHostNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecScopesHostNameFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecScopesHostNameFilter)(ptr) = AnomaliesSpecScopesHostNameFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecScopesHostNameFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecScopesNameFilterCodec struct {
}

func (AnomaliesSpecScopesNameFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecScopesNameFilter)(ptr) == nil
}

func (AnomaliesSpecScopesNameFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecScopesNameFilter)(ptr)
	var objs []AnomaliesSpecScopesNameFilter
	if obj != nil {
		objs = []AnomaliesSpecScopesNameFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesNameFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecScopesNameFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecScopesNameFilter)(ptr) = AnomaliesSpecScopesNameFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecScopesNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecScopesNameFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecScopesNameFilter)(ptr) = AnomaliesSpecScopesNameFilter{}
			}
		} else {
			*(*AnomaliesSpecScopesNameFilter)(ptr) = AnomaliesSpecScopesNameFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecScopesNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecScopesNameFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecScopesNameFilter)(ptr) = AnomaliesSpecScopesNameFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecScopesNameFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecScopesProcessGroupNameFilterCodec struct {
}

func (AnomaliesSpecScopesProcessGroupNameFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) == nil
}

func (AnomaliesSpecScopesProcessGroupNameFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecScopesProcessGroupNameFilter)(ptr)
	var objs []AnomaliesSpecScopesProcessGroupNameFilter
	if obj != nil {
		objs = []AnomaliesSpecScopesProcessGroupNameFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesProcessGroupNameFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecScopesProcessGroupNameFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) = AnomaliesSpecScopesProcessGroupNameFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecScopesProcessGroupNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesProcessGroupNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) = AnomaliesSpecScopesProcessGroupNameFilter{}
			}
		} else {
			*(*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) = AnomaliesSpecScopesProcessGroupNameFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecScopesProcessGroupNameFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesProcessGroupNameFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecScopesProcessGroupNameFilter)(ptr) = AnomaliesSpecScopesProcessGroupNameFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecScopesProcessGroupNameFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecScopesTagFilterCodec struct {
}

func (AnomaliesSpecScopesTagFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecScopesTagFilter)(ptr) == nil
}

func (AnomaliesSpecScopesTagFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecScopesTagFilter)(ptr)
	var objs []AnomaliesSpecScopesTagFilter
	if obj != nil {
		objs = []AnomaliesSpecScopesTagFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesTagFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecScopesTagFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecScopesTagFilter)(ptr) = AnomaliesSpecScopesTagFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecScopesTagFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesTagFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecScopesTagFilter)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecScopesTagFilter)(ptr) = AnomaliesSpecScopesTagFilter{}
			}
		} else {
			*(*AnomaliesSpecScopesTagFilter)(ptr) = AnomaliesSpecScopesTagFilter{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecScopesTagFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecScopesTagFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecScopesTagFilter)(ptr) = obj
		} else {
			*(*AnomaliesSpecScopesTagFilter)(ptr) = AnomaliesSpecScopesTagFilter{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecScopesTagFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecStrategyCodec struct {
}

func (AnomaliesSpecStrategyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecStrategy)(ptr) == nil
}

func (AnomaliesSpecStrategyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecStrategy)(ptr)
	var objs []AnomaliesSpecStrategy
	if obj != nil {
		objs = []AnomaliesSpecStrategy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecStrategyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecStrategy)(ptr) = AnomaliesSpecStrategy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecStrategy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecStrategy)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecStrategy)(ptr) = AnomaliesSpecStrategy{}
			}
		} else {
			*(*AnomaliesSpecStrategy)(ptr) = AnomaliesSpecStrategy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecStrategy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecStrategy)(ptr) = obj
		} else {
			*(*AnomaliesSpecStrategy)(ptr) = AnomaliesSpecStrategy{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecStrategy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecStrategyAutoCodec struct {
}

func (AnomaliesSpecStrategyAutoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecStrategyAuto)(ptr) == nil
}

func (AnomaliesSpecStrategyAutoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecStrategyAuto)(ptr)
	var objs []AnomaliesSpecStrategyAuto
	if obj != nil {
		objs = []AnomaliesSpecStrategyAuto{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyAuto{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecStrategyAutoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecStrategyAuto)(ptr) = AnomaliesSpecStrategyAuto{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecStrategyAuto

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyAuto{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecStrategyAuto)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecStrategyAuto)(ptr) = AnomaliesSpecStrategyAuto{}
			}
		} else {
			*(*AnomaliesSpecStrategyAuto)(ptr) = AnomaliesSpecStrategyAuto{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecStrategyAuto

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyAuto{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecStrategyAuto)(ptr) = obj
		} else {
			*(*AnomaliesSpecStrategyAuto)(ptr) = AnomaliesSpecStrategyAuto{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecStrategyAuto", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnomaliesSpecStrategyStaticCodec struct {
}

func (AnomaliesSpecStrategyStaticCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnomaliesSpecStrategyStatic)(ptr) == nil
}

func (AnomaliesSpecStrategyStaticCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnomaliesSpecStrategyStatic)(ptr)
	var objs []AnomaliesSpecStrategyStatic
	if obj != nil {
		objs = []AnomaliesSpecStrategyStatic{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyStatic{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnomaliesSpecStrategyStaticCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnomaliesSpecStrategyStatic)(ptr) = AnomaliesSpecStrategyStatic{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnomaliesSpecStrategyStatic

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyStatic{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnomaliesSpecStrategyStatic)(ptr) = objs[0]
			} else {
				*(*AnomaliesSpecStrategyStatic)(ptr) = AnomaliesSpecStrategyStatic{}
			}
		} else {
			*(*AnomaliesSpecStrategyStatic)(ptr) = AnomaliesSpecStrategyStatic{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AnomaliesSpecStrategyStatic

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnomaliesSpecStrategyStatic{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AnomaliesSpecStrategyStatic)(ptr) = obj
		} else {
			*(*AnomaliesSpecStrategyStatic)(ptr) = AnomaliesSpecStrategyStatic{}
		}
	default:
		iter.ReportError("decode AnomaliesSpecStrategyStatic", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecRuleClassCodec struct {
}

func (ServiceSpecRuleClassCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecRuleClass)(ptr) == nil
}

func (ServiceSpecRuleClassCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecRuleClass)(ptr)
	var objs []ServiceSpecRuleClass
	if obj != nil {
		objs = []ServiceSpecRuleClass{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleClass{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecRuleClassCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecRuleClass)(ptr) = ServiceSpecRuleClass{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecRuleClass

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleClass{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecRuleClass)(ptr) = objs[0]
			} else {
				*(*ServiceSpecRuleClass)(ptr) = ServiceSpecRuleClass{}
			}
		} else {
			*(*ServiceSpecRuleClass)(ptr) = ServiceSpecRuleClass{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ServiceSpecRuleClass

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleClass{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ServiceSpecRuleClass)(ptr) = obj
		} else {
			*(*ServiceSpecRuleClass)(ptr) = ServiceSpecRuleClass{}
		}
	default:
		iter.ReportError("decode ServiceSpecRuleClass", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecRuleFileCodec struct {
}

func (ServiceSpecRuleFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecRuleFile)(ptr) == nil
}

func (ServiceSpecRuleFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecRuleFile)(ptr)
	var objs []ServiceSpecRuleFile
	if obj != nil {
		objs = []ServiceSpecRuleFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecRuleFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecRuleFile)(ptr) = ServiceSpecRuleFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecRuleFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecRuleFile)(ptr) = objs[0]
			} else {
				*(*ServiceSpecRuleFile)(ptr) = ServiceSpecRuleFile{}
			}
		} else {
			*(*ServiceSpecRuleFile)(ptr) = ServiceSpecRuleFile{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ServiceSpecRuleFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecRuleFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ServiceSpecRuleFile)(ptr) = obj
		} else {
			*(*ServiceSpecRuleFile)(ptr) = ServiceSpecRuleFile{}
		}
	default:
		iter.ReportError("decode ServiceSpecRuleFile", "unexpected JSON type")
	}
}
