/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecMetadata{}).Type1()):                                                   AutotagSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1()):                AutotagSpecRulesConditionsCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1()):             AutotagSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsHostTechValue{}).Type1()):                               AutotagSpecRulesConditionsHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagValue{}).Type1()):                             AutotagSpecRulesConditionsIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagComparisonValue{}).Type1()):                   AutotagSpecRulesConditionsIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1()):               AutotagSpecRulesConditionsSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleTechComparisonValue{}).Type1()):                   AutotagSpecRulesConditionsSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagValue{}).Type1()):                                    AutotagSpecRulesConditionsTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagComparisonValue{}).Type1()):                          AutotagSpecRulesConditionsTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTechValue{}).Type1()):                                   AutotagSpecRulesConditionsTechValueCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecMetadata{}).Type1()):                                                   AutotagSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1()):                AutotagSpecRulesConditionsCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1()):             AutotagSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsHostTechValue{}).Type1()):                               AutotagSpecRulesConditionsHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagValue{}).Type1()):                             AutotagSpecRulesConditionsIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagComparisonValue{}).Type1()):                   AutotagSpecRulesConditionsIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1()):               AutotagSpecRulesConditionsSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleTechComparisonValue{}).Type1()):                   AutotagSpecRulesConditionsSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagValue{}).Type1()):                                    AutotagSpecRulesConditionsTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagComparisonValue{}).Type1()):                          AutotagSpecRulesConditionsTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTechValue{}).Type1()):                                   AutotagSpecRulesConditionsTechValueCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutotagSpecMetadataCodec struct {
}

func (AutotagSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecMetadata)(ptr) == nil
}

func (AutotagSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecMetadata)(ptr)
	var objs []AutotagSpecMetadata
	if obj != nil {
		objs = []AutotagSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecMetadata)(ptr) = AutotagSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecMetadata)(ptr) = objs[0]
			} else {
				*(*AutotagSpecMetadata)(ptr) = AutotagSpecMetadata{}
			}
		} else {
			*(*AutotagSpecMetadata)(ptr) = AutotagSpecMetadata{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecMetadata)(ptr) = obj
		} else {
			*(*AutotagSpecMetadata)(ptr) = AutotagSpecMetadata{}
		}
	default:
		iter.ReportError("decode AutotagSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsCustomHostMetadataDynamicKeyCodec struct {
}

func (AutotagSpecRulesConditionsCustomHostMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) == nil
}

func (AutotagSpecRulesConditionsCustomHostMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr)
	var objs []AutotagSpecRulesConditionsCustomHostMetadataDynamicKey
	if obj != nil {
		objs = []AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsCustomHostMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}
			}
		} else {
			*(*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsCustomHostMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsCustomHostMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec struct {
}

func (AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr)
	var objs []AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec struct {
}

func (AutotagSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) == nil
}

func (AutotagSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr)
	var objs []AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey
	if obj != nil {
		objs = []AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsCustomProcessMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}
			}
		} else {
			*(*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec struct {
}

func (AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr)
	var objs []AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey)(ptr) = AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsHostTechValueCodec struct {
}

func (AutotagSpecRulesConditionsHostTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsHostTechValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsHostTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsHostTechValue)(ptr)
	var objs []AutotagSpecRulesConditionsHostTechValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsHostTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsHostTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsHostTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsHostTechValue)(ptr) = AutotagSpecRulesConditionsHostTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsHostTechValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsHostTechValue)(ptr) = AutotagSpecRulesConditionsHostTechValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsHostTechValue)(ptr) = AutotagSpecRulesConditionsHostTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsHostTechValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsHostTechValue)(ptr) = AutotagSpecRulesConditionsHostTechValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsHostTechValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsIndexedTagValueCodec struct {
}

func (AutotagSpecRulesConditionsIndexedTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsIndexedTagValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsIndexedTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsIndexedTagValue)(ptr)
	var objs []AutotagSpecRulesConditionsIndexedTagValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsIndexedTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsIndexedTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsIndexedTagValue)(ptr) = AutotagSpecRulesConditionsIndexedTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsIndexedTagValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsIndexedTagValue)(ptr) = AutotagSpecRulesConditionsIndexedTagValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsIndexedTagValue)(ptr) = AutotagSpecRulesConditionsIndexedTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsIndexedTagValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsIndexedTagValue)(ptr) = AutotagSpecRulesConditionsIndexedTagValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsIndexedTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsIndexedTagComparisonValueCodec struct {
}

func (AutotagSpecRulesConditionsIndexedTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsIndexedTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr)
	var objs []AutotagSpecRulesConditionsIndexedTagComparisonValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsIndexedTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsIndexedTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) = AutotagSpecRulesConditionsIndexedTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) = AutotagSpecRulesConditionsIndexedTagComparisonValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) = AutotagSpecRulesConditionsIndexedTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsIndexedTagComparisonValue)(ptr) = AutotagSpecRulesConditionsIndexedTagComparisonValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsIndexedTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsSimpleHostTechComparisonValueCodec struct {
}

func (AutotagSpecRulesConditionsSimpleHostTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsSimpleHostTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr)
	var objs []AutotagSpecRulesConditionsSimpleHostTechComparisonValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsSimpleHostTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsSimpleHostTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsSimpleHostTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleHostTechComparisonValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsSimpleHostTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsSimpleTechComparisonValueCodec struct {
}

func (AutotagSpecRulesConditionsSimpleTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsSimpleTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr)
	var objs []AutotagSpecRulesConditionsSimpleTechComparisonValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsSimpleTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsSimpleTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleTechComparisonValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsSimpleTechComparisonValue)(ptr) = AutotagSpecRulesConditionsSimpleTechComparisonValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsSimpleTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsTagValueCodec struct {
}

func (AutotagSpecRulesConditionsTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsTagValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsTagValue)(ptr)
	var objs []AutotagSpecRulesConditionsTagValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsTagValue)(ptr) = AutotagSpecRulesConditionsTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsTagValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsTagValue)(ptr) = AutotagSpecRulesConditionsTagValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsTagValue)(ptr) = AutotagSpecRulesConditionsTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsTagValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsTagValue)(ptr) = AutotagSpecRulesConditionsTagValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsTagComparisonValueCodec struct {
}

func (AutotagSpecRulesConditionsTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsTagComparisonValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsTagComparisonValue)(ptr)
	var objs []AutotagSpecRulesConditionsTagComparisonValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsTagComparisonValue)(ptr) = AutotagSpecRulesConditionsTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsTagComparisonValue)(ptr) = AutotagSpecRulesConditionsTagComparisonValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsTagComparisonValue)(ptr) = AutotagSpecRulesConditionsTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsTagComparisonValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsTagComparisonValue)(ptr) = AutotagSpecRulesConditionsTagComparisonValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutotagSpecRulesConditionsTechValueCodec struct {
}

func (AutotagSpecRulesConditionsTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutotagSpecRulesConditionsTechValue)(ptr) == nil
}

func (AutotagSpecRulesConditionsTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutotagSpecRulesConditionsTechValue)(ptr)
	var objs []AutotagSpecRulesConditionsTechValue
	if obj != nil {
		objs = []AutotagSpecRulesConditionsTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutotagSpecRulesConditionsTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutotagSpecRulesConditionsTechValue)(ptr) = AutotagSpecRulesConditionsTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutotagSpecRulesConditionsTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutotagSpecRulesConditionsTechValue)(ptr) = objs[0]
			} else {
				*(*AutotagSpecRulesConditionsTechValue)(ptr) = AutotagSpecRulesConditionsTechValue{}
			}
		} else {
			*(*AutotagSpecRulesConditionsTechValue)(ptr) = AutotagSpecRulesConditionsTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AutotagSpecRulesConditionsTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutotagSpecRulesConditionsTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AutotagSpecRulesConditionsTechValue)(ptr) = obj
		} else {
			*(*AutotagSpecRulesConditionsTechValue)(ptr) = AutotagSpecRulesConditionsTechValue{}
		}
	default:
		iter.ReportError("decode AutotagSpecRulesConditionsTechValue", "unexpected JSON type")
	}
}
