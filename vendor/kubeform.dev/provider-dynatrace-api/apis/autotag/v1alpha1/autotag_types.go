/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Autotag struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AutotagSpec   `json:"spec,omitempty"`
	Status            AutotagStatus `json:"status,omitempty"`
}

type AutotagSpecEntitySelectorBasedRule struct {
	// The rule is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// The entity selector string, by which the entities are selected
	// +optional
	Selector *string `json:"selector,omitempty" tf:"selector"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the entity-selector-based auto-tag. If specified, the tag is used in the `name:valueFormat` format.
	//
	// For example, you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`
	// +optional
	ValueFormat *string `json:"valueFormat,omitempty" tf:"value_format"`
}

type AutotagSpecMetadata struct {
	// Dynatrace server version
	// +optional
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version"`
	// A Sorted list of the version numbers of the configuration
	// +optional
	ConfigurationVersions []int64 `json:"configurationVersions,omitempty" tf:"configuration_versions"`
	// A Sorted list of the version numbers of the configuration
	// +optional
	CurrentConfigurationVersions []string `json:"currentConfigurationVersions,omitempty" tf:"current_configuration_versions"`
}

type AutotagSpecRulesConditionsApplicationType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsApplicationTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be APPLICATION_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsAzureComputeMode struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsAzureComputeModeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are DEDICATED or SHARED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsAzureSku struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsAzureSkuComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be AZURE_SKU
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BASIC, DYNAMIC, FREE, PREMIUM, SHARED and STANDARD.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsBaseComparisonBasic struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// The type of comparison
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsBaseConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// Defines the actual set of fields depending on the value
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsBitness struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are 32 and 64.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsBitnessComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be BITNESS
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are 32 and 64.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsCloudType struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsCloudTypeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be CLOUD_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AZURE, EC2, GOOGLE_CLOUD_PLATFORM, OPENSTACK, ORACLE and UNRECOGNIZED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// The type of comparison
	Type *string `json:"type" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomApplicationType struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsCustomApplicationTypeComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be CUSTOM_APPLICATION_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AMAZON_ECHO, DESKTOP, EMBEDDED, IOT, MICROSOFT_HOLOLENS and UFO.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsCustomHostMetadataDynamicKey struct {
	// The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomHostMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *AutotagSpecRulesConditionsCustomHostMetadataDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey struct {
	// The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are ENVIRONMENT, GOOGLE_COMPUTE_ENGINE and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomHostMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *AutotagSpecRulesConditionsCustomHostMetadataConditionKeyDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be HOST_CUSTOM_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey struct {
	//  The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomProcessMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *AutotagSpecRulesConditionsCustomProcessMetadataDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey struct {
	//  The actual key of the custom metadata
	Key *string `json:"key" tf:"key"`
	// The source of the custom metadata. Possible values are CLOUD_FOUNDRY, ENVIRONMENT, GOOGLE_CLOUD, KUBERNETES and PLUGIN
	Source *string `json:"source" tf:"source"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsCustomProcessMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key
	DynamicKey *AutotagSpecRulesConditionsCustomProcessMetadataConditionKeyDynamicKey `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be PROCESS_CUSTOM_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsDatabaseTopology struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsDatabaseTopologyComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be DATABASE_TOPOLOGY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLUSTER, EMBEDDED, FAILOVER, IPC, LOAD_BALANCING, SINGLE_SERVER and UNSPECIFIED.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsDcrumDecoder struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsDcrumDecoderComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be DCRUM_DECODER_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ALL_OTHER, CITRIX_APPFLOW, CITRIX_ICA, CITRIX_ICA_OVER_SSL, DB2_DRDA, HTTP, HTTPS, HTTP_EXPRESS, INFORMIX, MYSQL, ORACLE, SAP_GUI, SAP_GUI_OVER_HTTP, SAP_GUI_OVER_HTTPS, SAP_HANA_DB, SAP_RFC, SSL and TDS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsEntity struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsEntityIDComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Currently only EQUALS is supported. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be ENTITY_ID
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsHostTechValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type AutotagSpecRulesConditionsHostTech struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *AutotagSpecRulesConditionsHostTechValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsHypervisor struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsHypervisorTypeComparision struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be HYPERVISOR_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AHV, HYPER_V, KVM, LPAR, QEMU, VIRTUAL_BOX, VMWARE, WPAR and XEN.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedName struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedNameComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS, CONTAINS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_NAME
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedString struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedStringComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_STRING
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedTag struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *AutotagSpecRulesConditionsIndexedTagValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedTagComparisonValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIndexedTagComparison struct {
	// Reverses the operator. For example it turns EQUALS into DOES NOT EQUAL
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Either EQUALS or EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INDEXED_TAG
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *AutotagSpecRulesConditionsIndexedTagComparisonValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsInteger struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *int64 `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIntegerComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS, EXISTS, GREATER_THAN, GREATER_THAN_OR_EQUAL, LOWER_THAN and LOWER_THAN_OR_EQUAL. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be INTEGER
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *int64 `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIpaddress struct {
	//  The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsIpaddressComparison struct {
	//  The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS, IS_IP_IN_RANGE and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be IP_ADDRESS
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// Defines the actual set of fields depending on the value
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsMobilePlatform struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsMobilePlatformComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be MOBILE_PLATFORM
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ANDROID, IOS, LINUX, MAC_OS, OTHER, TVOS and WINDOWS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsOsArch struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsOsType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsOsarchitectureComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be OS_ARCHITECTURE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are ARM, IA64, PARISC, PPC, PPCLE, S390, SPARC, X86 and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsOstypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be OS_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AIX, DARWIN, HPUX, LINUX, SOLARIS, WINDOWS and ZOS.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsPaasType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsPaasTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be PAAS_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are AWS_ECS_EC2, AWS_ECS_FARGATE, AWS_LAMBDA, AZURE_FUNCTIONS, AZURE_WEBSITES, CLOUD_FOUNDRY, GOOGLE_APP_ENGINE, HEROKU, KUBERNETES and OPENSHIFT.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsProcessMetadata struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsProcessMetadataConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are AMAZON_ECR_IMAGE_ACCOUNT_ID,AMAZON_ECR_IMAGE_REGION, AMAZON_LAMBDA_FUNCTION_NAME, AMAZON_REGION, APACHE_CONFIG_PATH, APACHE_SPARK_MASTER_IP_ADDRESS, ASP_DOT_NET_CORE_APPLICATION_PATH, AWS_ECS_CLUSTER, AWS_ECS_CONTAINERNAME, AWS_ECS_FAMILY, AWS_ECS_REVISION, CASSANDRA_CLUSTER_NAME, CATALINA_BASE, CATALINA_HOME, CLOUD_FOUNDRY_APP_ID, CLOUD_FOUNDRY_APP_NAME, CLOUD_FOUNDRY_INSTANCE_INDEX, CLOUD_FOUNDRY_SPACE_ID, CLOUD_FOUNDRY_SPACE_NAME, COLDFUSION_JVM_CONFIG_FILE, COLDFUSION_SERVICE_NAME, COMMAND_LINE_ARGS, DOTNET_COMMAND, DOTNET_COMMAND_PATH, DYNATRACE_CLUSTER_ID, DYNATRACE_NODE_ID, ELASTICSEARCH_CLUSTER_NAME, ELASTICSEARCH_NODE_NAME, EQUINOX_CONFIG_PATH, EXE_NAME, EXE_PATH, GLASS_FISH_DOMAIN_NAME, GLASS_FISH_INSTANCE_NAME, GOOGLE_APP_ENGINE_INSTANCE, GOOGLE_APP_ENGINE_SERVICE, GOOGLE_CLOUD_PROJECT, HYBRIS_BIN_DIRECTORY, HYBRIS_CONFIG_DIRECTORY, HYBRIS_DATA_DIRECTORY, IBM_CICS_REGION, IBM_CTG_NAME, IBM_IMS_CONNECT_REGION, IBM_IMS_CONTROL_REGION, IBM_IMS_MESSAGE_PROCESSING_REGION, IBM_IMS_SOAP_GW_NAME, IBM_INTEGRATION_NODE_NAME, IBM_INTEGRATION_SERVER_NAME, IIS_APP_POOL, IIS_ROLE_NAME, JAVA_JAR_FILE, JAVA_JAR_PATH, JAVA_MAIN_CLASS, JAVA_MAIN_MODULE, JBOSS_HOME, JBOSS_MODE, JBOSS_SERVER_NAME, KUBERNETES_BASE_POD_NAME, KUBERNETES_CONTAINER_NAME, KUBERNETES_FULL_POD_NAME, KUBERNETES_NAMESPACE, KUBERNETES_POD_UID, MSSQL_INSTANCE_NAME, NODE_JS_APP_BASE_DIRECTORY, NODE_JS_APP_NAME, NODE_JS_SCRIPT_NAME, ORACLE_SID, PG_ID_CALC_INPUT_KEY_LINKAGE, PHP_SCRIPT_PATH, PHP_WORKING_DIRECTORY, RUBY_APP_ROOT_PATH, RUBY_SCRIPT_PATH, RULE_RESULT, SOFTWAREAG_INSTALL_ROOT, SOFTWAREAG_PRODUCTPROPNAME, SPRINGBOOT_APP_NAME, SPRINGBOOT_PROFILE_NAME, SPRINGBOOT_STARTUP_CLASS, TIBCO_BUSINESSWORKS_CE_APP_NAME, TIBCO_BUSINESSWORKS_CE_VERSION, TIBCO_BUSINESS_WORKS_APP_NODE_NAME, TIBCO_BUSINESS_WORKS_APP_SPACE_NAME, TIBCO_BUSINESS_WORKS_DOMAIN_NAME, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE, TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH, TIBCO_BUSINESS_WORKS_HOME, VARNISH_INSTANCE_NAME, WEB_LOGIC_CLUSTER_NAME, WEB_LOGIC_DOMAIN_NAME, WEB_LOGIC_HOME, WEB_LOGIC_NAME, WEB_SPHERE_CELL_NAME, WEB_SPHERE_CLUSTER_NAME, WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be PROCESS_PREDEFINED_METADATA_KEY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsServiceTopology struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsServiceTopologyComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SERVICE_TOPOLOGY
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are EXTERNAL_SERVICE, FULLY_MONITORED and OPAQUE_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsServiceType struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsServiceTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SERVICE_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are BACKGROUND_ACTIVITY, CICS_SERVICE, CUSTOM_SERVICE, DATABASE_SERVICE, ENTERPRISE_SERVICE_BUS_SERVICE, EXTERNAL, IBM_INTEGRATION_BUS_SERVICE, IMS_SERVICE, MESSAGING_SERVICE, QUEUE_LISTENER_SERVICE, RMI_SERVICE, RPC_SERVICE, WEB_REQUEST_SERVICE and WEB_SERVICE.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsSimpleHostTechComparisonValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set. Possible values are APPARMOR, BOSH, BOSHBPM, CLOUDFOUNDRY, CONTAINERD, CRIO, DIEGO_CELL, DOCKER, GARDEN, GRSECURITY, KUBERNETES, OPENSHIFT, OPENSTACK_COMPUTE, OPENSTACK_CONTROLLER and SELINUX
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type AutotagSpecRulesConditionsSimpleHostTechComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SIMPLE_HOST_TECH
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *AutotagSpecRulesConditionsSimpleHostTechComparisonValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsSimpleTechComparisonValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type AutotagSpecRulesConditionsSimpleTechComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SIMPLE_TECH
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *AutotagSpecRulesConditionsSimpleTechComparisonValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsString struct {
	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsStringComparison struct {
	// The comparison is case-sensitive (`true`) or insensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are BEGINS_WITH, CONTAINS, ENDS_WITH, EQUALS, EXISTS and REGEX_MATCHES. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be STRING
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsStringConditionKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	//    - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	//    - `AMAZON_ECR_IMAGE_REGION`
	//    - `AMAZON_LAMBDA_FUNCTION_NAME`
	//    - `AMAZON_REGION`
	//    - `APACHE_CONFIG_PATH`
	//    - `APACHE_SPARK_MASTER_IP_ADDRESS`
	//    - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	//    - `AWS_ECS_CLUSTER`
	//    - `AWS_ECS_CONTAINERNAME`
	//    - `AWS_ECS_FAMILY`
	//    - `AWS_ECS_REVISION`
	//    - `CASSANDRA_CLUSTER_NAME`
	//    - `CATALINA_BASE`
	//    - `CATALINA_HOME`
	//    - `CLOUD_FOUNDRY_APP_ID`
	//    - `CLOUD_FOUNDRY_APP_NAME`
	//    - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	//    - `CLOUD_FOUNDRY_SPACE_ID`
	//    - `CLOUD_FOUNDRY_SPACE_NAME`
	//    - `COLDFUSION_JVM_CONFIG_FILE`
	//    - `COLDFUSION_SERVICE_NAME`
	//    - `COMMAND_LINE_ARGS`
	//    - `DOTNET_COMMAND`
	//    - `DOTNET_COMMAND_PATH`
	//    - `DYNATRACE_CLUSTER_ID`
	//    - `DYNATRACE_NODE_ID`
	//    - `ELASTICSEARCH_CLUSTER_NAME`
	//    - `ELASTICSEARCH_NODE_NAME`
	//    - `EQUINOX_CONFIG_PATH`
	//    - `EXE_NAME`
	//    - `EXE_PATH`
	//    - `GLASS_FISH_DOMAIN_NAME`
	//    - `GLASS_FISH_INSTANCE_NAME`
	//    - `GOOGLE_APP_ENGINE_INSTANCE`
	//    - `GOOGLE_APP_ENGINE_SERVICE`
	//    - `GOOGLE_CLOUD_PROJECT`
	//    - `HYBRIS_BIN_DIRECTORY`
	//    - `HYBRIS_CONFIG_DIRECTORY`
	//    - `HYBRIS_DATA_DIRECTORY`
	//    - `IBM_CICS_REGION`
	//    - `IBM_CTG_NAME`
	//    - `IBM_IMS_CONNECT_REGION`
	//    - `IBM_IMS_CONTROL_REGION`
	//    - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	//    - `IBM_IMS_SOAP_GW_NAME`
	//    - `IBM_INTEGRATION_NODE_NAME`
	//    - `IBM_INTEGRATION_SERVER_NAME`
	//    - `IIS_APP_POOL`
	//    - `IIS_ROLE_NAME`
	//    - `JAVA_JAR_FILE`
	//    - `JAVA_JAR_PATH`
	//    - `JAVA_MAIN_CLASS`
	//    - `JAVA_MAIN_MODULE`
	//    - `JBOSS_HOME`
	//    - `JBOSS_MODE`
	//    - `JBOSS_SERVER_NAME`
	//    - `KUBERNETES_BASE_POD_NAME`
	//    - `KUBERNETES_CONTAINER_NAME`
	//    - `KUBERNETES_FULL_POD_NAME`
	//    - `KUBERNETES_NAMESPACE`
	//    - `KUBERNETES_POD_UID`
	//    - `MSSQL_INSTANCE_NAME`
	//    - `NODE_JS_APP_BASE_DIRECTORY`
	//    - `NODE_JS_APP_NAME`
	//    - `NODE_JS_SCRIPT_NAME`
	//    - `ORACLE_SID`
	//    - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	//    - `PHP_SCRIPT_PATH`
	//    - `PHP_WORKING_DIRECTORY`
	//    - `RUBY_APP_ROOT_PATH`
	//    - `RUBY_SCRIPT_PATH`
	//    - `RULE_RESULT`
	//    - `SOFTWAREAG_INSTALL_ROOT`
	//    - `SOFTWAREAG_PRODUCTPROPNAME`
	//    - `SPRINGBOOT_APP_NAME`
	//    - `SPRINGBOOT_PROFILE_NAME`
	//    - `SPRINGBOOT_STARTUP_CLASS`
	//    - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	//    - `TIBCO_BUSINESSWORKS_CE_VERSION`
	//    - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	//    - `TIBCO_BUSINESS_WORKS_HOME`
	//    - `VARNISH_INSTANCE_NAME`
	//    - `WEB_LOGIC_CLUSTER_NAME`
	//    - `WEB_LOGIC_DOMAIN_NAME`
	//    - `WEB_LOGIC_HOME`
	//    - `WEB_LOGIC_NAME`
	//    - `WEB_SPHERE_CELL_NAME`
	//    - `WEB_SPHERE_CLUSTER_NAME`
	//    - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// if specified, needs to be `STRING`
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsStringKey struct {
	// The attribute to be used for comparision
	Attribute *string `json:"attribute" tf:"attribute"`
	// The key of the attribute, which need dynamic keys. Not applicable otherwise, as the attibute itself acts as a key. Possible values are
	//    - `AMAZON_ECR_IMAGE_ACCOUNT_ID`
	//    - `AMAZON_ECR_IMAGE_REGION`
	//    - `AMAZON_LAMBDA_FUNCTION_NAME`
	//    - `AMAZON_REGION`
	//    - `APACHE_CONFIG_PATH`
	//    - `APACHE_SPARK_MASTER_IP_ADDRESS`
	//    - `ASP_DOT_NET_CORE_APPLICATION_PATH`
	//    - `AWS_ECS_CLUSTER`
	//    - `AWS_ECS_CONTAINERNAME`
	//    - `AWS_ECS_FAMILY`
	//    - `AWS_ECS_REVISION`
	//    - `CASSANDRA_CLUSTER_NAME`
	//    - `CATALINA_BASE`
	//    - `CATALINA_HOME`
	//    - `CLOUD_FOUNDRY_APP_ID`
	//    - `CLOUD_FOUNDRY_APP_NAME`
	//    - `CLOUD_FOUNDRY_INSTANCE_INDEX`
	//    - `CLOUD_FOUNDRY_SPACE_ID`
	//    - `CLOUD_FOUNDRY_SPACE_NAME`
	//    - `COLDFUSION_JVM_CONFIG_FILE`
	//    - `COLDFUSION_SERVICE_NAME`
	//    - `COMMAND_LINE_ARGS`
	//    - `DOTNET_COMMAND`
	//    - `DOTNET_COMMAND_PATH`
	//    - `DYNATRACE_CLUSTER_ID`
	//    - `DYNATRACE_NODE_ID`
	//    - `ELASTICSEARCH_CLUSTER_NAME`
	//    - `ELASTICSEARCH_NODE_NAME`
	//    - `EQUINOX_CONFIG_PATH`
	//    - `EXE_NAME`
	//    - `EXE_PATH`
	//    - `GLASS_FISH_DOMAIN_NAME`
	//    - `GLASS_FISH_INSTANCE_NAME`
	//    - `GOOGLE_APP_ENGINE_INSTANCE`
	//    - `GOOGLE_APP_ENGINE_SERVICE`
	//    - `GOOGLE_CLOUD_PROJECT`
	//    - `HYBRIS_BIN_DIRECTORY`
	//    - `HYBRIS_CONFIG_DIRECTORY`
	//    - `HYBRIS_DATA_DIRECTORY`
	//    - `IBM_CICS_REGION`
	//    - `IBM_CTG_NAME`
	//    - `IBM_IMS_CONNECT_REGION`
	//    - `IBM_IMS_CONTROL_REGION`
	//    - `IBM_IMS_MESSAGE_PROCESSING_REGION`
	//    - `IBM_IMS_SOAP_GW_NAME`
	//    - `IBM_INTEGRATION_NODE_NAME`
	//    - `IBM_INTEGRATION_SERVER_NAME`
	//    - `IIS_APP_POOL`
	//    - `IIS_ROLE_NAME`
	//    - `JAVA_JAR_FILE`
	//    - `JAVA_JAR_PATH`
	//    - `JAVA_MAIN_CLASS`
	//    - `JAVA_MAIN_MODULE`
	//    - `JBOSS_HOME`
	//    - `JBOSS_MODE`
	//    - `JBOSS_SERVER_NAME`
	//    - `KUBERNETES_BASE_POD_NAME`
	//    - `KUBERNETES_CONTAINER_NAME`
	//    - `KUBERNETES_FULL_POD_NAME`
	//    - `KUBERNETES_NAMESPACE`
	//    - `KUBERNETES_POD_UID`
	//    - `MSSQL_INSTANCE_NAME`
	//    - `NODE_JS_APP_BASE_DIRECTORY`
	//    - `NODE_JS_APP_NAME`
	//    - `NODE_JS_SCRIPT_NAME`
	//    - `ORACLE_SID`
	//    - `PG_ID_CALC_INPUT_KEY_LINKAGE`
	//    - `PHP_SCRIPT_PATH`
	//    - `PHP_WORKING_DIRECTORY`
	//    - `RUBY_APP_ROOT_PATH`
	//    - `RUBY_SCRIPT_PATH`
	//    - `RULE_RESULT`
	//    - `SOFTWAREAG_INSTALL_ROOT`
	//    - `SOFTWAREAG_PRODUCTPROPNAME`
	//    - `SPRINGBOOT_APP_NAME`
	//    - `SPRINGBOOT_PROFILE_NAME`
	//    - `SPRINGBOOT_STARTUP_CLASS`
	//    - `TIBCO_BUSINESSWORKS_CE_APP_NAME`
	//    - `TIBCO_BUSINESSWORKS_CE_VERSION`
	//    - `TIBCO_BUSINESS_WORKS_APP_NODE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_APP_SPACE_NAME`
	//    - `TIBCO_BUSINESS_WORKS_DOMAIN_NAME`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE`
	//    - `TIBCO_BUSINESS_WORKS_ENGINE_PROPERTY_FILE_PATH`
	//    - `TIBCO_BUSINESS_WORKS_HOME`
	//    - `VARNISH_INSTANCE_NAME`
	//    - `WEB_LOGIC_CLUSTER_NAME`
	//    - `WEB_LOGIC_DOMAIN_NAME`
	//    - `WEB_LOGIC_HOME`
	//    - `WEB_LOGIC_NAME`
	//    - `WEB_SPHERE_CELL_NAME`
	//    - `WEB_SPHERE_CLUSTER_NAME`
	//    - `WEB_SPHERE_NODE_NAME and WEB_SPHERE_SERVER_NAME`
	DynamicKey *string `json:"dynamicKey" tf:"dynamic_key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRulesConditionsSyntheticEngine struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsSyntheticEngineTypeComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are  EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be SYNTHETIC_ENGINE_TYPE
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are CLASSIC and CUSTOM
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsTag struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *AutotagSpecRulesConditionsTagValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsTagComparisonValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Possible values are AWS, AWS_GENERIC, AZURE, CLOUD_FOUNDRY, CONTEXTLESS, ENVIRONMENT, GOOGLE_CLOUD and KUBERNETES. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// Any attributes that aren't yet supported by this provider but have meanwhile gotten introduced by a newer version of the Dynatrace REST API
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsTagComparison struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and TAG_KEY_EQUALS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// if specified, needs to be TAG
	// +optional
	// Deprecated
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Tag of a Dynatrace entity
	// +optional
	Value *AutotagSpecRulesConditionsTagComparisonValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditionsTechValue struct {
	// Predefined technology, if technology is not predefined, then the verbatim type must be set.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Non-predefined technology, use for custom technologies
	// +optional
	VerbatimType *string `json:"verbatimType,omitempty" tf:"verbatim_type"`
}

type AutotagSpecRulesConditionsTech struct {
	// Reverses the operator. For example it turns the **begins with** into **does not begin with**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator of the comparison. Possible values are EQUALS and EXISTS. You can reverse it by setting **negate** to `true`
	Operator *string `json:"operator" tf:"operator"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *AutotagSpecRulesConditionsTechValue `json:"value,omitempty" tf:"value"`
}

type AutotagSpecRulesConditions struct {
	// Comparison for `APPLICATION_TYPE` attributes
	// +optional
	ApplicationType []AutotagSpecRulesConditionsApplicationType `json:"applicationType,omitempty" tf:"application_type"`
	// Comparison for `APPLICATION_TYPE` attributes
	// +optional
	// Deprecated
	ApplicationTypeComparison []AutotagSpecRulesConditionsApplicationTypeComparison `json:"applicationTypeComparison,omitempty" tf:"application_type_comparison"`
	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +optional
	// Deprecated
	AzureComputeMode []AutotagSpecRulesConditionsAzureComputeMode `json:"azureComputeMode,omitempty" tf:"azure_compute_mode"`
	// Comparison for `AZURE_COMPUTE_MODE` attributes
	// +optional
	AzureComputeModeComparison []AutotagSpecRulesConditionsAzureComputeModeComparison `json:"azureComputeModeComparison,omitempty" tf:"azure_compute_mode_comparison"`
	// Comparison for `AZURE_SKU` attributes
	// +optional
	AzureSku []AutotagSpecRulesConditionsAzureSku `json:"azureSku,omitempty" tf:"azure_sku"`
	// Comparison for `AZURE_SKU` attributes
	// +optional
	// Deprecated
	AzureSkuComparision []AutotagSpecRulesConditionsAzureSkuComparision `json:"azureSkuComparision,omitempty" tf:"azure_sku_comparision"`
	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +optional
	// Deprecated
	BaseComparisonBasic []AutotagSpecRulesConditionsBaseComparisonBasic `json:"baseComparisonBasic,omitempty" tf:"base_comparison_basic"`
	// Fallback for not yet known type
	// +optional
	// Deprecated
	BaseConditionKey []AutotagSpecRulesConditionsBaseConditionKey `json:"baseConditionKey,omitempty" tf:"base_condition_key"`
	// Comparison for `BITNESS` attributes
	// +optional
	Bitness []AutotagSpecRulesConditionsBitness `json:"bitness,omitempty" tf:"bitness"`
	// Comparison for `BITNESS` attributes
	// +optional
	// Deprecated
	BitnessComparision []AutotagSpecRulesConditionsBitnessComparision `json:"bitnessComparision,omitempty" tf:"bitness_comparision"`
	// Comparison for `CLOUD_TYPE` attributes
	// +optional
	CloudType []AutotagSpecRulesConditionsCloudType `json:"cloudType,omitempty" tf:"cloud_type"`
	// Comparison for `CLOUD_TYPE` attributes
	// +optional
	// Deprecated
	CloudTypeComparison []AutotagSpecRulesConditionsCloudTypeComparison `json:"cloudTypeComparison,omitempty" tf:"cloud_type_comparison"`
	// A comparison that's yet unknown to the provider. Operator and Value need to be encoded using the 'unknowns' property.
	// +optional
	Comparison []AutotagSpecRulesConditionsComparison `json:"comparison,omitempty" tf:"comparison"`
	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +optional
	CustomApplicationType []AutotagSpecRulesConditionsCustomApplicationType `json:"customApplicationType,omitempty" tf:"custom_application_type"`
	// Comparison for `CUSTOM_APPLICATION_TYPE` attributes
	// +optional
	// Deprecated
	CustomApplicationTypeComparison []AutotagSpecRulesConditionsCustomApplicationTypeComparison `json:"customApplicationTypeComparison,omitempty" tf:"custom_application_type_comparison"`
	// Key for Custom Host Metadata
	// +optional
	CustomHostMetadata []AutotagSpecRulesConditionsCustomHostMetadata `json:"customHostMetadata,omitempty" tf:"custom_host_metadata"`
	// Key for Custom Host Metadata
	// +optional
	// Deprecated
	CustomHostMetadataConditionKey []AutotagSpecRulesConditionsCustomHostMetadataConditionKey `json:"customHostMetadataConditionKey,omitempty" tf:"custom_host_metadata_condition_key"`
	// Key for Custom Process Metadata
	// +optional
	CustomProcessMetadata []AutotagSpecRulesConditionsCustomProcessMetadata `json:"customProcessMetadata,omitempty" tf:"custom_process_metadata"`
	// Key for Custom Process Metadata
	// +optional
	// Deprecated
	CustomProcessMetadataConditionKey []AutotagSpecRulesConditionsCustomProcessMetadataConditionKey `json:"customProcessMetadataConditionKey,omitempty" tf:"custom_process_metadata_condition_key"`
	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +optional
	DatabaseTopology []AutotagSpecRulesConditionsDatabaseTopology `json:"databaseTopology,omitempty" tf:"database_topology"`
	// Comparison for `DATABASE_TOPOLOGY` attributes
	// +optional
	// Deprecated
	DatabaseTopologyComparison []AutotagSpecRulesConditionsDatabaseTopologyComparison `json:"databaseTopologyComparison,omitempty" tf:"database_topology_comparison"`
	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +optional
	DcrumDecoder []AutotagSpecRulesConditionsDcrumDecoder `json:"dcrumDecoder,omitempty" tf:"dcrum_decoder"`
	// Comparison for `DCRUM_DECODER_TYPE` attributes
	// +optional
	// Deprecated
	DcrumDecoderComparison []AutotagSpecRulesConditionsDcrumDecoderComparison `json:"dcrumDecoderComparison,omitempty" tf:"dcrum_decoder_comparison"`
	// Comparison for `ENTITY_ID` attributes
	// +optional
	Entity []AutotagSpecRulesConditionsEntity `json:"entity,omitempty" tf:"entity"`
	// Comparison for `ENTITY_ID` attributes
	// +optional
	// Deprecated
	EntityIDComparison []AutotagSpecRulesConditionsEntityIDComparison `json:"entityIDComparison,omitempty" tf:"entity_id_comparison"`
	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +optional
	HostTech []AutotagSpecRulesConditionsHostTech `json:"hostTech,omitempty" tf:"host_tech"`
	// Comparison for `HYPERVISOR_TYPE` attributes
	// +optional
	Hypervisor []AutotagSpecRulesConditionsHypervisor `json:"hypervisor,omitempty" tf:"hypervisor"`
	// `hypervisor_type_comparision` is deprecated. Use `hypervisor` instead
	// +optional
	// Deprecated
	HypervisorTypeComparision []AutotagSpecRulesConditionsHypervisorTypeComparision `json:"hypervisorTypeComparision,omitempty" tf:"hypervisor_type_comparision"`
	// Comparison for `INDEXED_NAME` attributes
	// +optional
	IndexedName []AutotagSpecRulesConditionsIndexedName `json:"indexedName,omitempty" tf:"indexed_name"`
	// Comparison for `INDEXED_NAME` attributes
	// +optional
	// Deprecated
	IndexedNameComparison []AutotagSpecRulesConditionsIndexedNameComparison `json:"indexedNameComparison,omitempty" tf:"indexed_name_comparison"`
	// Comparison for `INDEXED_STRING` attributes
	// +optional
	IndexedString []AutotagSpecRulesConditionsIndexedString `json:"indexedString,omitempty" tf:"indexed_string"`
	// Comparison for `INDEXED_STRING` attributes
	// +optional
	// Deprecated
	IndexedStringComparison []AutotagSpecRulesConditionsIndexedStringComparison `json:"indexedStringComparison,omitempty" tf:"indexed_string_comparison"`
	// Comparison for `INDEXED_TAG` attributes
	// +optional
	IndexedTag []AutotagSpecRulesConditionsIndexedTag `json:"indexedTag,omitempty" tf:"indexed_tag"`
	// Comparison for `INDEXED_TAG` attributes
	// +optional
	// Deprecated
	IndexedTagComparison []AutotagSpecRulesConditionsIndexedTagComparison `json:"indexedTagComparison,omitempty" tf:"indexed_tag_comparison"`
	// Comparison for `INTEGER` attributes
	// +optional
	Integer []AutotagSpecRulesConditionsInteger `json:"integer,omitempty" tf:"integer"`
	// Comparison for `INTEGER` attributes
	// +optional
	// Deprecated
	IntegerComparison []AutotagSpecRulesConditionsIntegerComparison `json:"integerComparison,omitempty" tf:"integer_comparison"`
	// Comparison for `IP_ADDRESS` attributes
	// +optional
	Ipaddress []AutotagSpecRulesConditionsIpaddress `json:"ipaddress,omitempty" tf:"ipaddress"`
	// Comparison for `IP_ADDRESS` attributes
	// +optional
	// Deprecated
	IpaddressComparison []AutotagSpecRulesConditionsIpaddressComparison `json:"ipaddressComparison,omitempty" tf:"ipaddress_comparison"`
	// Fallback for not yet known type
	// +optional
	Key []AutotagSpecRulesConditionsKey `json:"key,omitempty" tf:"key"`
	// Comparison for `MOBILE_PLATFORM` attributes
	// +optional
	MobilePlatform []AutotagSpecRulesConditionsMobilePlatform `json:"mobilePlatform,omitempty" tf:"mobile_platform"`
	// Comparison for `MOBILE_PLATFORM` attributes
	// +optional
	// Deprecated
	MobilePlatformComparison []AutotagSpecRulesConditionsMobilePlatformComparison `json:"mobilePlatformComparison,omitempty" tf:"mobile_platform_comparison"`
	// Comparison for `OS_ARCHITECTURE` attributes
	// +optional
	OsArch []AutotagSpecRulesConditionsOsArch `json:"osArch,omitempty" tf:"os_arch"`
	// Comparison for `OS_TYPE` attributes
	// +optional
	OsType []AutotagSpecRulesConditionsOsType `json:"osType,omitempty" tf:"os_type"`
	// Comparison for `OS_ARCHITECTURE` attributes
	// +optional
	// Deprecated
	OsarchitectureComparison []AutotagSpecRulesConditionsOsarchitectureComparison `json:"osarchitectureComparison,omitempty" tf:"osarchitecture_comparison"`
	// Comparison for `OS_TYPE` attributes
	// +optional
	// Deprecated
	OstypeComparison []AutotagSpecRulesConditionsOstypeComparison `json:"ostypeComparison,omitempty" tf:"ostype_comparison"`
	// Comparison for `PAAS_TYPE` attributes
	// +optional
	PaasType []AutotagSpecRulesConditionsPaasType `json:"paasType,omitempty" tf:"paas_type"`
	// Comparison for `PAAS_TYPE` attributes
	// +optional
	// Deprecated
	PaasTypeComparison []AutotagSpecRulesConditionsPaasTypeComparison `json:"paasTypeComparison,omitempty" tf:"paas_type_comparison"`
	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +optional
	ProcessMetadata []AutotagSpecRulesConditionsProcessMetadata `json:"processMetadata,omitempty" tf:"process_metadata"`
	// The key for dynamic attributes of the `PROCESS_PREDEFINED_METADATA_KEY` type
	// +optional
	// Deprecated
	ProcessMetadataConditionKey []AutotagSpecRulesConditionsProcessMetadataConditionKey `json:"processMetadataConditionKey,omitempty" tf:"process_metadata_condition_key"`
	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +optional
	ServiceTopology []AutotagSpecRulesConditionsServiceTopology `json:"serviceTopology,omitempty" tf:"service_topology"`
	// Comparison for `SERVICE_TOPOLOGY` attributes
	// +optional
	// Deprecated
	ServiceTopologyComparison []AutotagSpecRulesConditionsServiceTopologyComparison `json:"serviceTopologyComparison,omitempty" tf:"service_topology_comparison"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	ServiceType []AutotagSpecRulesConditionsServiceType `json:"serviceType,omitempty" tf:"service_type"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	// Deprecated
	ServiceTypeComparison []AutotagSpecRulesConditionsServiceTypeComparison `json:"serviceTypeComparison,omitempty" tf:"service_type_comparison"`
	// Comparison for `SIMPLE_HOST_TECH` attributes
	// +optional
	// Deprecated
	SimpleHostTechComparison []AutotagSpecRulesConditionsSimpleHostTechComparison `json:"simpleHostTechComparison,omitempty" tf:"simple_host_tech_comparison"`
	// Comparison for `SIMPLE_TECH` attributes
	// +optional
	// Deprecated
	SimpleTechComparison []AutotagSpecRulesConditionsSimpleTechComparison `json:"simpleTechComparison,omitempty" tf:"simple_tech_comparison"`
	// Comparison for `STRING` attributes
	// +optional
	String []AutotagSpecRulesConditionsString `json:"string,omitempty" tf:"string"`
	// Comparison for `STRING` attributes
	// +optional
	// Deprecated
	StringComparison []AutotagSpecRulesConditionsStringComparison `json:"stringComparison,omitempty" tf:"string_comparison"`
	//  The key for dynamic attributes of the `STRING` type
	// +optional
	// Deprecated
	StringConditionKey []AutotagSpecRulesConditionsStringConditionKey `json:"stringConditionKey,omitempty" tf:"string_condition_key"`
	//  The key for dynamic attributes of the `STRING` type
	// +optional
	StringKey []AutotagSpecRulesConditionsStringKey `json:"stringKey,omitempty" tf:"string_key"`
	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +optional
	SyntheticEngine []AutotagSpecRulesConditionsSyntheticEngine `json:"syntheticEngine,omitempty" tf:"synthetic_engine"`
	// Comparison for `SYNTHETIC_ENGINE_TYPE` attributes
	// +optional
	// Deprecated
	SyntheticEngineTypeComparison []AutotagSpecRulesConditionsSyntheticEngineTypeComparison `json:"syntheticEngineTypeComparison,omitempty" tf:"synthetic_engine_type_comparison"`
	// Comparison for `TAG` attributes
	// +optional
	Tag []AutotagSpecRulesConditionsTag `json:"tag,omitempty" tf:"tag"`
	// Comparison for `TAG` attributes
	// +optional
	// Deprecated
	TagComparison []AutotagSpecRulesConditionsTagComparison `json:"tagComparison,omitempty" tf:"tag_comparison"`
	// Comparison for `SIMPLE_TECH` attributes
	// +optional
	Tech []AutotagSpecRulesConditionsTech `json:"tech,omitempty" tf:"tech"`
	// Any attributes that aren't yet supported by this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagSpecRules struct {
	// A list of matching rules for the management zone. The management zone applies only if **all** conditions are fulfilled
	// +optional
	// +kubebuilder:validation:MinItems=1
	Conditions []AutotagSpecRulesConditions `json:"conditions,omitempty" tf:"conditions"`
	// The rule is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// How to apply the management zone to underlying entities:
	//    - `SERVICE_TO_HOST_LIKE`: Apply to underlying hosts of matching services
	//    - `SERVICE_TO_PROCESS_GROUP_LIKE`: Apply to underlying process groups of matching services
	//    - `PROCESS_GROUP_TO_HOST`: Apply to underlying hosts of matching process groups
	//    - `PROCESS_GROUP_TO_SERVICE`: Apply to all services provided by matching process groups
	//    - `HOST_TO_PROCESS_GROUP_INSTANCE`: Apply to processes running on matching hosts
	//    - `CUSTOM_DEVICE_GROUP_TO_CUSTOM_DEVICE`: Apply to custom devices in matching custom device groups
	//    - `AZURE_TO_PG`: Apply to process groups connected to matching Azure entities
	//    - `AZURE_TO_SERVICE`: Apply to services provided by matching Azure entities
	// +optional
	PropagationTypes []string `json:"propagationTypes,omitempty" tf:"propagation_types"`
	// The type of Dynatrace entities the management zone can be applied to
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the auto-tag. If specified, the tag is used in the `name:valueFormat` format.  For example, you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`.  You can use the following placeholders here:  * `{AwsAutoScalingGroup:Name}`  * `{AwsAvailabilityZone:Name}`  * `{AwsElasticLoadBalancer:Name}`  * `{AwsRelationalDatabaseService:DBName}`  * `{AwsRelationalDatabaseService:Endpoint}`  * `{AwsRelationalDatabaseService:Engine}`  * `{AwsRelationalDatabaseService:InstanceClass}`  * `{AwsRelationalDatabaseService:Name}`  * `{AwsRelationalDatabaseService:Port}`  * `{AzureRegion:Name}`  * `{AzureScaleSet:Name}`  * `{AzureVm:Name}`  * `{CloudFoundryOrganization:Name}`  * `{CustomDevice:DetectedName}`  * `{CustomDevice:DnsName}`  * `{CustomDevice:IpAddress}`  * `{CustomDevice:Port}`  * `{DockerContainerGroupInstance:ContainerName}`  * `{DockerContainerGroupInstance:FullImageName}`  * `{DockerContainerGroupInstance:ImageVersion}`  * `{DockerContainerGroupInstance:StrippedImageName}`  * `{ESXIHost:HardwareModel}`  * `{ESXIHost:HardwareVendor}`  * `{ESXIHost:Name}`  * `{ESXIHost:ProductName}`  * `{ESXIHost:ProductVersion}`  * `{Ec2Instance:AmiId}`  * `{Ec2Instance:BeanstalkEnvironmentName}`  * `{Ec2Instance:InstanceId}`  * `{Ec2Instance:InstanceType}`  * `{Ec2Instance:LocalHostName}`  * `{Ec2Instance:Name}`  * `{Ec2Instance:PublicHostName}`  * `{Ec2Instance:SecurityGroup}`  * `{GoogleComputeInstance:Id}`  * `{GoogleComputeInstance:IpAddresses}`  * `{GoogleComputeInstance:MachineType}`  * `{GoogleComputeInstance:Name}`  * `{GoogleComputeInstance:ProjectId}`  * `{GoogleComputeInstance:Project}`  * `{Host:AWSNameTag}`  * `{Host:AixLogicalCpuCount}`  * `{Host:AzureHostName}`  * `{Host:AzureSiteName}`  * `{Host:BoshDeploymentId}`  * `{Host:BoshInstanceId}`  * `{Host:BoshInstanceName}`  * `{Host:BoshName}`  * `{Host:BoshStemcellVersion}`  * `{Host:CpuCores}`  * `{Host:DetectedName}`  * `{Host:Environment:AppName}`  * `{Host:Environment:BoshReleaseVersion}`  * `{Host:Environment:Environment}`  * `{Host:Environment:Link}`  * `{Host:Environment:Organization}`  * `{Host:Environment:Owner}`  * `{Host:Environment:Support}`  * `{Host:IpAddress}`  * `{Host:LogicalCpuCores}`  * `{Host:OneAgentCustomHostName}`  * `{Host:OperatingSystemVersion}`  * `{Host:PaasMemoryLimit}`  * `{HostGroup:Name}`  * `{KubernetesCluster:Name}`  * `{KubernetesNode:DetectedName}`  * `{OpenstackAvailabilityZone:Name}`  * `{OpenstackZone:Name}`  * `{OpenstackComputeNode:Name}`  * `{OpenstackProject:Name}`  * `{OpenstackVm:UnstanceType}`  * `{OpenstackVm:Name}`  * `{OpenstackVm:SecurityGroup}`  * `{ProcessGroup:AmazonECRImageAccountId}`  * `{ProcessGroup:AmazonECRImageRegion}`  * `{ProcessGroup:AmazonECSCluster}`  * `{ProcessGroup:AmazonECSContainerName}`  * `{ProcessGroup:AmazonECSFamily}`  * `{ProcessGroup:AmazonECSRevision}`  * `{ProcessGroup:AmazonLambdaFunctionName}`  * `{ProcessGroup:AmazonRegion}`  * `{ProcessGroup:ApacheConfigPath}`  * `{ProcessGroup:ApacheSparkMasterIpAddress}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AspDotNetCoreApplicationPath}`  * `{ProcessGroup:AzureHostName}`  * `{ProcessGroup:AzureSiteName}`  * `{ProcessGroup:CassandraClusterName}`  * `{ProcessGroup:CatalinaBase}`  * `{ProcessGroup:CatalinaHome}`  * `{ProcessGroup:CloudFoundryAppId}`  * `{ProcessGroup:CloudFoundryAppName}`  * `{ProcessGroup:CloudFoundryInstanceIndex}`  * `{ProcessGroup:CloudFoundrySpaceId}`  * `{ProcessGroup:CloudFoundrySpaceName}`  * `{ProcessGroup:ColdFusionJvmConfigFile}`  * `{ProcessGroup:ColdFusionServiceName}`  * `{ProcessGroup:CommandLineArgs}`  * `{ProcessGroup:DetectedName}`  * `{ProcessGroup:DotNetCommandPath}`  * `{ProcessGroup:DotNetCommand}`  * `{ProcessGroup:DotNetClusterId}`  * `{ProcessGroup:DotNetNodeId}`  * `{ProcessGroup:ElasticsearchClusterName}`  * `{ProcessGroup:ElasticsearchNodeName}`  * `{ProcessGroup:EquinoxConfigPath}`  * `{ProcessGroup:ExeName}`  * `{ProcessGroup:ExePath}`  * `{ProcessGroup:GlassFishDomainName}`  * `{ProcessGroup:GlassFishInstanceName}`  * `{ProcessGroup:GoogleAppEngineInstance}`  * `{ProcessGroup:GoogleAppEngineService}`  * `{ProcessGroup:GoogleCloudProject}`  * `{ProcessGroup:HybrisBinDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisConfigDirectory}`  * `{ProcessGroup:HybrisDataDirectory}`  * `{ProcessGroup:IBMCicsRegion}`  * `{ProcessGroup:IBMCtgName}`  * `{ProcessGroup:IBMImsConnectRegion}`  * `{ProcessGroup:IBMImsControlRegion}`  * `{ProcessGroup:IBMImsMessageProcessingRegion}`  * `{ProcessGroup:IBMImsSoapGwName}`  * `{ProcessGroup:IBMIntegrationNodeName}`  * `{ProcessGroup:IBMIntegrationServerName}`  * `{ProcessGroup:IISAppPool}`  * `{ProcessGroup:IISRoleName}`  * `{ProcessGroup:JbossHome}`  * `{ProcessGroup:JbossMode}`  * `{ProcessGroup:JbossServerName}`  * `{ProcessGroup:JavaJarFile}`  * `{ProcessGroup:JavaJarPath}`  * `{ProcessGroup:JavaMainCLass}`  * `{ProcessGroup:KubernetesBasePodName}`  * `{ProcessGroup:KubernetesContainerName}`  * `{ProcessGroup:KubernetesFullPodName}`  * `{ProcessGroup:KubernetesNamespace}`  * `{ProcessGroup:KubernetesPodUid}`  * `{ProcessGroup:MssqlInstanceName}`  * `{ProcessGroup:NodeJsAppBaseDirectory}`  * `{ProcessGroup:NodeJsAppName}`  * `{ProcessGroup:NodeJsScriptName}`  * `{ProcessGroup:OracleSid}`  * `{ProcessGroup:PHPScriptPath}`  * `{ProcessGroup:PHPWorkingDirectory}`  * `{ProcessGroup:Ports}`  * `{ProcessGroup:RubyAppRootPath}`  * `{ProcessGroup:RubyScriptPath}`  * `{ProcessGroup:SoftwareAGInstallRoot}`  * `{ProcessGroup:SoftwareAGProductPropertyName}`  * `{ProcessGroup:SpringBootAppName}`  * `{ProcessGroup:SpringBootProfileName}`  * `{ProcessGroup:SpringBootStartupClass}`  * `{ProcessGroup:TIBCOBusinessWorksAppNodeName}`  * `{ProcessGroup:TIBCOBusinessWorksAppSpaceName}`  * `{ProcessGroup:TIBCOBusinessWorksCeAppName}`  * `{ProcessGroup:TIBCOBusinessWorksCeVersion}`  * `{ProcessGroup:TIBCOBusinessWorksDomainName}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFilePath}`  * `{ProcessGroup:TIBCOBusinessWorksEnginePropertyFile}`  * `{ProcessGroup:TIBCOBusinessWorksHome}`  * `{ProcessGroup:VarnishInstanceName}`  * `{ProcessGroup:WebLogicClusterName}`  * `{ProcessGroup:WebLogicDomainName}`  * `{ProcessGroup:WebLogicHome}`  * `{ProcessGroup:WebLogicName}`  * `{ProcessGroup:WebSphereCellName}`  * `{ProcessGroup:WebSphereClusterName}`  * `{ProcessGroup:WebSphereNodeName}`  * `{ProcessGroup:WebSphereServerName}`  * `{ProcessGroup:ActorSystem}`  * `{Service:STGServerName}`  * `{Service:DatabaseHostName}`  * `{Service:DatabaseName}`  * `{Service:DatabaseVendor}`  * `{Service:DetectedName}`  * `{Service:EndpointPath}`  * `{Service:EndpointPathGatewayUrl}`  * `{Service:IIBApplicationName}`  * `{Service:MessageListenerClassName}`  * `{Service:Port}`  * `{Service:PublicDomainName}`  * `{Service:RemoteEndpoint}`  * `{Service:RemoteName}`  * `{Service:WebApplicationId}`  * `{Service:WebContextRoot}`  * `{Service:WebServerName}`  * `{Service:WebServiceNamespace}`  * `{Service:WebServiceName}`  * `{VmwareDatacenter:Name}`  * `{VmwareVm:Name}`
	// +optional
	ValueFormat *string `json:"valueFormat,omitempty" tf:"value_format"`
}

type AutotagSpec struct {
	State *AutotagSpecResource `json:"state,omitempty" tf:"-"`

	Resource AutotagSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type AutotagSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// A list of entity-selector based rules for management zone usage. If several rules are specified, the `or` logic applies
	// +optional
	// +kubebuilder:validation:MinItems=1
	EntitySelectorBasedRule []AutotagSpecEntitySelectorBasedRule `json:"entitySelectorBasedRule,omitempty" tf:"entity_selector_based_rule"`
	// `metadata` exists for backwards compatibility but shouldn't get specified anymore
	// +optional
	// Deprecated
	Metadata *AutotagSpecMetadata `json:"metadata,omitempty" tf:"metadata"`
	// The name of the auto-tag, which is applied to entities.  Additionally you can specify a **valueFormat** in the tag rule. In that case the tag is used in the `name:valueFormat` format.  For example you can extend the `Infrastructure` tag to `Infrastructure:Windows` and `Infrastructure:Linux`.
	Name *string `json:"name" tf:"name"`
	// A list of rules for management zone usage.  Each rule is evaluated independently of all other rules
	// +optional
	// +kubebuilder:validation:MinItems=1
	Rules []AutotagSpecRules `json:"rules,omitempty" tf:"rules"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AutotagStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// AutotagList is a list of Autotags
type AutotagList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Autotag CRD objects
	Items []Autotag `json:"items,omitempty"`
}
