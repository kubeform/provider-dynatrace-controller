/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Attribute struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AttributeSpec   `json:"spec,omitempty"`
	Status            AttributeStatus `json:"status,omitempty"`
}

type AttributeSpecDataSourcesCicsSdkMethodNodeCondition struct {
	// Negate the comparison
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator comparing the extracted value to the comparison value
	Operator *string `json:"operator" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	Value *string `json:"value" tf:"value"`
}

type AttributeSpecDataSourcesIibLabelMethodNodeCondition struct {
	// Negate the comparison
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator comparing the extracted value to the comparison value
	Operator *string `json:"operator" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	Value *string `json:"value" tf:"value"`
}

type AttributeSpecDataSourcesIibMethodNodeCondition struct {
	// Negate the comparison
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator comparing the extracted value to the comparison value
	Operator *string `json:"operator" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	Value *string `json:"value" tf:"value"`
}

type AttributeSpecDataSourcesMethodsMethod struct {
	// Configuration of a method to be captured
	// +optional
	// +kubebuilder:validation:MinItems=1
	ArgumentTypes []string `json:"argumentTypes,omitempty" tf:"argument_types"`
	// The class name where the method to capture resides.   Either this or the **fileName** must be set
	// +optional
	ClassName *string `json:"className,omitempty" tf:"class_name"`
	// The file name where the method to capture resides.   Either this or **className** must be set
	// +optional
	FileName *string `json:"fileName,omitempty" tf:"file_name"`
	// The operator of the comparison. If not set, `EQUALS` is used
	// +optional
	FileNameMatcher *string `json:"fileNameMatcher,omitempty" tf:"file_name_matcher"`
	// The name of the method to capture
	MethodName *string `json:"methodName" tf:"method_name"`
	// The modifiers of the method to capture
	// +optional
	// +kubebuilder:validation:MinItems=1
	Modifiers []string `json:"modifiers,omitempty" tf:"modifiers"`
	// The return type
	ReturnType *string `json:"returnType" tf:"return_type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The visibility of the method to capture
	Visibility *string `json:"visibility" tf:"visibility"`
}

type AttributeSpecDataSourcesMethods struct {
	// The index of the argument to capture. Set `0` to capture the return value, `1` or higher to capture a mehtod argument.   Required if the **capture** is set to `ARGUMENT`.  Not applicable in other cases
	// +optional
	ArgumentIndex *int64 `json:"argumentIndex,omitempty" tf:"argument_index"`
	// What to capture from the method
	Capture *string `json:"capture" tf:"capture"`
	// The getter chain to apply to the captured object. It is required in one of the following cases:  The **capture** is set to `THIS`.    The **capture** is set to `ARGUMENT`, and the argument is not a primitive, a primitive wrapper class, a string, or an array.   Not applicable in other cases
	// +optional
	DeepObjectAccess *string `json:"deepObjectAccess,omitempty" tf:"deep_object_access"`
	// Configuration of a method to be captured
	// +optional
	Method *AttributeSpecDataSourcesMethodsMethod `json:"method,omitempty" tf:"method"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AttributeSpecDataSourcesScope struct {
	// Only applies to this host group
	// +optional
	HostGroup *string `json:"hostGroup,omitempty" tf:"host_group"`
	// Only applies to this process group. Note that this can't be transferred between different clusters or environments
	// +optional
	ProcessGroup *string `json:"processGroup,omitempty" tf:"process_group"`
	// Only applies to this service technology
	// +optional
	ServiceTechnology *string `json:"serviceTechnology,omitempty" tf:"service_technology"`
	// Only apply to process groups matching this tag
	// +optional
	TagOfProcessGroup *string `json:"tagOfProcessGroup,omitempty" tf:"tag_of_process_group"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AttributeSpecDataSourcesValueProcessingExtractSubstring struct {
	// The delimiter string
	Delimiter *string `json:"delimiter" tf:"delimiter"`
	// The end-delimiter string.   Required if the **position** value is `BETWEEN`. Otherwise not allowed
	// +optional
	EndDelimiter *string `json:"endDelimiter,omitempty" tf:"end_delimiter"`
	// The position of the extracted string relative to delimiters
	Position *string `json:"position" tf:"position"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AttributeSpecDataSourcesValueProcessingValueCondition struct {
	// Negate the comparison
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Operator comparing the extracted value to the comparison value
	Operator *string `json:"operator" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	Value *string `json:"value" tf:"value"`
}

type AttributeSpecDataSourcesValueProcessing struct {
	// Preprocess by extracting a substring from the original value
	// +optional
	ExtractSubstring *AttributeSpecDataSourcesValueProcessingExtractSubstring `json:"extractSubstring,omitempty" tf:"extract_substring"`
	// Split (preprocessed) string values at this separator
	// +optional
	SplitAt *string `json:"splitAt,omitempty" tf:"split_at"`
	// Prune Whitespaces. Defaults to false
	// +optional
	Trim *bool `json:"trim,omitempty" tf:"trim"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// IBM integration bus label node name condition for which the value is captured
	// +optional
	ValueCondition *AttributeSpecDataSourcesValueProcessingValueCondition `json:"valueCondition,omitempty" tf:"value_condition"`
	// Extract value from captured data per regex
	// +optional
	ValueExtractorRegex *string `json:"valueExtractorRegex,omitempty" tf:"value_extractor_regex"`
}

type AttributeSpecDataSources struct {
	// Specifies the location where the values are captured and stored.  Required if the **source** is one of the following: `GET_PARAMETER`, `URI`, `REQUEST_HEADER`, `RESPONSE_HEADER`.   Not applicable in other cases.   If the **source** value is `REQUEST_HEADER` or `RESPONSE_HEADER`, the `CAPTURE_AND_STORE_ON_BOTH` location is not allowed
	// +optional
	CapturingAndStorageLocation *string `json:"capturingAndStorageLocation,omitempty" tf:"capturing_and_storage_location"`
	// IBM integration bus label node name condition for which the value is captured
	// +optional
	CicsSdkMethodNodeCondition *AttributeSpecDataSourcesCicsSdkMethodNodeCondition `json:"cicsSdkMethodNodeCondition,omitempty" tf:"cics_sdk_method_node_condition"`
	// The data source is enabled (`true`) or disabled (`false`)
	Enabled *bool `json:"enabled" tf:"enabled"`
	// IBM integration bus label node name condition for which the value is captured
	// +optional
	IibLabelMethodNodeCondition *AttributeSpecDataSourcesIibLabelMethodNodeCondition `json:"iibLabelMethodNodeCondition,omitempty" tf:"iib_label_method_node_condition"`
	// IBM integration bus label node name condition for which the value is captured
	// +optional
	IibMethodNodeCondition *AttributeSpecDataSourcesIibMethodNodeCondition `json:"iibMethodNodeCondition,omitempty" tf:"iib_method_node_condition"`
	// The IBM integration bus node type for which the value is captured.  This or `iibMethodNodeCondition` is required if the **source** is: `IIB_NODE`.  Not applicable in other cases
	// +optional
	IibNodeType *string `json:"iibNodeType,omitempty" tf:"iib_node_type"`
	// The method specification if the **source** value is `METHOD_PARAM`.   Not applicable in other cases
	// +optional
	// +kubebuilder:validation:MinItems=1
	Methods []AttributeSpecDataSourcesMethods `json:"methods,omitempty" tf:"methods"`
	// The name of the web request parameter to capture.  Required if the **source** is one of the following: `POST_PARAMETER`, `GET_PARAMETER`, `REQUEST_HEADER`, `RESPONSE_HEADER`, `CUSTOM_ATTRIBUTE`.  Not applicable in other cases
	// +optional
	ParameterName *string `json:"parameterName,omitempty" tf:"parameter_name"`
	// Conditions for data capturing
	// +optional
	Scope *AttributeSpecDataSourcesScope `json:"scope,omitempty" tf:"scope"`
	// The technology of the session attribute to capture if the **source** value is `SESSION_ATTRIBUTE`.
	//
	//  Not applicable in other cases
	// +optional
	SessionAttributeTechnology *string `json:"sessionAttributeTechnology,omitempty" tf:"session_attribute_technology"`
	// The source of the attribute to capture. Works in conjunction with **parameterName** or **methods** and **technology**
	Source *string `json:"source" tf:"source"`
	// The technology of the method to capture if the **source** value is `METHOD_PARAM`.
	//
	//  Not applicable in other cases
	// +optional
	Technology *string `json:"technology,omitempty" tf:"technology"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// Process values as specified
	// +optional
	ValueProcessing *AttributeSpecDataSourcesValueProcessing `json:"valueProcessing,omitempty" tf:"value_processing"`
}

type AttributeSpec struct {
	State *AttributeSpecResource `json:"state,omitempty" tf:"-"`

	Resource AttributeSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type AttributeSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Aggregation type for the request values
	Aggregation *string `json:"aggregation" tf:"aggregation"`
	// Confidential data flag. Set `true` to treat the captured data as confidential
	// +optional
	Confidential *bool `json:"confidential,omitempty" tf:"confidential"`
	// The list of data sources
	// +optional
	// +kubebuilder:validation:MinItems=1
	DataSources []AttributeSpecDataSources `json:"dataSources,omitempty" tf:"data_sources"`
	// The data type of the request attribute
	DataType *string `json:"dataType" tf:"data_type"`
	// The request attribute is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// The name of the request attribute
	Name *string `json:"name" tf:"name"`
	// String values transformation.   If the **dataType** is not `string`, set the `Original` here
	Normalization *string `json:"normalization" tf:"normalization"`
	// Personal data masking flag. Set `true` to skip masking.   Warning: This will potentially access personalized data
	// +optional
	SkipPersonalDataMasking *bool `json:"skipPersonalDataMasking,omitempty" tf:"skip_personal_data_masking"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type AttributeStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// AttributeList is a list of Attributes
type AttributeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Attribute CRD objects
	Items []Attribute `json:"items,omitempty"`
}
