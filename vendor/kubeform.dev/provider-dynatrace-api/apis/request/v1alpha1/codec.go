/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1()):      AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1()):     AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1()):          AttributeSpecDataSourcesIibMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1()):                   AttributeSpecDataSourcesMethodsMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1()):                           AttributeSpecDataSourcesScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1()):                 AttributeSpecDataSourcesValueProcessingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1()): AttributeSpecDataSourcesValueProcessingExtractSubstringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1()):   AttributeSpecDataSourcesValueProcessingValueConditionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1()):      AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1()):     AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1()):          AttributeSpecDataSourcesIibMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1()):                   AttributeSpecDataSourcesMethodsMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1()):                           AttributeSpecDataSourcesScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1()):                 AttributeSpecDataSourcesValueProcessingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1()): AttributeSpecDataSourcesValueProcessingExtractSubstringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1()):   AttributeSpecDataSourcesValueProcessingValueConditionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec struct {
}

func (AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr)
	var objs []AttributeSpecDataSourcesCicsSdkMethodNodeCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesCicsSdkMethodNodeCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesCicsSdkMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesCicsSdkMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesCicsSdkMethodNodeCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec struct {
}

func (AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr)
	var objs []AttributeSpecDataSourcesIibLabelMethodNodeCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesIibLabelMethodNodeCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesIibLabelMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesIibLabelMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesIibLabelMethodNodeCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesIibMethodNodeConditionCodec struct {
}

func (AttributeSpecDataSourcesIibMethodNodeConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesIibMethodNodeConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr)
	var objs []AttributeSpecDataSourcesIibMethodNodeCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesIibMethodNodeCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesIibMethodNodeConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesIibMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesIibMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesIibMethodNodeCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesMethodsMethodCodec struct {
}

func (AttributeSpecDataSourcesMethodsMethodCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesMethodsMethod)(ptr) == nil
}

func (AttributeSpecDataSourcesMethodsMethodCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesMethodsMethod)(ptr)
	var objs []AttributeSpecDataSourcesMethodsMethod
	if obj != nil {
		objs = []AttributeSpecDataSourcesMethodsMethod{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesMethodsMethodCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesMethodsMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
			}
		} else {
			*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesMethodsMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesMethodsMethod", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesScopeCodec struct {
}

func (AttributeSpecDataSourcesScopeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesScope)(ptr) == nil
}

func (AttributeSpecDataSourcesScopeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesScope)(ptr)
	var objs []AttributeSpecDataSourcesScope
	if obj != nil {
		objs = []AttributeSpecDataSourcesScope{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesScopeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesScope

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesScope)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
			}
		} else {
			*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesScope

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesScope)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesScope", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesValueProcessingCodec struct {
}

func (AttributeSpecDataSourcesValueProcessingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesValueProcessing)(ptr) == nil
}

func (AttributeSpecDataSourcesValueProcessingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesValueProcessing)(ptr)
	var objs []AttributeSpecDataSourcesValueProcessing
	if obj != nil {
		objs = []AttributeSpecDataSourcesValueProcessing{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesValueProcessingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesValueProcessing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesValueProcessing)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
			}
		} else {
			*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesValueProcessing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesValueProcessing)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesValueProcessing", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesValueProcessingExtractSubstringCodec struct {
}

func (AttributeSpecDataSourcesValueProcessingExtractSubstringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) == nil
}

func (AttributeSpecDataSourcesValueProcessingExtractSubstringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr)
	var objs []AttributeSpecDataSourcesValueProcessingExtractSubstring
	if obj != nil {
		objs = []AttributeSpecDataSourcesValueProcessingExtractSubstring{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesValueProcessingExtractSubstringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesValueProcessingExtractSubstring

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
			}
		} else {
			*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesValueProcessingExtractSubstring

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesValueProcessingExtractSubstring", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesValueProcessingValueConditionCodec struct {
}

func (AttributeSpecDataSourcesValueProcessingValueConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesValueProcessingValueConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr)
	var objs []AttributeSpecDataSourcesValueProcessingValueCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesValueProcessingValueCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesValueProcessingValueConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesValueProcessingValueCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesValueProcessingValueCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesValueProcessingValueCondition", "unexpected JSON type")
	}
}
