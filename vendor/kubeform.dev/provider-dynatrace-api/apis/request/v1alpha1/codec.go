/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1()):                                  AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1()):                                 AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1()):                                      AttributeSpecDataSourcesIibMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1()):                                               AttributeSpecDataSourcesMethodsMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1()):                                                       AttributeSpecDataSourcesScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1()):                                             AttributeSpecDataSourcesValueProcessingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1()):                             AttributeSpecDataSourcesValueProcessingExtractSubstringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1()):                               AttributeSpecDataSourcesValueProcessingValueConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditions{}).Type1()):                                                                NamingSpecConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparison{}).Type1()):                                             NamingSpecConditionsConditionComparisonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonBoolean{}).Type1()):                                      NamingSpecConditionsConditionComparisonBooleanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonEsbInputNodeType{}).Type1()):                             NamingSpecConditionsConditionComparisonEsbInputNodeTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailedState{}).Type1()):                                  NamingSpecConditionsConditionComparisonFailedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailureReason{}).Type1()):                                NamingSpecConditionsConditionComparisonFailureReasonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFastString{}).Type1()):                                   NamingSpecConditionsConditionComparisonFastStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFlawState{}).Type1()):                                    NamingSpecConditionsConditionComparisonFlawStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonGeneric{}).Type1()):                                      NamingSpecConditionsConditionComparisonGenericCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpMethod{}).Type1()):                                   NamingSpecConditionsConditionComparisonHttpMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpStatusClass{}).Type1()):                              NamingSpecConditionsConditionComparisonHttpStatusClassCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonIibInputNodeType{}).Type1()):                             NamingSpecConditionsConditionComparisonIibInputNodeTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumber{}).Type1()):                                       NamingSpecConditionsConditionComparisonNumberCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttribute{}).Type1()):                       NamingSpecConditionsConditionComparisonNumberRequestAttributeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}).Type1()):                 NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}).Type1()):       NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}).Type1()): NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonServiceType{}).Type1()):                                  NamingSpecConditionsConditionComparisonServiceTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonString{}).Type1()):                                       NamingSpecConditionsConditionComparisonStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttribute{}).Type1()):                       NamingSpecConditionsConditionComparisonStringRequestAttributeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}).Type1()):                 NamingSpecConditionsConditionComparisonStringRequestAttributeSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}).Type1()):       NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}).Type1()): NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTag{}).Type1()):                                          NamingSpecConditionsConditionComparisonTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValue{}).Type1()):                                     NamingSpecConditionsConditionComparisonTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValues{}).Type1()):                                    NamingSpecConditionsConditionComparisonTagValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonZosCallType{}).Type1()):                                  NamingSpecConditionsConditionComparisonZosCallTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholders{}).Type1()):                                                              NamingSpecPlaceholdersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSource{}).Type1()):                                             NamingSpecPlaceholdersPlaceholderSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTag{}).Type1()):                                   NamingSpecPlaceholdersPlaceholderSourceServiceTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}).Type1()):                             NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKeyCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1()):                                  AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1()):                                 AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1()):                                      AttributeSpecDataSourcesIibMethodNodeConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1()):                                               AttributeSpecDataSourcesMethodsMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1()):                                                       AttributeSpecDataSourcesScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1()):                                             AttributeSpecDataSourcesValueProcessingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1()):                             AttributeSpecDataSourcesValueProcessingExtractSubstringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1()):                               AttributeSpecDataSourcesValueProcessingValueConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditions{}).Type1()):                                                                NamingSpecConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparison{}).Type1()):                                             NamingSpecConditionsConditionComparisonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonBoolean{}).Type1()):                                      NamingSpecConditionsConditionComparisonBooleanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonEsbInputNodeType{}).Type1()):                             NamingSpecConditionsConditionComparisonEsbInputNodeTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailedState{}).Type1()):                                  NamingSpecConditionsConditionComparisonFailedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailureReason{}).Type1()):                                NamingSpecConditionsConditionComparisonFailureReasonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFastString{}).Type1()):                                   NamingSpecConditionsConditionComparisonFastStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFlawState{}).Type1()):                                    NamingSpecConditionsConditionComparisonFlawStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonGeneric{}).Type1()):                                      NamingSpecConditionsConditionComparisonGenericCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpMethod{}).Type1()):                                   NamingSpecConditionsConditionComparisonHttpMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpStatusClass{}).Type1()):                              NamingSpecConditionsConditionComparisonHttpStatusClassCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonIibInputNodeType{}).Type1()):                             NamingSpecConditionsConditionComparisonIibInputNodeTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumber{}).Type1()):                                       NamingSpecConditionsConditionComparisonNumberCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttribute{}).Type1()):                       NamingSpecConditionsConditionComparisonNumberRequestAttributeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}).Type1()):                 NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}).Type1()):       NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}).Type1()): NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonServiceType{}).Type1()):                                  NamingSpecConditionsConditionComparisonServiceTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonString{}).Type1()):                                       NamingSpecConditionsConditionComparisonStringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttribute{}).Type1()):                       NamingSpecConditionsConditionComparisonStringRequestAttributeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}).Type1()):                 NamingSpecConditionsConditionComparisonStringRequestAttributeSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}).Type1()):       NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}).Type1()): NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTag{}).Type1()):                                          NamingSpecConditionsConditionComparisonTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValue{}).Type1()):                                     NamingSpecConditionsConditionComparisonTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValues{}).Type1()):                                    NamingSpecConditionsConditionComparisonTagValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonZosCallType{}).Type1()):                                  NamingSpecConditionsConditionComparisonZosCallTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholders{}).Type1()):                                                              NamingSpecPlaceholdersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSource{}).Type1()):                                             NamingSpecPlaceholdersPlaceholderSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTag{}).Type1()):                                   NamingSpecPlaceholdersPlaceholderSourceServiceTagCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}).Type1()):                             NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKeyCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec struct {
}

func (AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr)
	var objs []AttributeSpecDataSourcesCicsSdkMethodNodeCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesCicsSdkMethodNodeCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesCicsSdkMethodNodeConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesCicsSdkMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesCicsSdkMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesCicsSdkMethodNodeCondition)(ptr) = AttributeSpecDataSourcesCicsSdkMethodNodeCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesCicsSdkMethodNodeCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec struct {
}

func (AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr)
	var objs []AttributeSpecDataSourcesIibLabelMethodNodeCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesIibLabelMethodNodeCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesIibLabelMethodNodeConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesIibLabelMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesIibLabelMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibLabelMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesIibLabelMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibLabelMethodNodeCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesIibLabelMethodNodeCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesIibMethodNodeConditionCodec struct {
}

func (AttributeSpecDataSourcesIibMethodNodeConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesIibMethodNodeConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr)
	var objs []AttributeSpecDataSourcesIibMethodNodeCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesIibMethodNodeCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesIibMethodNodeConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesIibMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesIibMethodNodeCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesIibMethodNodeCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesIibMethodNodeCondition)(ptr) = AttributeSpecDataSourcesIibMethodNodeCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesIibMethodNodeCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesMethodsMethodCodec struct {
}

func (AttributeSpecDataSourcesMethodsMethodCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesMethodsMethod)(ptr) == nil
}

func (AttributeSpecDataSourcesMethodsMethodCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesMethodsMethod)(ptr)
	var objs []AttributeSpecDataSourcesMethodsMethod
	if obj != nil {
		objs = []AttributeSpecDataSourcesMethodsMethod{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesMethodsMethodCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesMethodsMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
			}
		} else {
			*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesMethodsMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesMethodsMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesMethodsMethod)(ptr) = AttributeSpecDataSourcesMethodsMethod{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesMethodsMethod", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesScopeCodec struct {
}

func (AttributeSpecDataSourcesScopeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesScope)(ptr) == nil
}

func (AttributeSpecDataSourcesScopeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesScope)(ptr)
	var objs []AttributeSpecDataSourcesScope
	if obj != nil {
		objs = []AttributeSpecDataSourcesScope{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesScopeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesScope

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesScope)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
			}
		} else {
			*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesScope

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesScope{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesScope)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesScope)(ptr) = AttributeSpecDataSourcesScope{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesScope", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesValueProcessingCodec struct {
}

func (AttributeSpecDataSourcesValueProcessingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesValueProcessing)(ptr) == nil
}

func (AttributeSpecDataSourcesValueProcessingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesValueProcessing)(ptr)
	var objs []AttributeSpecDataSourcesValueProcessing
	if obj != nil {
		objs = []AttributeSpecDataSourcesValueProcessing{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesValueProcessingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesValueProcessing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesValueProcessing)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
			}
		} else {
			*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesValueProcessing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesValueProcessing)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesValueProcessing)(ptr) = AttributeSpecDataSourcesValueProcessing{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesValueProcessing", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesValueProcessingExtractSubstringCodec struct {
}

func (AttributeSpecDataSourcesValueProcessingExtractSubstringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) == nil
}

func (AttributeSpecDataSourcesValueProcessingExtractSubstringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr)
	var objs []AttributeSpecDataSourcesValueProcessingExtractSubstring
	if obj != nil {
		objs = []AttributeSpecDataSourcesValueProcessingExtractSubstring{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesValueProcessingExtractSubstringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesValueProcessingExtractSubstring

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
			}
		} else {
			*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesValueProcessingExtractSubstring

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingExtractSubstring{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesValueProcessingExtractSubstring)(ptr) = AttributeSpecDataSourcesValueProcessingExtractSubstring{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesValueProcessingExtractSubstring", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AttributeSpecDataSourcesValueProcessingValueConditionCodec struct {
}

func (AttributeSpecDataSourcesValueProcessingValueConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) == nil
}

func (AttributeSpecDataSourcesValueProcessingValueConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr)
	var objs []AttributeSpecDataSourcesValueProcessingValueCondition
	if obj != nil {
		objs = []AttributeSpecDataSourcesValueProcessingValueCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AttributeSpecDataSourcesValueProcessingValueConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AttributeSpecDataSourcesValueProcessingValueCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = objs[0]
			} else {
				*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
			}
		} else {
			*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AttributeSpecDataSourcesValueProcessingValueCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AttributeSpecDataSourcesValueProcessingValueCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = obj
		} else {
			*(*AttributeSpecDataSourcesValueProcessingValueCondition)(ptr) = AttributeSpecDataSourcesValueProcessingValueCondition{}
		}
	default:
		iter.ReportError("decode AttributeSpecDataSourcesValueProcessingValueCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsCodec struct {
}

func (NamingSpecConditionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditions)(ptr) == nil
}

func (NamingSpecConditionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditions)(ptr)
	var objs []NamingSpecConditions
	if obj != nil {
		objs = []NamingSpecConditions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditions)(ptr) = NamingSpecConditions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditions)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditions)(ptr) = NamingSpecConditions{}
			}
		} else {
			*(*NamingSpecConditions)(ptr) = NamingSpecConditions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditions)(ptr) = obj
		} else {
			*(*NamingSpecConditions)(ptr) = NamingSpecConditions{}
		}
	default:
		iter.ReportError("decode NamingSpecConditions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonCodec struct {
}

func (NamingSpecConditionsConditionComparisonCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparison)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparison)(ptr)
	var objs []NamingSpecConditionsConditionComparison
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparison{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparison{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparison)(ptr) = NamingSpecConditionsConditionComparison{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparison

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparison{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparison)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparison)(ptr) = NamingSpecConditionsConditionComparison{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparison)(ptr) = NamingSpecConditionsConditionComparison{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparison

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparison{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparison)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparison)(ptr) = NamingSpecConditionsConditionComparison{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparison", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonBooleanCodec struct {
}

func (NamingSpecConditionsConditionComparisonBooleanCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonBoolean)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonBooleanCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonBoolean)(ptr)
	var objs []NamingSpecConditionsConditionComparisonBoolean
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonBoolean{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonBoolean{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonBooleanCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonBoolean)(ptr) = NamingSpecConditionsConditionComparisonBoolean{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonBoolean

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonBoolean{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonBoolean)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonBoolean)(ptr) = NamingSpecConditionsConditionComparisonBoolean{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonBoolean)(ptr) = NamingSpecConditionsConditionComparisonBoolean{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonBoolean

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonBoolean{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonBoolean)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonBoolean)(ptr) = NamingSpecConditionsConditionComparisonBoolean{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonBoolean", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonEsbInputNodeTypeCodec struct {
}

func (NamingSpecConditionsConditionComparisonEsbInputNodeTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonEsbInputNodeTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr)
	var objs []NamingSpecConditionsConditionComparisonEsbInputNodeType
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonEsbInputNodeType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonEsbInputNodeType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonEsbInputNodeTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonEsbInputNodeType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonEsbInputNodeType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonEsbInputNodeType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonEsbInputNodeType{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonEsbInputNodeType{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonEsbInputNodeType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonEsbInputNodeType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonEsbInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonEsbInputNodeType{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonEsbInputNodeType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonFailedStateCodec struct {
}

func (NamingSpecConditionsConditionComparisonFailedStateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonFailedState)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonFailedStateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonFailedState)(ptr)
	var objs []NamingSpecConditionsConditionComparisonFailedState
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonFailedState{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailedState{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonFailedStateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonFailedState)(ptr) = NamingSpecConditionsConditionComparisonFailedState{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonFailedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonFailedState)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonFailedState)(ptr) = NamingSpecConditionsConditionComparisonFailedState{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonFailedState)(ptr) = NamingSpecConditionsConditionComparisonFailedState{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonFailedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonFailedState)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonFailedState)(ptr) = NamingSpecConditionsConditionComparisonFailedState{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonFailedState", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonFailureReasonCodec struct {
}

func (NamingSpecConditionsConditionComparisonFailureReasonCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonFailureReason)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonFailureReasonCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonFailureReason)(ptr)
	var objs []NamingSpecConditionsConditionComparisonFailureReason
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonFailureReason{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailureReason{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonFailureReasonCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonFailureReason)(ptr) = NamingSpecConditionsConditionComparisonFailureReason{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonFailureReason

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailureReason{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonFailureReason)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonFailureReason)(ptr) = NamingSpecConditionsConditionComparisonFailureReason{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonFailureReason)(ptr) = NamingSpecConditionsConditionComparisonFailureReason{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonFailureReason

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFailureReason{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonFailureReason)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonFailureReason)(ptr) = NamingSpecConditionsConditionComparisonFailureReason{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonFailureReason", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonFastStringCodec struct {
}

func (NamingSpecConditionsConditionComparisonFastStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonFastString)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonFastStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonFastString)(ptr)
	var objs []NamingSpecConditionsConditionComparisonFastString
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonFastString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFastString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonFastStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonFastString)(ptr) = NamingSpecConditionsConditionComparisonFastString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonFastString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFastString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonFastString)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonFastString)(ptr) = NamingSpecConditionsConditionComparisonFastString{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonFastString)(ptr) = NamingSpecConditionsConditionComparisonFastString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonFastString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFastString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonFastString)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonFastString)(ptr) = NamingSpecConditionsConditionComparisonFastString{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonFastString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonFlawStateCodec struct {
}

func (NamingSpecConditionsConditionComparisonFlawStateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonFlawState)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonFlawStateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonFlawState)(ptr)
	var objs []NamingSpecConditionsConditionComparisonFlawState
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonFlawState{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFlawState{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonFlawStateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonFlawState)(ptr) = NamingSpecConditionsConditionComparisonFlawState{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonFlawState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFlawState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonFlawState)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonFlawState)(ptr) = NamingSpecConditionsConditionComparisonFlawState{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonFlawState)(ptr) = NamingSpecConditionsConditionComparisonFlawState{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonFlawState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonFlawState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonFlawState)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonFlawState)(ptr) = NamingSpecConditionsConditionComparisonFlawState{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonFlawState", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonGenericCodec struct {
}

func (NamingSpecConditionsConditionComparisonGenericCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonGeneric)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonGenericCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonGeneric)(ptr)
	var objs []NamingSpecConditionsConditionComparisonGeneric
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonGeneric{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonGeneric{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonGenericCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonGeneric)(ptr) = NamingSpecConditionsConditionComparisonGeneric{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonGeneric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonGeneric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonGeneric)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonGeneric)(ptr) = NamingSpecConditionsConditionComparisonGeneric{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonGeneric)(ptr) = NamingSpecConditionsConditionComparisonGeneric{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonGeneric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonGeneric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonGeneric)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonGeneric)(ptr) = NamingSpecConditionsConditionComparisonGeneric{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonGeneric", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonHttpMethodCodec struct {
}

func (NamingSpecConditionsConditionComparisonHttpMethodCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonHttpMethodCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonHttpMethod)(ptr)
	var objs []NamingSpecConditionsConditionComparisonHttpMethod
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonHttpMethod{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpMethod{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonHttpMethodCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) = NamingSpecConditionsConditionComparisonHttpMethod{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonHttpMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) = NamingSpecConditionsConditionComparisonHttpMethod{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) = NamingSpecConditionsConditionComparisonHttpMethod{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonHttpMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonHttpMethod)(ptr) = NamingSpecConditionsConditionComparisonHttpMethod{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonHttpMethod", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonHttpStatusClassCodec struct {
}

func (NamingSpecConditionsConditionComparisonHttpStatusClassCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonHttpStatusClassCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr)
	var objs []NamingSpecConditionsConditionComparisonHttpStatusClass
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonHttpStatusClass{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpStatusClass{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonHttpStatusClassCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) = NamingSpecConditionsConditionComparisonHttpStatusClass{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonHttpStatusClass

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpStatusClass{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) = NamingSpecConditionsConditionComparisonHttpStatusClass{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) = NamingSpecConditionsConditionComparisonHttpStatusClass{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonHttpStatusClass

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonHttpStatusClass{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonHttpStatusClass)(ptr) = NamingSpecConditionsConditionComparisonHttpStatusClass{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonHttpStatusClass", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonIibInputNodeTypeCodec struct {
}

func (NamingSpecConditionsConditionComparisonIibInputNodeTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonIibInputNodeTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr)
	var objs []NamingSpecConditionsConditionComparisonIibInputNodeType
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonIibInputNodeType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonIibInputNodeType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonIibInputNodeTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonIibInputNodeType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonIibInputNodeType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonIibInputNodeType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonIibInputNodeType{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonIibInputNodeType{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonIibInputNodeType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonIibInputNodeType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonIibInputNodeType)(ptr) = NamingSpecConditionsConditionComparisonIibInputNodeType{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonIibInputNodeType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonNumberCodec struct {
}

func (NamingSpecConditionsConditionComparisonNumberCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonNumber)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonNumberCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonNumber)(ptr)
	var objs []NamingSpecConditionsConditionComparisonNumber
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonNumber{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumber{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonNumberCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonNumber)(ptr) = NamingSpecConditionsConditionComparisonNumber{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonNumber

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumber{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonNumber)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonNumber)(ptr) = NamingSpecConditionsConditionComparisonNumber{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonNumber)(ptr) = NamingSpecConditionsConditionComparisonNumber{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonNumber

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumber{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonNumber)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonNumber)(ptr) = NamingSpecConditionsConditionComparisonNumber{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonNumber", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonNumberRequestAttributeCodec struct {
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr)
	var objs []NamingSpecConditionsConditionComparisonNumberRequestAttribute
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonNumberRequestAttribute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttribute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttribute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonNumberRequestAttribute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttribute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttribute{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttribute{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonNumberRequestAttribute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttribute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttribute{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonNumberRequestAttribute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceCodec struct {
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr)
	var objs []NamingSpecConditionsConditionComparisonNumberRequestAttributeSource
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonNumberRequestAttributeSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonNumberRequestAttributeSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSource{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonNumberRequestAttributeSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagCodec struct {
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr)
	var objs []NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyCodec struct {
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr)
	var objs []NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonServiceTypeCodec struct {
}

func (NamingSpecConditionsConditionComparisonServiceTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonServiceType)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonServiceTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonServiceType)(ptr)
	var objs []NamingSpecConditionsConditionComparisonServiceType
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonServiceType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonServiceType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonServiceTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonServiceType)(ptr) = NamingSpecConditionsConditionComparisonServiceType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonServiceType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonServiceType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonServiceType)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonServiceType)(ptr) = NamingSpecConditionsConditionComparisonServiceType{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonServiceType)(ptr) = NamingSpecConditionsConditionComparisonServiceType{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonServiceType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonServiceType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonServiceType)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonServiceType)(ptr) = NamingSpecConditionsConditionComparisonServiceType{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonServiceType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonStringCodec struct {
}

func (NamingSpecConditionsConditionComparisonStringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonString)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonStringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonString)(ptr)
	var objs []NamingSpecConditionsConditionComparisonString
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonString{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonString{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonStringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonString)(ptr) = NamingSpecConditionsConditionComparisonString{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonString)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonString)(ptr) = NamingSpecConditionsConditionComparisonString{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonString)(ptr) = NamingSpecConditionsConditionComparisonString{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonString

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonString{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonString)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonString)(ptr) = NamingSpecConditionsConditionComparisonString{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonString", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonStringRequestAttributeCodec struct {
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr)
	var objs []NamingSpecConditionsConditionComparisonStringRequestAttribute
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonStringRequestAttribute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttribute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttribute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonStringRequestAttribute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttribute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttribute{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttribute{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonStringRequestAttribute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttribute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttribute)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttribute{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonStringRequestAttribute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonStringRequestAttributeSourceCodec struct {
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr)
	var objs []NamingSpecConditionsConditionComparisonStringRequestAttributeSource
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonStringRequestAttributeSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonStringRequestAttributeSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonStringRequestAttributeSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSource)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSource{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonStringRequestAttributeSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagCodec struct {
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr)
	var objs []NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyCodec struct {
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr)
	var objs []NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey)(ptr) = NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonTagCodec struct {
}

func (NamingSpecConditionsConditionComparisonTagCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonTag)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonTagCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonTag)(ptr)
	var objs []NamingSpecConditionsConditionComparisonTag
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonTag{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTag{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonTagCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonTag)(ptr) = NamingSpecConditionsConditionComparisonTag{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonTag)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonTag)(ptr) = NamingSpecConditionsConditionComparisonTag{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonTag)(ptr) = NamingSpecConditionsConditionComparisonTag{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonTag)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonTag)(ptr) = NamingSpecConditionsConditionComparisonTag{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonTag", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonTagValueCodec struct {
}

func (NamingSpecConditionsConditionComparisonTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonTagValue)(ptr)
	var objs []NamingSpecConditionsConditionComparisonTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonTagValue)(ptr) = NamingSpecConditionsConditionComparisonTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonTagValue)(ptr) = NamingSpecConditionsConditionComparisonTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonTagValue)(ptr) = NamingSpecConditionsConditionComparisonTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonTagValue)(ptr) = NamingSpecConditionsConditionComparisonTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonTagValuesCodec struct {
}

func (NamingSpecConditionsConditionComparisonTagValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonTagValues)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonTagValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonTagValues)(ptr)
	var objs []NamingSpecConditionsConditionComparisonTagValues
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonTagValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonTagValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonTagValues)(ptr) = NamingSpecConditionsConditionComparisonTagValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonTagValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonTagValues)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonTagValues)(ptr) = NamingSpecConditionsConditionComparisonTagValues{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonTagValues)(ptr) = NamingSpecConditionsConditionComparisonTagValues{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonTagValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonTagValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonTagValues)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonTagValues)(ptr) = NamingSpecConditionsConditionComparisonTagValues{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonTagValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionComparisonZosCallTypeCodec struct {
}

func (NamingSpecConditionsConditionComparisonZosCallTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionComparisonZosCallType)(ptr) == nil
}

func (NamingSpecConditionsConditionComparisonZosCallTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionComparisonZosCallType)(ptr)
	var objs []NamingSpecConditionsConditionComparisonZosCallType
	if obj != nil {
		objs = []NamingSpecConditionsConditionComparisonZosCallType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonZosCallType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionComparisonZosCallTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionComparisonZosCallType)(ptr) = NamingSpecConditionsConditionComparisonZosCallType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionComparisonZosCallType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonZosCallType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionComparisonZosCallType)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionComparisonZosCallType)(ptr) = NamingSpecConditionsConditionComparisonZosCallType{}
			}
		} else {
			*(*NamingSpecConditionsConditionComparisonZosCallType)(ptr) = NamingSpecConditionsConditionComparisonZosCallType{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionComparisonZosCallType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionComparisonZosCallType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionComparisonZosCallType)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionComparisonZosCallType)(ptr) = NamingSpecConditionsConditionComparisonZosCallType{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionComparisonZosCallType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecPlaceholdersCodec struct {
}

func (NamingSpecPlaceholdersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecPlaceholders)(ptr) == nil
}

func (NamingSpecPlaceholdersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecPlaceholders)(ptr)
	var objs []NamingSpecPlaceholders
	if obj != nil {
		objs = []NamingSpecPlaceholders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecPlaceholdersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecPlaceholders)(ptr) = NamingSpecPlaceholders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecPlaceholders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecPlaceholders)(ptr) = objs[0]
			} else {
				*(*NamingSpecPlaceholders)(ptr) = NamingSpecPlaceholders{}
			}
		} else {
			*(*NamingSpecPlaceholders)(ptr) = NamingSpecPlaceholders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecPlaceholders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecPlaceholders)(ptr) = obj
		} else {
			*(*NamingSpecPlaceholders)(ptr) = NamingSpecPlaceholders{}
		}
	default:
		iter.ReportError("decode NamingSpecPlaceholders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecPlaceholdersPlaceholderSourceCodec struct {
}

func (NamingSpecPlaceholdersPlaceholderSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecPlaceholdersPlaceholderSource)(ptr) == nil
}

func (NamingSpecPlaceholdersPlaceholderSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecPlaceholdersPlaceholderSource)(ptr)
	var objs []NamingSpecPlaceholdersPlaceholderSource
	if obj != nil {
		objs = []NamingSpecPlaceholdersPlaceholderSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecPlaceholdersPlaceholderSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecPlaceholdersPlaceholderSource)(ptr) = NamingSpecPlaceholdersPlaceholderSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecPlaceholdersPlaceholderSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecPlaceholdersPlaceholderSource)(ptr) = objs[0]
			} else {
				*(*NamingSpecPlaceholdersPlaceholderSource)(ptr) = NamingSpecPlaceholdersPlaceholderSource{}
			}
		} else {
			*(*NamingSpecPlaceholdersPlaceholderSource)(ptr) = NamingSpecPlaceholdersPlaceholderSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecPlaceholdersPlaceholderSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecPlaceholdersPlaceholderSource)(ptr) = obj
		} else {
			*(*NamingSpecPlaceholdersPlaceholderSource)(ptr) = NamingSpecPlaceholdersPlaceholderSource{}
		}
	default:
		iter.ReportError("decode NamingSpecPlaceholdersPlaceholderSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecPlaceholdersPlaceholderSourceServiceTagCodec struct {
}

func (NamingSpecPlaceholdersPlaceholderSourceServiceTagCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) == nil
}

func (NamingSpecPlaceholdersPlaceholderSourceServiceTagCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr)
	var objs []NamingSpecPlaceholdersPlaceholderSourceServiceTag
	if obj != nil {
		objs = []NamingSpecPlaceholdersPlaceholderSourceServiceTag{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTag{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecPlaceholdersPlaceholderSourceServiceTagCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTag{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecPlaceholdersPlaceholderSourceServiceTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) = objs[0]
			} else {
				*(*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTag{}
			}
		} else {
			*(*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTag{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecPlaceholdersPlaceholderSourceServiceTag

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTag{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) = obj
		} else {
			*(*NamingSpecPlaceholdersPlaceholderSourceServiceTag)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTag{}
		}
	default:
		iter.ReportError("decode NamingSpecPlaceholdersPlaceholderSourceServiceTag", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKeyCodec struct {
}

func (NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) == nil
}

func (NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr)
	var objs []NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey
	if obj != nil {
		objs = []NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}
			}
		} else {
			*(*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) = obj
		} else {
			*(*NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey)(ptr) = NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey{}
		}
	default:
		iter.ReportError("decode NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey", "unexpected JSON type")
	}
}
