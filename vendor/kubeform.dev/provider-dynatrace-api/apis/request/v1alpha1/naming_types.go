/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Naming struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NamingSpec   `json:"spec,omitempty"`
	Status            NamingStatus `json:"status,omitempty"`
}

type NamingSpecConditionsConditionComparisonBoolean struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *bool `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []bool `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonEsbInputNodeType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonFailedState struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `FAILED` and `FAILED`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `FAILED` and `FAILED`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonFailureReason struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonFastString struct {
	// The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `CONTAINS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonFlawState struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonGeneric struct {
	// Defines the actual set of fields depending on the value
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionComparisonHttpMethod struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonHttpStatusClass struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonIibInputNodeType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonNumber struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *float64 `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []float64 `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey struct {
	// has no documentation
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// has no documentation
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
}

type NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag struct {
	// The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
	Key *string `json:"key" tf:"key"`
	// has no documentation
	// +optional
	TagKey *NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey `json:"tagKey,omitempty" tf:"tag_key"`
	// The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionComparisonNumberRequestAttributeSource struct {
	// Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
	// +optional
	ManagementZone *string `json:"managementZone,omitempty" tf:"management_zone"`
	// Use only request attributes from services that have this tag. Use either this or `managementZone`
	// +optional
	ServiceTag *NamingSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag `json:"serviceTag,omitempty" tf:"service_tag"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionComparisonNumberRequestAttribute struct {
	// If `true`, the request attribute is matched on child service calls. Default is `false`
	// +optional
	MatchOnChildCalls *bool `json:"matchOnChildCalls,omitempty" tf:"match_on_child_calls"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// No documentation available for this attribute
	RequestAttribute *string `json:"requestAttribute" tf:"request_attribute"`
	// Defines valid sources of request attributes for conditions or placeholders
	// +optional
	Source *NamingSpecConditionsConditionComparisonNumberRequestAttributeSource `json:"source,omitempty" tf:"source"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *float64 `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []float64 `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonServiceType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonString struct {
	// The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey struct {
	// has no documentation
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// has no documentation
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
}

type NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag struct {
	// The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
	Key *string `json:"key" tf:"key"`
	// has no documentation
	// +optional
	TagKey *NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey `json:"tagKey,omitempty" tf:"tag_key"`
	// The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionComparisonStringRequestAttributeSource struct {
	// Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
	// +optional
	ManagementZone *string `json:"managementZone,omitempty" tf:"management_zone"`
	// Use only request attributes from services that have this tag. Use either this or `managementZone`
	// +optional
	ServiceTag *NamingSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag `json:"serviceTag,omitempty" tf:"service_tag"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecConditionsConditionComparisonStringRequestAttribute struct {
	// The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// If `true`, the request attribute is matched on child service calls. Default is `false`
	// +optional
	MatchOnChildCalls *bool `json:"matchOnChildCalls,omitempty" tf:"match_on_child_calls"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// No documentation available for this attribute
	RequestAttribute *string `json:"requestAttribute" tf:"request_attribute"`
	// Defines valid sources of request attributes for conditions or placeholders
	// +optional
	Source *NamingSpecConditionsConditionComparisonStringRequestAttributeSource `json:"source,omitempty" tf:"source"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionComparisonTagValuesValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionComparisonTagValues struct {
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Value []NamingSpecConditionsConditionComparisonTagValuesValue `json:"value,omitempty" tf:"value"`
}

type NamingSpecConditionsConditionComparisonTag struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `TAG_KEY_EQUALS` and `TAG_KEY_EQUALS_ANY_OF`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The values to compare to
	// +optional
	Value *NamingSpecConditionsConditionComparisonTagValue `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	Values *NamingSpecConditionsConditionComparisonTagValues `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparisonZosCallType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type NamingSpecConditionsConditionComparison struct {
	// Boolean Comparison for `BOOLEAN` attributes
	// +optional
	Boolean *NamingSpecConditionsConditionComparisonBoolean `json:"boolean,omitempty" tf:"boolean"`
	// Type-specific comparison information for attributes of type 'ESB_INPUT_NODE_TYPE'
	// +optional
	EsbInputNodeType *NamingSpecConditionsConditionComparisonEsbInputNodeType `json:"esbInputNodeType,omitempty" tf:"esb_input_node_type"`
	// Comparison for `FAILED_STATE` attributes
	// +optional
	FailedState *NamingSpecConditionsConditionComparisonFailedState `json:"failedState,omitempty" tf:"failed_state"`
	// Comparison for `FAILURE_REASON` attributes
	// +optional
	FailureReason *NamingSpecConditionsConditionComparisonFailureReason `json:"failureReason,omitempty" tf:"failure_reason"`
	// Comparison for `FAST_STRING` attributes. Use it for all service property attributes
	// +optional
	FastString *NamingSpecConditionsConditionComparisonFastString `json:"fastString,omitempty" tf:"fast_string"`
	// Comparison for `FLAW_STATE` attributes
	// +optional
	FlawState *NamingSpecConditionsConditionComparisonFlawState `json:"flawState,omitempty" tf:"flaw_state"`
	// Comparison for `NUMBER` attributes
	// +optional
	Generic *NamingSpecConditionsConditionComparisonGeneric `json:"generic,omitempty" tf:"generic"`
	// Comparison for `HTTP_METHOD` attributes
	// +optional
	HttpMethod *NamingSpecConditionsConditionComparisonHttpMethod `json:"httpMethod,omitempty" tf:"http_method"`
	// Comparison for `HTTP_STATUS_CLASS` attributes
	// +optional
	HttpStatusClass *NamingSpecConditionsConditionComparisonHttpStatusClass `json:"httpStatusClass,omitempty" tf:"http_status_class"`
	// Comparison for `IIB_INPUT_NODE_TYPE` attributes
	// +optional
	IibInputNodeType *NamingSpecConditionsConditionComparisonIibInputNodeType `json:"iibInputNodeType,omitempty" tf:"iib_input_node_type"`
	// Reverse the comparison **operator**. For example, it turns **equals** into **does not equal**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Comparison for `NUMBER` attributes
	// +optional
	Number *NamingSpecConditionsConditionComparisonNumber `json:"number,omitempty" tf:"number"`
	// Comparison for `NUMBER_REQUEST_ATTRIBUTE` attributes
	// +optional
	NumberRequestAttribute *NamingSpecConditionsConditionComparisonNumberRequestAttribute `json:"numberRequestAttribute,omitempty" tf:"number_request_attribute"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	ServiceType *NamingSpecConditionsConditionComparisonServiceType `json:"serviceType,omitempty" tf:"service_type"`
	// Comparison for `STRING` attributes
	// +optional
	String *NamingSpecConditionsConditionComparisonString `json:"string,omitempty" tf:"string"`
	// Comparison for `STRING_REQUEST_ATTRIBUTE` attributes
	// +optional
	StringRequestAttribute *NamingSpecConditionsConditionComparisonStringRequestAttribute `json:"stringRequestAttribute,omitempty" tf:"string_request_attribute"`
	// Comparison for `TAG` attributes
	// +optional
	Tag *NamingSpecConditionsConditionComparisonTag `json:"tag,omitempty" tf:"tag"`
	// Comparison for `ZOS_CALL_TYPE` attributes
	// +optional
	ZosCallType *NamingSpecConditionsConditionComparisonZosCallType `json:"zosCallType,omitempty" tf:"zos_call_type"`
}

type NamingSpecConditionsCondition struct {
	// The attribute to be matched.  Note that for a service property attribute you must use the comparison of the `FAST_STRING` type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
	Attribute *string `json:"attribute" tf:"attribute"`
	// Type-specific comparison for attributes
	Comparison *NamingSpecConditionsConditionComparison `json:"comparison" tf:"comparison"`
}

type NamingSpecConditions struct {
	// A conditions for the metric usage
	// +optional
	// +kubebuilder:validation:MinItems=1
	Condition []NamingSpecConditionsCondition `json:"condition,omitempty" tf:"condition"`
}

type NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey struct {
	// has no documentation
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// has no documentation
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
}

type NamingSpecPlaceholdersPlaceholderSourceServiceTag struct {
	// The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
	Key *string `json:"key" tf:"key"`
	// has no documentation
	// +optional
	TagKey *NamingSpecPlaceholdersPlaceholderSourceServiceTagTagKey `json:"tagKey,omitempty" tf:"tag_key"`
	// The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type NamingSpecPlaceholdersPlaceholderSource struct {
	// Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
	// +optional
	ManagementZone *string `json:"managementZone,omitempty" tf:"management_zone"`
	// Use only request attributes from services that have this tag. Use either this or `managementZone`
	// +optional
	ServiceTag *NamingSpecPlaceholdersPlaceholderSourceServiceTag `json:"serviceTag,omitempty" tf:"service_tag"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingSpecPlaceholdersPlaceholder struct {
	// Which value of the request attribute must be used when it occurs across multiple child requests. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute, when **useFromChildCalls** is `true`. For the `COUNT` aggregation, the **kind** field is not applicable. Possible values are `COUNT`, `FIRST` and `LAST`.
	// +optional
	Aggregation *string `json:"aggregation,omitempty" tf:"aggregation"`
	// The attribute to extract from. You can only use attributes of the **string** type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
	Attribute *string `json:"attribute" tf:"attribute"`
	// Depending on the `kind` value:
	//
	//
	// * `REGEX_EXTRACTION`: The regular expression.
	//
	//
	// * `BETWEEN_DELIMITER`: The opening delimiter string to look for.
	//
	//
	// * All other values: The delimiter string to look for
	// +optional
	DelimiterOrRegex *string `json:"delimiterOrRegex,omitempty" tf:"delimiter_or_regex"`
	// The closing delimiter string to look for. Required if the `kind` value is `BETWEEN_DELIMITER`. Not applicable otherwise
	// +optional
	EndDelimiter *string `json:"endDelimiter,omitempty" tf:"end_delimiter"`
	// The type of extraction. Defines either usage of regular expression (`regex`) or the position of request attribute value to be extracted. When the `attribute` is `SERVICE_REQUEST_ATTRIBUTE` attribute and `aggregation` is `COUNT`, needs to be set to `ORIGINAL_TEXT`. Possible values are 	`AFTER_DELIMITER`, `BEFORE_DELIMITER`, `BETWEEN_DELIMITER`, `ORIGINAL_TEXT` and `REGEX_EXTRACTION`
	Kind *string `json:"kind" tf:"kind"`
	// The name of the placeholder. Use it in the naming pattern as `{name}`
	Name *string `json:"name" tf:"name"`
	// The format of the extracted string. Possible values are `ORIGINAL`, `TO_LOWER_CASE` and `TO_UPPER_CASE`
	// +optional
	Normalization *string `json:"normalization,omitempty" tf:"normalization"`
	// The request attribute to extract from. Required if the `kind` value is `SERVICE_REQUEST_ATTRIBUTE`. Not applicable otherwise
	// +optional
	RequestAttribute *string `json:"requestAttribute,omitempty" tf:"request_attribute"`
	// Defines valid sources of request attributes for conditions or placeholders
	// +optional
	Source *NamingSpecPlaceholdersPlaceholderSource `json:"source,omitempty" tf:"source"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// If `true` request attribute will be taken from a child service call. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute. Defaults to `false`
	// +optional
	UseFromChildCalls *bool `json:"useFromChildCalls,omitempty" tf:"use_from_child_calls"`
}

type NamingSpecPlaceholders struct {
	// A custom placeholder to be used in a dimension value pattern
	// +optional
	// +kubebuilder:validation:MinItems=1
	Placeholder []NamingSpecPlaceholdersPlaceholder `json:"placeholder,omitempty" tf:"placeholder"`
}

type NamingSpec struct {
	State *NamingSpecResource `json:"state,omitempty" tf:"-"`

	Resource NamingSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type NamingSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The set of conditions for the request naming rule usage.
	//
	//  You can specify several conditions. The request has to match **all** the specified conditions for the rule to trigger
	Conditions *NamingSpecConditions `json:"conditions" tf:"conditions"`
	// The rule is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// Specifies the management zones for which this rule should be applied
	// +optional
	// +kubebuilder:validation:MinItems=1
	ManagementZones []string `json:"managementZones,omitempty" tf:"management_zones"`
	// The name to be assigned to matching requests
	NamingPattern *string `json:"namingPattern" tf:"naming_pattern"`
	// The list of custom placeholders to be used in the naming pattern.
	//
	//  It enables you to extract a request attribute value or other request attribute and use it in the request naming pattern.
	// +optional
	Placeholders *NamingSpecPlaceholders `json:"placeholders,omitempty" tf:"placeholders"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type NamingStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// NamingList is a list of Namings
type NamingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Naming CRD objects
	Items []Naming `json:"items,omitempty"`
}
