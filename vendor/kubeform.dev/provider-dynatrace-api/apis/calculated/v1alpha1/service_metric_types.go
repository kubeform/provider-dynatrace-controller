/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ServiceMetric struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServiceMetricSpec   `json:"spec,omitempty"`
	Status            ServiceMetricStatus `json:"status,omitempty"`
}

type ServiceMetricSpecConditionsConditionComparisonBoolean struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *bool `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []bool `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonEsbInputNodeType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonFailedState struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `FAILED` and `FAILED`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `FAILED` and `FAILED`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonFailureReason struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `EXCEPTION_AT_ENTRY_NODE`, `EXCEPTION_ON_ANY_NODE`, `HTTP_CODE` and `REQUEST_ATTRIBUTE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonFastString struct {
	// The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `CONTAINS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonFlawState struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `FLAWED` and `NOT_FLAWED`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonGeneric struct {
	// Defines the actual set of fields depending on the value
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ServiceMetricSpecConditionsConditionComparisonHttpMethod struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CONNECT`, `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, `PUT` and `TRACE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonHttpStatusClass struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `C_1XX`, `C_2XX`, `C_3XX`, `C_4XX`, `C_5XX` and `NO_RESPONSE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonIibInputNodeType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CALLABLE_FLOW_ASYNC_RESPONSE_NODE`, `CALLABLE_FLOW_INPUT_NODE`, `DATABASE_INPUT_NODE`, `DOTNET_INPUT_NODE`, `EMAIL_INPUT_NODE`, `EVENT_INPUT`, `EVENT_INPUT_NODE`, `FILE_INPUT_NODE`, `FTE_INPUT_NODE`, `HTTP_ASYNC_RESPONSE`, `JD_EDWARDS_INPUT_NODE`, `JMS_CLIENT_INPUT_NODE`, `LABEL_NODE`, `MQ_INPUT_NODE`, `PEOPLE_SOFT_INPUT_NODE`, `REST_ASYNC_RESPONSE`, `REST_REQUEST`, `SAP_INPUT_NODE`, `SCA_ASYNC_RESPONSE_NODE`, `SCA_INPUT_NODE`, `SIEBEL_INPUT_NODE`, `SOAP_INPUT_NODE`, `TCPIP_CLIENT_INPUT_NODE`, `TCPIP_CLIENT_REQUEST_NODE`, `TCPIP_SERVER_INPUT_NODE`, `TCPIP_SERVER_REQUEST_NODE`, `TIMEOUT_NOTIFICATION_NODE` and `WS_INPUT_NODE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonNumber struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *float64 `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []float64 `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey struct {
	// has no documentation
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// has no documentation
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
}

type ServiceMetricSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag struct {
	// The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
	Key *string `json:"key" tf:"key"`
	// has no documentation
	// +optional
	TagKey *ServiceMetricSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTagTagKey `json:"tagKey,omitempty" tf:"tag_key"`
	// The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ServiceMetricSpecConditionsConditionComparisonNumberRequestAttributeSource struct {
	// Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
	// +optional
	ManagementZone *string `json:"managementZone,omitempty" tf:"management_zone"`
	// Use only request attributes from services that have this tag. Use either this or `managementZone`
	// +optional
	ServiceTag *ServiceMetricSpecConditionsConditionComparisonNumberRequestAttributeSourceServiceTag `json:"serviceTag,omitempty" tf:"service_tag"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ServiceMetricSpecConditionsConditionComparisonNumberRequestAttribute struct {
	// If `true`, the request attribute is matched on child service calls. Default is `false`
	// +optional
	MatchOnChildCalls *bool `json:"matchOnChildCalls,omitempty" tf:"match_on_child_calls"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `EXISTS`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LOWER_THAN` and `LOWER_THAN_OR_EQUAL`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// No documentation available for this attribute
	RequestAttribute *string `json:"requestAttribute" tf:"request_attribute"`
	// Defines valid sources of request attributes for conditions or placeholders
	// +optional
	Source *ServiceMetricSpecConditionsConditionComparisonNumberRequestAttributeSource `json:"source,omitempty" tf:"source"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *float64 `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []float64 `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonServiceType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `BACKGROUND_ACTIVITY`, `CICS_SERVICE`, `CUSTOM_SERVICE`, `DATABASE_SERVICE`, `ENTERPRISE_SERVICE_BUS_SERVICE`, `EXTERNAL`, `IBM_INTEGRATION_BUS_SERVICE`, `IMS_SERVICE`, `MESSAGING_SERVICE`, `RMI_SERVICE`, `RPC_SERVICE`, `WEB_REQUEST_SERVICE` and `WEB_SERVICE`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonString struct {
	// The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey struct {
	// has no documentation
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// has no documentation
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
}

type ServiceMetricSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag struct {
	// The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
	Key *string `json:"key" tf:"key"`
	// has no documentation
	// +optional
	TagKey *ServiceMetricSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTagTagKey `json:"tagKey,omitempty" tf:"tag_key"`
	// The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ServiceMetricSpecConditionsConditionComparisonStringRequestAttributeSource struct {
	// Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
	// +optional
	ManagementZone *string `json:"managementZone,omitempty" tf:"management_zone"`
	// Use only request attributes from services that have this tag. Use either this or `managementZone`
	// +optional
	ServiceTag *ServiceMetricSpecConditionsConditionComparisonStringRequestAttributeSourceServiceTag `json:"serviceTag,omitempty" tf:"service_tag"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ServiceMetricSpecConditionsConditionComparisonStringRequestAttribute struct {
	// The comparison is case-sensitive (`true`) or not case-sensitive (`false`)
	// +optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive"`
	// If `true`, the request attribute is matched on child service calls. Default is `false`
	// +optional
	MatchOnChildCalls *bool `json:"matchOnChildCalls,omitempty" tf:"match_on_child_calls"`
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `BEGINS_WITH`, `BEGINS_WITH_ANY_OF`, `CONTAINS`, `ENDS_WITH`, `ENDS_WITH_ANY_OF`, `EQUALS`, `EQUALS_ANY_OF`, `EXISTS` and `REGEX_MATCHES`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// No documentation available for this attribute
	RequestAttribute *string `json:"requestAttribute" tf:"request_attribute"`
	// Defines valid sources of request attributes for conditions or placeholders
	// +optional
	Source *ServiceMetricSpecConditionsConditionComparisonStringRequestAttributeSource `json:"source,omitempty" tf:"source"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonTagValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ServiceMetricSpecConditionsConditionComparisonTagValuesValue struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ServiceMetricSpecConditionsConditionComparisonTagValues struct {
	// The values to compare to
	// +optional
	// +kubebuilder:validation:MinItems=1
	Value []ServiceMetricSpecConditionsConditionComparisonTagValuesValue `json:"value,omitempty" tf:"value"`
}

type ServiceMetricSpecConditionsConditionComparisonTag struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF`, `TAG_KEY_EQUALS` and `TAG_KEY_EQUALS_ANY_OF`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The values to compare to
	// +optional
	Value *ServiceMetricSpecConditionsConditionComparisonTagValue `json:"value,omitempty" tf:"value"`
	// The values to compare to
	// +optional
	Values *ServiceMetricSpecConditionsConditionComparisonTagValues `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparisonZosCallType struct {
	// Operator of the comparison. You can reverse it by setting `negate` to `true`. Possible values are `EQUALS`, `EQUALS_ANY_OF` and `EXISTS`
	// +optional
	Operator *string `json:"operator,omitempty" tf:"operator"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
	// The values to compare to. Possible values are `CTG`, `DPL`, `EXPLICIT_ADK`, `IMS_CONNECT`, `IMS_CONNECT_API`, `IMS_ITRA`, `IMS_MSC`, `IMS_PGM_SWITCH`, `IMS_SHARED_QUEUES`, `IMS_TRANS_EXEC`, `MQ`, `SOAP`, `START`, `TX` and `UNKNOWN`
	// +optional
	// +kubebuilder:validation:MinItems=1
	Values []string `json:"values,omitempty" tf:"values"`
}

type ServiceMetricSpecConditionsConditionComparison struct {
	// Boolean Comparison for `BOOLEAN` attributes
	// +optional
	Boolean *ServiceMetricSpecConditionsConditionComparisonBoolean `json:"boolean,omitempty" tf:"boolean"`
	// Type-specific comparison information for attributes of type 'ESB_INPUT_NODE_TYPE'
	// +optional
	EsbInputNodeType *ServiceMetricSpecConditionsConditionComparisonEsbInputNodeType `json:"esbInputNodeType,omitempty" tf:"esb_input_node_type"`
	// Comparison for `FAILED_STATE` attributes
	// +optional
	FailedState *ServiceMetricSpecConditionsConditionComparisonFailedState `json:"failedState,omitempty" tf:"failed_state"`
	// Comparison for `FAILURE_REASON` attributes
	// +optional
	FailureReason *ServiceMetricSpecConditionsConditionComparisonFailureReason `json:"failureReason,omitempty" tf:"failure_reason"`
	// Comparison for `FAST_STRING` attributes. Use it for all service property attributes
	// +optional
	FastString *ServiceMetricSpecConditionsConditionComparisonFastString `json:"fastString,omitempty" tf:"fast_string"`
	// Comparison for `FLAW_STATE` attributes
	// +optional
	FlawState *ServiceMetricSpecConditionsConditionComparisonFlawState `json:"flawState,omitempty" tf:"flaw_state"`
	// Comparison for `NUMBER` attributes
	// +optional
	Generic *ServiceMetricSpecConditionsConditionComparisonGeneric `json:"generic,omitempty" tf:"generic"`
	// Comparison for `HTTP_METHOD` attributes
	// +optional
	HttpMethod *ServiceMetricSpecConditionsConditionComparisonHttpMethod `json:"httpMethod,omitempty" tf:"http_method"`
	// Comparison for `HTTP_STATUS_CLASS` attributes
	// +optional
	HttpStatusClass *ServiceMetricSpecConditionsConditionComparisonHttpStatusClass `json:"httpStatusClass,omitempty" tf:"http_status_class"`
	// Comparison for `IIB_INPUT_NODE_TYPE` attributes
	// +optional
	IibInputNodeType *ServiceMetricSpecConditionsConditionComparisonIibInputNodeType `json:"iibInputNodeType,omitempty" tf:"iib_input_node_type"`
	// Reverse the comparison **operator**. For example, it turns **equals** into **does not equal**
	// +optional
	Negate *bool `json:"negate,omitempty" tf:"negate"`
	// Comparison for `NUMBER` attributes
	// +optional
	Number *ServiceMetricSpecConditionsConditionComparisonNumber `json:"number,omitempty" tf:"number"`
	// Comparison for `NUMBER_REQUEST_ATTRIBUTE` attributes
	// +optional
	NumberRequestAttribute *ServiceMetricSpecConditionsConditionComparisonNumberRequestAttribute `json:"numberRequestAttribute,omitempty" tf:"number_request_attribute"`
	// Comparison for `SERVICE_TYPE` attributes
	// +optional
	ServiceType *ServiceMetricSpecConditionsConditionComparisonServiceType `json:"serviceType,omitempty" tf:"service_type"`
	// Comparison for `STRING` attributes
	// +optional
	String *ServiceMetricSpecConditionsConditionComparisonString `json:"string,omitempty" tf:"string"`
	// Comparison for `STRING_REQUEST_ATTRIBUTE` attributes
	// +optional
	StringRequestAttribute *ServiceMetricSpecConditionsConditionComparisonStringRequestAttribute `json:"stringRequestAttribute,omitempty" tf:"string_request_attribute"`
	// Comparison for `TAG` attributes
	// +optional
	Tag *ServiceMetricSpecConditionsConditionComparisonTag `json:"tag,omitempty" tf:"tag"`
	// Comparison for `ZOS_CALL_TYPE` attributes
	// +optional
	ZosCallType *ServiceMetricSpecConditionsConditionComparisonZosCallType `json:"zosCallType,omitempty" tf:"zos_call_type"`
}

type ServiceMetricSpecConditionsCondition struct {
	// The attribute to be matched.  Note that for a service property attribute you must use the comparison of the `FAST_STRING` type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
	Attribute *string `json:"attribute" tf:"attribute"`
	// Type-specific comparison for attributes
	Comparison *ServiceMetricSpecConditionsConditionComparison `json:"comparison" tf:"comparison"`
}

type ServiceMetricSpecConditions struct {
	// A conditions for the metric usage
	// +optional
	// +kubebuilder:validation:MinItems=1
	Condition []ServiceMetricSpecConditionsCondition `json:"condition,omitempty" tf:"condition"`
}

type ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey struct {
	// has no documentation
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// has no documentation
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
}

type ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag struct {
	// The origin of the tag, such as AWS or Cloud Foundry. For custom tags use the `CONTEXTLESS` value. The context is set for tags that are automatically imported by OneAgent (for example, from the AWS console or environment variables). It’s useful for determining the origin of tags when not manually defined, and it also helps to prevent clashes with other existing tags. If the tag is not automatically imported, `CONTEXTLESS` set. Possible values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_COMPUTE_ENGINE` and `KUBERNETES`
	// +optional
	Context *string `json:"context,omitempty" tf:"context"`
	// The key of the tag. For custom tags, put the tag value here. The key allows categorization of multiple tags. It is possible that there are multiple values for a single key which will all be represented as standalone tags. Therefore, the key does not have the semantic of a map key but is more like a key of a key-value tuple. In some cases, for example custom tags, the key represents the actual tag value and the value field is not set – those are called valueless tags
	Key *string `json:"key" tf:"key"`
	// has no documentation
	// +optional
	TagKey *ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholderSourceServiceTagTagKey `json:"tagKey,omitempty" tf:"tag_key"`
	// The value of the tag. Not applicable to custom tags. If a tag does have a separate key and value (in the textual representation they are split by the colon ‘:’), this field is set with the actual value. Key-value pairs can occur for automatically imported tags and tags set by rules if extractors are used
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholderSource struct {
	// Use only request attributes from services that belong to this management zone.. Use either this or `serviceTag`
	// +optional
	ManagementZone *string `json:"managementZone,omitempty" tf:"management_zone"`
	// Use only request attributes from services that have this tag. Use either this or `managementZone`
	// +optional
	ServiceTag *ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholderSourceServiceTag `json:"serviceTag,omitempty" tf:"service_tag"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholder struct {
	// Which value of the request attribute must be used when it occurs across multiple child requests. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute, when **useFromChildCalls** is `true`. For the `COUNT` aggregation, the **kind** field is not applicable. Possible values are `COUNT`, `FIRST` and `LAST`.
	// +optional
	Aggregation *string `json:"aggregation,omitempty" tf:"aggregation"`
	// The attribute to extract from. You can only use attributes of the **string** type. Possible values are `ACTOR_SYSTEM`, `AKKA_ACTOR_CLASS_NAME`, `AKKA_ACTOR_MESSAGE_TYPE`, `AKKA_ACTOR_PATH`, `APPLICATION_BUILD_VERSION`, `APPLICATION_RELEASE_VERSION`, `AZURE_FUNCTIONS_FUNCTION_NAME`, `AZURE_FUNCTIONS_SITE_NAME`, `CICS_PROGRAM_NAME`, `CICS_SYSTEM_ID`, `CICS_TASK_ID`, `CICS_TRANSACTION_ID`, `CICS_USER_ID`, `CPU_TIME`, `CTG_GATEWAY_URL`, `CTG_PROGRAM`, `CTG_SERVER_NAME`, `CTG_TRANSACTION_ID`, `CUSTOMSERVICE_CLASS`, `CUSTOMSERVICE_METHOD`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DATABASE_HOST`, `DATABASE_NAME`, `DATABASE_TYPE`, `DATABASE_URL`, `DISK_IO_TIME`, `ERROR_COUNT`, `ESB_APPLICATION_NAME`, `ESB_INPUT_TYPE`, `ESB_LIBRARY_NAME`, `ESB_MESSAGE_FLOW_NAME`, `EXCEPTION_CLASS`, `EXCEPTION_MESSAGE`, `FAILED_STATE`, `FAILURE_REASON`, `FLAW_STATE`, `HTTP_REQUEST_METHOD`, `HTTP_STATUS`, `HTTP_STATUS_CLASS`, `IMS_PROGRAM_NAME`, `IMS_TRANSACTION_ID`, `IMS_USER_ID`, `IO_TIME`, `IS_KEY_REQUEST`, `LAMBDA_COLDSTART`, `LOCK_TIME`, `MESSAGING_DESTINATION_TYPE`, `MESSAGING_IS_TEMPORARY_QUEUE`, `MESSAGING_QUEUE_NAME`, `MESSAGING_QUEUE_VENDOR`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESS_GROUP_NAME`, `PROCESS_GROUP_TAG`, `REMOTE_ENDPOINT`, `REMOTE_METHOD`, `REMOTE_SERVICE_NAME`, `REQUEST_NAME`, `REQUEST_TYPE`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `RMI_CLASS`, `RMI_METHOD`, `SERVICE_DISPLAY_NAME`, `SERVICE_NAME`, `SERVICE_PORT`, `SERVICE_PUBLIC_DOMAIN_NAME`, `SERVICE_REQUEST_ATTRIBUTE`, `SERVICE_TAG`, `SERVICE_TYPE`, `SERVICE_WEB_APPLICATION_ID`, `SERVICE_WEB_CONTEXT_ROOT`, `SERVICE_WEB_SERVER_NAME`, `SERVICE_WEB_SERVICE_NAME`, `SERVICE_WEB_SERVICE_NAMESPACE`, `SUSPENSION_TIME`, `TOTAL_PROCESSING_TIME`, `WAIT_TIME`, `WEBREQUEST_QUERY`, `WEBREQUEST_RELATIVE_URL`, `WEBREQUEST_URL`, `WEBREQUEST_URL_HOST`, `WEBREQUEST_URL_PATH`, `WEBREQUEST_URL_PORT`, `WEBSERVICE_ENDPOINT`, `WEBSERVICE_METHOD` and `ZOS_CALL_TYPE`
	Attribute *string `json:"attribute" tf:"attribute"`
	// Depending on the `kind` value:
	//
	//
	// * `REGEX_EXTRACTION`: The regular expression.
	//
	//
	// * `BETWEEN_DELIMITER`: The opening delimiter string to look for.
	//
	//
	// * All other values: The delimiter string to look for
	// +optional
	DelimiterOrRegex *string `json:"delimiterOrRegex,omitempty" tf:"delimiter_or_regex"`
	// The closing delimiter string to look for. Required if the `kind` value is `BETWEEN_DELIMITER`. Not applicable otherwise
	// +optional
	EndDelimiter *string `json:"endDelimiter,omitempty" tf:"end_delimiter"`
	// The type of extraction. Defines either usage of regular expression (`regex`) or the position of request attribute value to be extracted. When the `attribute` is `SERVICE_REQUEST_ATTRIBUTE` attribute and `aggregation` is `COUNT`, needs to be set to `ORIGINAL_TEXT`. Possible values are 	`AFTER_DELIMITER`, `BEFORE_DELIMITER`, `BETWEEN_DELIMITER`, `ORIGINAL_TEXT` and `REGEX_EXTRACTION`
	Kind *string `json:"kind" tf:"kind"`
	// The name of the placeholder. Use it in the naming pattern as `{name}`
	Name *string `json:"name" tf:"name"`
	// The format of the extracted string. Possible values are `ORIGINAL`, `TO_LOWER_CASE` and `TO_UPPER_CASE`
	// +optional
	Normalization *string `json:"normalization,omitempty" tf:"normalization"`
	// The request attribute to extract from. Required if the `kind` value is `SERVICE_REQUEST_ATTRIBUTE`. Not applicable otherwise
	// +optional
	RequestAttribute *string `json:"requestAttribute,omitempty" tf:"request_attribute"`
	// Defines valid sources of request attributes for conditions or placeholders
	// +optional
	Source *ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholderSource `json:"source,omitempty" tf:"source"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// If `true` request attribute will be taken from a child service call. Only applicable for the `SERVICE_REQUEST_ATTRIBUTE` attribute. Defaults to `false`
	// +optional
	UseFromChildCalls *bool `json:"useFromChildCalls,omitempty" tf:"use_from_child_calls"`
}

type ServiceMetricSpecDimensionDefinitionPlaceholders struct {
	// A custom placeholder to be used in a dimension value pattern
	// +optional
	// +kubebuilder:validation:MinItems=1
	Placeholder []ServiceMetricSpecDimensionDefinitionPlaceholdersPlaceholder `json:"placeholder,omitempty" tf:"placeholder"`
}

type ServiceMetricSpecDimensionDefinition struct {
	// The dimension value pattern. You can define custom placeholders in the `placeholders` field and use them here
	Dimension *string `json:"dimension" tf:"dimension"`
	// The name of the dimension
	Name *string `json:"name" tf:"name"`
	// The list of custom placeholders to be used in a dimension value pattern
	// +optional
	Placeholders *ServiceMetricSpecDimensionDefinitionPlaceholders `json:"placeholders,omitempty" tf:"placeholders"`
	// The number of top values to be calculated
	TopX *int64 `json:"topX" tf:"top_x"`
	// The aggregation of the dimension. Possible values are `AVERAGE`, `COUNT`, `MAX`, `MIN`, `OF_INTEREST_RATIO`, `OTHER_RATIO`, `SINGLE_VALUE` and `SUM`
	TopXAggregation *string `json:"topXAggregation" tf:"top_x_aggregation"`
	// How to calculate the **topX** values. Possible values are `ASCENDING` and `DESCENDING`
	TopXDirection *string `json:"topXDirection" tf:"top_x_direction"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ServiceMetricSpecMetricDefinition struct {
	// The metric to be captured. Possible values are `CPU_TIME`, `DATABASE_CHILD_CALL_COUNT`, `DATABASE_CHILD_CALL_TIME`, `DISK_IO_TIME`, `EXCEPTION_COUNT`, `FAILED_REQUEST_COUNT`, `FAILED_REQUEST_COUNT_CLIENT`, `FAILURE_RATE`, `FAILURE_RATE_CLIENT`, `HTTP_4XX_ERROR_COUNT`, `HTTP_4XX_ERROR_COUNT_CLIENT`, `HTTP_5XX_ERROR_COUNT`, `HTTP_5XX_ERROR_COUNT_CLIENT`, `IO_TIME`, `LOCK_TIME`, `NETWORK_IO_TIME`, `NON_DATABASE_CHILD_CALL_COUNT`, `NON_DATABASE_CHILD_CALL_TIME`, `PROCESSING_TIME`, `REQUEST_ATTRIBUTE`, `REQUEST_COUNT`, `RESPONSE_TIME`, `RESPONSE_TIME_CLIENT`, `SUCCESSFUL_REQUEST_COUNT`, `SUCCESSFUL_REQUEST_COUNT_CLIENT` and `WAIT_TIME`
	Metric *string `json:"metric" tf:"metric"`
	// The request attribute to be captured. Only applicable when the **metric** parameter is set to `REQUEST_ATTRIBUTE`
	// +optional
	RequestAttribute *string `json:"requestAttribute,omitempty" tf:"request_attribute"`
}

type ServiceMetricSpec struct {
	State *ServiceMetricSpecResource `json:"state,omitempty" tf:"-"`

	Resource ServiceMetricSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type ServiceMetricSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The set of conditions for the metric usage. **All** the specified conditions must be fulfilled to use the metric
	// +optional
	// +kubebuilder:validation:MinItems=1
	Conditions []ServiceMetricSpecConditions `json:"conditions,omitempty" tf:"conditions"`
	// Parameters of a definition of a calculated service metric
	// +optional
	DimensionDefinition *ServiceMetricSpecDimensionDefinition `json:"dimensionDefinition,omitempty" tf:"dimension_definition"`
	// The metric is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// Restricts the metric usage to the specified service. This field is mutually exclusive with the `management_zones` field
	// +optional
	EntityID *string `json:"entityID,omitempty" tf:"entity_id"`
	// Restricts the metric usage to specified management zones. This field is mutually exclusive with the `entity_id` field
	// +optional
	ManagementZones []string `json:"managementZones,omitempty" tf:"management_zones"`
	// The definition of a calculated service metric
	// +optional
	MetricDefinition *ServiceMetricSpecMetricDefinition `json:"metricDefinition,omitempty" tf:"metric_definition"`
	// The key of the calculated service metric
	MetricKey *string `json:"metricKey" tf:"metric_key"`
	// The displayed name of the metric
	Name *string `json:"name" tf:"name"`
	// The unit of the metric. Possible values are `BIT`, `BIT_PER_HOUR`, `BIT_PER_MINUTE`, `BIT_PER_SECOND`, `BYTE`, `BYTE_PER_HOUR`, `BYTE_PER_MINUTE`, `BYTE_PER_SECOND`, `CORES`, `COUNT`, `DAY`, `DECIBEL_MILLI_WATT`, `GIBI_BYTE`, `GIGA`, `GIGA_BYTE`, `HOUR`, `KIBI_BYTE`, `KIBI_BYTE_PER_HOUR`, `KIBI_BYTE_PER_MINUTE`, `KIBI_BYTE_PER_SECOND`, `KILO`, `KILO_BYTE`, `KILO_BYTE_PER_HOUR`, `KILO_BYTE_PER_MINUTE`, `KILO_BYTE_PER_SECOND`, `MEBI_BYTE`, `MEBI_BYTE_PER_HOUR`, `MEBI_BYTE_PER_MINUTE`, `MEBI_BYTE_PER_SECOND`, `MEGA`, `MEGA_BYTE`, `MEGA_BYTE_PER_HOUR`, `MEGA_BYTE_PER_MINUTE`, `MEGA_BYTE_PER_SECOND`, `MICRO_SECOND`, `MILLI_CORES`, `MILLI_SECOND`, `MILLI_SECOND_PER_MINUTE`, `MINUTE`, `MONTH`, `MSU`, `NANO_SECOND`, `NANO_SECOND_PER_MINUTE`, `NOT_APPLICABLE`, `PERCENT`, `PER_HOUR`, `PER_MINUTE`, `PER_SECOND`, `PIXEL`, `PROMILLE`, `RATIO`, `SECOND`, `STATE`, `UNSPECIFIED`, `WEEK` and `YEAR`
	Unit *string `json:"unit" tf:"unit"`
	// The display name of the metric's unit. Only applicable when the **unit** parameter is set to `UNSPECIFIED`
	// +optional
	UnitDisplayName *string `json:"unitDisplayName,omitempty" tf:"unit_display_name"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type ServiceMetricStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ServiceMetricList is a list of ServiceMetrics
type ServiceMetricList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ServiceMetric CRD objects
	Items []ServiceMetric `json:"items,omitempty"`
}
