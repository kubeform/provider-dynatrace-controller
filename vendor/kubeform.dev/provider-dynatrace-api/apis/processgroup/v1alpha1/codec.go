/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1()):                NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1()):             NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1()):                               NamingSpecConditionsConditionHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1()):                             NamingSpecConditionsConditionIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1()):                   NamingSpecConditionsConditionIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1()):               NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1()):                   NamingSpecConditionsConditionSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1()):                                    NamingSpecConditionsConditionTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1()):                          NamingSpecConditionsConditionTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1()):                                   NamingSpecConditionsConditionTechValueCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1()):                NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1()):    NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1()):             NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1()): NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1()):                               NamingSpecConditionsConditionHostTechValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1()):                             NamingSpecConditionsConditionIndexedTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1()):                   NamingSpecConditionsConditionIndexedTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1()):               NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1()):                   NamingSpecConditionsConditionSimpleTechComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1()):                                    NamingSpecConditionsConditionTagValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1()):                          NamingSpecConditionsConditionTagComparisonValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1()):                                   NamingSpecConditionsConditionTechValueCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomHostMetadataDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomHostMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomHostMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomHostMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomHostMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomHostMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomProcessMetadataDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomProcessMetadataDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomProcessMetadataDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec struct {
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) == nil
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr)
	var objs []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey
	if obj != nil {
		objs = []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
			}
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey)(ptr) = NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionCustomProcessMetadataConditionKeyDynamicKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionHostTechValueCodec struct {
}

func (NamingSpecConditionsConditionHostTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionHostTechValue)(ptr) == nil
}

func (NamingSpecConditionsConditionHostTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionHostTechValue)(ptr)
	var objs []NamingSpecConditionsConditionHostTechValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionHostTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionHostTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionHostTechValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionHostTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionHostTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionHostTechValue)(ptr) = NamingSpecConditionsConditionHostTechValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionHostTechValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionIndexedTagValueCodec struct {
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionIndexedTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionIndexedTagValue)(ptr)
	var objs []NamingSpecConditionsConditionIndexedTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionIndexedTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionIndexedTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionIndexedTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionIndexedTagValue)(ptr) = NamingSpecConditionsConditionIndexedTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionIndexedTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionIndexedTagComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionIndexedTagComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionIndexedTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionIndexedTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionIndexedTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionIndexedTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionIndexedTagComparisonValue)(ptr) = NamingSpecConditionsConditionIndexedTagComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionIndexedTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionSimpleHostTechComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionSimpleHostTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionSimpleHostTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionSimpleHostTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleHostTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionSimpleHostTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleHostTechComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionSimpleHostTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionSimpleTechComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionSimpleTechComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionSimpleTechComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionSimpleTechComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionSimpleTechComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionSimpleTechComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionSimpleTechComparisonValue)(ptr) = NamingSpecConditionsConditionSimpleTechComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionSimpleTechComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTagValueCodec struct {
}

func (NamingSpecConditionsConditionTagValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTagValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTagValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTagValue)(ptr)
	var objs []NamingSpecConditionsConditionTagValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTagValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTagValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTagValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTagValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTagValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTagValue)(ptr) = NamingSpecConditionsConditionTagValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTagValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTagComparisonValueCodec struct {
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTagComparisonValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTagComparisonValue)(ptr)
	var objs []NamingSpecConditionsConditionTagComparisonValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTagComparisonValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTagComparisonValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTagComparisonValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTagComparisonValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTagComparisonValue)(ptr) = NamingSpecConditionsConditionTagComparisonValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTagComparisonValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NamingSpecConditionsConditionTechValueCodec struct {
}

func (NamingSpecConditionsConditionTechValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NamingSpecConditionsConditionTechValue)(ptr) == nil
}

func (NamingSpecConditionsConditionTechValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NamingSpecConditionsConditionTechValue)(ptr)
	var objs []NamingSpecConditionsConditionTechValue
	if obj != nil {
		objs = []NamingSpecConditionsConditionTechValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NamingSpecConditionsConditionTechValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NamingSpecConditionsConditionTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NamingSpecConditionsConditionTechValue)(ptr) = objs[0]
			} else {
				*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
			}
		} else {
			*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj NamingSpecConditionsConditionTechValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NamingSpecConditionsConditionTechValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*NamingSpecConditionsConditionTechValue)(ptr) = obj
		} else {
			*(*NamingSpecConditionsConditionTechValue)(ptr) = NamingSpecConditionsConditionTechValue{}
		}
	default:
		iter.ReportError("decode NamingSpecConditionsConditionTechValue", "unexpected JSON type")
	}
}
