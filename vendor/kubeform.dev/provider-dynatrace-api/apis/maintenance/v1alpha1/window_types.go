/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Window struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WindowSpec   `json:"spec,omitempty"`
	Status            WindowStatus `json:"status,omitempty"`
}

type WindowSpecMetadata struct {
	// Dynatrace server version
	// +optional
	ClusterVersion *string `json:"clusterVersion,omitempty" tf:"cluster_version"`
	// A Sorted list of the version numbers of the configuration
	// +optional
	ConfigurationVersions []int64 `json:"configurationVersions,omitempty" tf:"configuration_versions"`
	// A Sorted list of the version numbers of the configuration
	// +optional
	CurrentConfigurationVersions []string `json:"currentConfigurationVersions,omitempty" tf:"current_configuration_versions"`
}

type WindowSpecScheduleRecurrence struct {
	// The day of the month for monthly maintenance.  The value of `31` is treated as the last day of the month for months that don't have a 31st day. The value of `30` is also treated as the last day of the month for February
	// +optional
	DayOfMonth *int64 `json:"dayOfMonth,omitempty" tf:"day_of_month"`
	// The day of the week for weekly maintenance.  The format is the full name of the day in upper case, for example `THURSDAY`
	// +optional
	DayOfWeek *string `json:"dayOfWeek,omitempty" tf:"day_of_week"`
	// The duration of the maintenance window in minutes
	DurationMinutes *int64 `json:"durationMinutes" tf:"duration_minutes"`
	// The start time of the maintenance window in HH:mm format
	StartTime *string `json:"startTime" tf:"start_time"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type WindowSpecSchedule struct {
	// The end date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
	End *string `json:"end" tf:"end"`
	// The recurrence of the maintenance window
	// +optional
	Recurrence *WindowSpecScheduleRecurrence `json:"recurrence,omitempty" tf:"recurrence"`
	// The type of the schedule recurrence. Possible values are `DAILY`, `MONTHLY`, `ONCE` and `WEEKLY`
	RecurrenceType *string `json:"recurrenceType" tf:"recurrence_type"`
	// The start date and time of the maintenance window validity period in yyyy-mm-dd HH:mm format
	Start *string `json:"start" tf:"start"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The time zone of the start and end time. Default time zone is UTC. You can use either UTC offset `UTC+01:00` format or the IANA Time Zone Database format (for example, `Europe/Vienna`)
	ZoneID *string `json:"zoneID" tf:"zone_id"`
}

type WindowSpecScopeMatchesTags struct {
	// The origin of the tag, such as AWS or Cloud Foundry. Custom tags use the `CONTEXTLESS` value
	Context *string `json:"context" tf:"context"`
	// The key of the tag. Custom tags have the tag value here
	Key *string `json:"key" tf:"key"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
	// The value of the tag. Not applicable to custom tags
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type WindowSpecScopeMatches struct {
	// The ID of a management zone to which the matched entities must belong
	// +optional
	MzID *string `json:"mzID,omitempty" tf:"mz_id"`
	// The logic that applies when several tags are specified: AND/OR.  If not set, the OR logic is used
	// +optional
	TagCombination *string `json:"tagCombination,omitempty" tf:"tag_combination"`
	// The tag you want to use for matching.  You can use custom tags from the UI, AWS tags, Cloud Foundry tags, OpenShift/Kubernetes, and tags based on environment variables
	// +optional
	// +kubebuilder:validation:MinItems=1
	Tags []WindowSpecScopeMatchesTags `json:"tags,omitempty" tf:"tags"`
	// The type of the Dynatrace entities (for example, hosts or services) you want to pick up by matching
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type WindowSpecScope struct {
	// A list of Dynatrace entities (for example, hosts or services) to be included in the scope.  Allowed values are Dynatrace entity IDs
	// +optional
	Entities []string `json:"entities,omitempty" tf:"entities"`
	// A list of matching rules for dynamic scope formation.  If several rules are set, the OR logic applies
	// +optional
	// +kubebuilder:validation:MinItems=1
	Matches []WindowSpecScopeMatches `json:"matches,omitempty" tf:"matches"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type WindowSpec struct {
	State *WindowSpecResource `json:"state,omitempty" tf:"-"`

	Resource WindowSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type WindowSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// A short description of the maintenance purpose
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// `metadata` exists for backwards compatibility but shouldn't get specified anymore
	// +optional
	// Deprecated
	Metadata *WindowSpecMetadata `json:"metadata,omitempty" tf:"metadata"`
	// The name of the maintenance window, displayed in the UI
	Name *string `json:"name" tf:"name"`
	// The schedule of the maintenance window
	// +optional
	Schedule *WindowSpecSchedule `json:"schedule,omitempty" tf:"schedule"`
	// the tiles this Dashboard consist of
	// +optional
	Scope *WindowSpecScope `json:"scope,omitempty" tf:"scope"`
	// Suppress execution of synthetic monitors during the maintenance
	// +optional
	SuppressSynthMonExec *bool `json:"suppressSynthMonExec,omitempty" tf:"suppress_synth_mon_exec"`
	// The type of suppression of alerting and problem detection during the maintenance
	Suppression *string `json:"suppression" tf:"suppression"`
	// The type of the maintenance: planned or unplanned
	Type *string `json:"type" tf:"type"`
	// allows for configuring properties that are not explicitly supported by the current version of this provider
	// +optional
	Unknowns *string `json:"unknowns,omitempty" tf:"unknowns"`
}

type WindowStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// WindowList is a list of Windows
type WindowList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Window CRD objects
	Items []Window `json:"items,omitempty"`
}
