/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Monitor struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitorSpec   `json:"spec,omitempty"`
	Status            MonitorStatus `json:"status,omitempty"`
}

type MonitorSpecAnomalyDetectionLoadingTimeThresholdsThresholdsThreshold struct {
	// Specify the event to which an ACTION threshold applies
	// +optional
	EventIndex *int64 `json:"eventIndex,omitempty" tf:"event_index"`
	// Specify the request to which an ACTION threshold applies
	// +optional
	RequestIndex *int64 `json:"requestIndex,omitempty" tf:"request_index"`
	// The type of the threshold: `TOTAL` (total loading time) or `ACTION` (action loading time)
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Notify if monitor takes longer than *X* milliseconds to load
	ValueMs *int64 `json:"valueMs" tf:"value_ms"`
}

type MonitorSpecAnomalyDetectionLoadingTimeThresholdsThresholds struct {
	// The list of performance threshold rules
	// +kubebuilder:validation:MinItems=1
	Threshold []MonitorSpecAnomalyDetectionLoadingTimeThresholdsThresholdsThreshold `json:"threshold" tf:"threshold"`
}

type MonitorSpecAnomalyDetectionLoadingTimeThresholds struct {
	// Performance threshold is enabled (`true`) or disabled (`false`)
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// The list of performance threshold rules
	// +optional
	Thresholds []MonitorSpecAnomalyDetectionLoadingTimeThresholdsThresholds `json:"thresholds,omitempty" tf:"thresholds"`
}

type MonitorSpecAnomalyDetectionOutageHandlingLocalOutagePolicy struct {
	// The number of affected locations to trigger an alert
	AffectedLocations *int64 `json:"affectedLocations" tf:"affected_locations"`
	// The number of consecutive fails to trigger an alert
	ConsecutiveRuns *int64 `json:"consecutiveRuns" tf:"consecutive_runs"`
}

type MonitorSpecAnomalyDetectionOutageHandling struct {
	// When enabled (`true`), generate a problem and send an alert when the monitor is unavailable at all configured locations
	// +optional
	GlobalOutage *bool `json:"globalOutage,omitempty" tf:"global_outage"`
	// When enabled (`true`), generate a problem and send an alert when the monitor is unavailable for one or more consecutive runs at any location
	// +optional
	LocalOutage *bool `json:"localOutage,omitempty" tf:"local_outage"`
	// Local outage handling configuration.
	//
	//  Alert if **affectedLocations** of locations are unable to access the web application **consecutiveRuns** times consecutively
	// +optional
	LocalOutagePolicy []MonitorSpecAnomalyDetectionOutageHandlingLocalOutagePolicy `json:"localOutagePolicy,omitempty" tf:"local_outage_policy"`
	// Schedule retry if browser monitor execution results in a fail. For HTTP monitors this property is ignored
	// +optional
	RetryOnError *bool `json:"retryOnError,omitempty" tf:"retry_on_error"`
}

type MonitorSpecAnomalyDetection struct {
	// Thresholds for loading times
	// +optional
	LoadingTimeThresholds []MonitorSpecAnomalyDetectionLoadingTimeThresholds `json:"loadingTimeThresholds,omitempty" tf:"loading_time_thresholds"`
	// Outage handling configuration
	// +optional
	OutageHandling []MonitorSpecAnomalyDetectionOutageHandling `json:"outageHandling,omitempty" tf:"outage_handling"`
}

type MonitorSpecKeyPerformanceMetrics struct {
	// Defines the key performance metric for load actions. Supported values are `VISUALLY_COMPLETE`, `SPEED_INDEX`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE`, `HTML_DOWNLOADED`, `DOM_INTERACTIVE`, `LOAD_EVENT_START` and `LOAD_EVENT_END`.
	LoadActionKpm *string `json:"loadActionKpm" tf:"load_action_kpm"`
	// Defines the key performance metric for XHR actions. Supported values are `VISUALLY_COMPLETE`, `USER_ACTION_DURATION`, `TIME_TO_FIRST_BYTE` and `RESPONSE_END`.
	XhrActionKpm *string `json:"xhrActionKpm" tf:"xhr_action_kpm"`
}

type MonitorSpecScriptConfigurationBandwidth struct {
	// The download speed of the network, in bytes per second
	// +optional
	Download *int64 `json:"download,omitempty" tf:"download"`
	// The latency of the network, in milliseconds
	// +optional
	Latency *int64 `json:"latency,omitempty" tf:"latency"`
	// The type of the preconfigured network—when editing in the browser, press `Crtl+Spacebar` to see the list of available networks
	// +optional
	NetworkType *string `json:"networkType,omitempty" tf:"network_type"`
	// The upload speed of the network, in bytes per second
	// +optional
	Upload *int64 `json:"upload,omitempty" tf:"upload"`
}

type MonitorSpecScriptConfigurationCookiesCookie struct {
	// The domain of the cookie.
	Domain *string `json:"domain" tf:"domain"`
	// The name of the cookie. The following cookie names are now allowed: `dtCookie`, `dtLatC`, `dtPC`, `rxVisitor`, `rxlatency`, `rxpc`, `rxsession` and `rxvt`
	Name *string `json:"name" tf:"name"`
	// The path of the cookie.
	// +optional
	Path *string `json:"path,omitempty" tf:"path"`
	// The value of the cookie. The following symbols are not allowed: `;`, `,`, `\` and `"`.
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptConfigurationCookies struct {
	// A request cookie
	// +kubebuilder:validation:MinItems=1
	Cookie []MonitorSpecScriptConfigurationCookiesCookie `json:"cookie" tf:"cookie"`
}

type MonitorSpecScriptConfigurationDevice struct {
	// The height of the screen in pixels.
	// The maximum allowed width is `1080`.
	// +optional
	Height *int64 `json:"height,omitempty" tf:"height"`
	// The flag of the mobile device.
	// Set to `true` for mobile devices or `false` for a desktop or laptop.
	// +optional
	Mobile *bool `json:"mobile,omitempty" tf:"mobile"`
	// The name of the preconfigured device—when editing in the browser, press `Crtl+Spacebar` to see the list of available devices
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// The orientation of the device. Possible values are `portrait` or `landscape`. Desktop and laptop devices are not allowed to use the `portrait` orientation
	// +optional
	Orientation *string `json:"orientation,omitempty" tf:"orientation"`
	// The pixel ratio of the device.
	// +optional
	ScaleFactor *int64 `json:"scaleFactor,omitempty" tf:"scale_factor"`
	// The flag of the touchscreen.
	// Set to `true` if the device uses touchscreen. In that case, use can set interaction event as `tap`.
	// +optional
	TouchEnabled *bool `json:"touchEnabled,omitempty" tf:"touch_enabled"`
	// The width of the screen in pixels.
	// The maximum allowed width is `1920`.
	// +optional
	Width *int64 `json:"width,omitempty" tf:"width"`
}

type MonitorSpecScriptConfigurationHeadersHeader struct {
	// The key of the header
	Name *string `json:"name" tf:"name"`
	// The value of the header
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptConfigurationHeaders struct {
	// contains an HTTP header of the request
	// +kubebuilder:validation:MinItems=1
	Header []MonitorSpecScriptConfigurationHeadersHeader `json:"header" tf:"header"`
	// Restrict applying headers to a set of URLs
	// +optional
	Restrictions []string `json:"restrictions,omitempty" tf:"restrictions"`
}

type MonitorSpecScriptConfigurationIgnoredErrorCodes struct {
	// Only apply to document request matching this regex
	// +optional
	MatchingDocumentRequests *string `json:"matchingDocumentRequests,omitempty" tf:"matching_document_requests"`
	// You can use exact number, range or status class mask. Multiple values can be separated by comma, i.e. 404, 405-410, 5xx
	StatusCodes *string `json:"statusCodes" tf:"status_codes"`
}

type MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings struct {
	// Track up to n cascading setTimeout calls
	ActionLimit *int64 `json:"actionLimit" tf:"action_limit"`
	// Limit cascading timeouts cumulatively to n ms
	TotalTimeout *int64 `json:"totalTimeout" tf:"total_timeout"`
}

type MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions struct {
	// Query CSS selectors to specify mutation nodes (elements that change) to ignore in Visually complete and Speed index calculation
	// +optional
	ExcludedElements []string `json:"excludedElements,omitempty" tf:"excluded_elements"`
	// Parameters for Visually complete and Speed index calculation
	// +optional
	ExcludedUrls []string `json:"excludedUrls,omitempty" tf:"excluded_urls"`
	// Use this setting to define the minimum visible area per element (in pixels) for an element to be counted towards Visually complete and Speed index
	ImageSizeThreshold *int64 `json:"imageSizeThreshold" tf:"image_size_threshold"`
	// The time the Visually complete module waits for inactivity and no further mutations on the page after the load action
	InactivityTimeout *int64 `json:"inactivityTimeout" tf:"inactivity_timeout"`
	// The time the Visually complete module waits after an XHR or custom action closes to start the calculation
	MutationTimeout *int64 `json:"mutationTimeout" tf:"mutation_timeout"`
}

type MonitorSpecScriptConfigurationJavascriptSetttings struct {
	// Additional Javascript Agent Properties
	// +optional
	CustomProperties *string `json:"customProperties,omitempty" tf:"custom_properties"`
	// Custom JavaScript Agent settings
	// +optional
	TimeoutSettings *MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings `json:"timeoutSettings,omitempty" tf:"timeout_settings"`
	// Parameters for Visually complete and Speed index calculation
	// +optional
	VisuallyCompleteOptions *MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions `json:"visuallyCompleteOptions,omitempty" tf:"visually_complete_options"`
}

type MonitorSpecScriptConfiguration struct {
	// The emulated device of the monitor—holds either the parameters of the custom device or the name and orientation of the preconfigured device.
	//
	// If not set, then the Desktop preconfigured device is used
	// +optional
	Bandwidth *MonitorSpecScriptConfigurationBandwidth `json:"bandwidth,omitempty" tf:"bandwidth"`
	// Block these URLs
	// +optional
	// +kubebuilder:validation:MinItems=1
	Block []string `json:"block,omitempty" tf:"block"`
	// Bypass Content Security Policy of monitored pages
	// +optional
	BypassCsp *bool `json:"bypassCsp,omitempty" tf:"bypass_csp"`
	// These cookies are added before execution of the first step
	// +optional
	Cookies *MonitorSpecScriptConfigurationCookies `json:"cookies,omitempty" tf:"cookies"`
	// The emulated device of the monitor—holds either the parameters of the custom device or the name and orientation of the preconfigured device.
	//
	// If not set, then the Desktop preconfigured device is used
	// +optional
	Device *MonitorSpecScriptConfigurationDevice `json:"device,omitempty" tf:"device"`
	// No documentation available
	// +optional
	DisableWebSecurity *bool `json:"disableWebSecurity,omitempty" tf:"disable_web_security"`
	// The list of HTTP headers to be sent with requests of the monitor
	// +optional
	Headers *MonitorSpecScriptConfigurationHeaders `json:"headers,omitempty" tf:"headers"`
	// Ignore specific status codes
	// +optional
	IgnoredErrorCodes *MonitorSpecScriptConfigurationIgnoredErrorCodes `json:"ignoredErrorCodes,omitempty" tf:"ignored_error_codes"`
	// Custom JavaScript Agent settings
	// +optional
	JavascriptSetttings *MonitorSpecScriptConfigurationJavascriptSetttings `json:"javascriptSetttings,omitempty" tf:"javascript_setttings"`
	// Capture performance metrics for pages loaded in frames
	// +optional
	MonitorFrames *bool `json:"monitorFrames,omitempty" tf:"monitor_frames"`
	// The user agent of the request
	// +optional
	UserAgent *string `json:"userAgent,omitempty" tf:"user_agent"`
}

type MonitorSpecScriptEventsEventClickTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventClickTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventClickTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventClickTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventClickTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventClickValidateValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventClickValidateValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventClickValidateValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventClickValidateValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventClickValidateValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventClickValidateValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventClickValidateValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventClickValidate struct {
	// The element to wait for. Required for the `validation` type, not applicable otherwise.
	// +kubebuilder:validation:MinItems=1
	Validation []MonitorSpecScriptEventsEventClickValidateValidation `json:"validation" tf:"validation"`
}

type MonitorSpecScriptEventsEventClickWaitValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventClickWaitValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventClickWaitValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventClickWaitValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventClickWaitValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventClickWaitValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventClickWaitValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventClickWait struct {
	// The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
	// +optional
	Milliseconds *int64 `json:"milliseconds,omitempty" tf:"milliseconds"`
	// he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
	// The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
	// The elements to wait for. Required for the `validation` type, not applicable otherwise.
	// +optional
	Validation *MonitorSpecScriptEventsEventClickWaitValidation `json:"validation,omitempty" tf:"validation"`
	// The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
	WaitFor *string `json:"waitFor" tf:"wait_for"`
}

type MonitorSpecScriptEventsEventClick struct {
	// the mouse button to be used for the click
	Button *int64 `json:"button" tf:"button"`
	// The tab on which the page should open
	// +optional
	Target *MonitorSpecScriptEventsEventClickTarget `json:"target,omitempty" tf:"target"`
	// The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
	// +optional
	Validate *MonitorSpecScriptEventsEventClickValidate `json:"validate,omitempty" tf:"validate"`
	// The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
	// +optional
	Wait *MonitorSpecScriptEventsEventClickWait `json:"wait,omitempty" tf:"wait"`
}

type MonitorSpecScriptEventsEventCookieCookiesCookie struct {
	// The domain of the cookie.
	Domain *string `json:"domain" tf:"domain"`
	// The name of the cookie. The following cookie names are now allowed: `dtCookie`, `dtLatC`, `dtPC`, `rxVisitor`, `rxlatency`, `rxpc`, `rxsession` and `rxvt`
	Name *string `json:"name" tf:"name"`
	// The path of the cookie.
	// +optional
	Path *string `json:"path,omitempty" tf:"path"`
	// The value of the cookie. The following symbols are not allowed: `;`, `,`, `\` and `"`.
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventCookieCookies struct {
	// A request cookie
	// +kubebuilder:validation:MinItems=1
	Cookie []MonitorSpecScriptEventsEventCookieCookiesCookie `json:"cookie" tf:"cookie"`
}

type MonitorSpecScriptEventsEventCookie struct {
	// Every cookie must be unique within the list. However, you can use the same cookie again in other event
	Cookies *MonitorSpecScriptEventsEventCookieCookies `json:"cookies" tf:"cookies"`
}

type MonitorSpecScriptEventsEventJavascriptTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventJavascriptTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventJavascriptTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventJavascriptTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventJavascriptTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventJavascriptWaitValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventJavascriptWaitValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventJavascriptWaitValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventJavascriptWaitValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventJavascriptWaitValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventJavascriptWaitValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventJavascriptWaitValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventJavascriptWait struct {
	// The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
	// +optional
	Milliseconds *int64 `json:"milliseconds,omitempty" tf:"milliseconds"`
	// he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
	// The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
	// The elements to wait for. Required for the `validation` type, not applicable otherwise.
	// +optional
	Validation *MonitorSpecScriptEventsEventJavascriptWaitValidation `json:"validation,omitempty" tf:"validation"`
	// The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
	WaitFor *string `json:"waitFor" tf:"wait_for"`
}

type MonitorSpecScriptEventsEventJavascript struct {
	// The JavaScript code to be executed in this event
	Code *string `json:"code" tf:"code"`
	// The tab on which the page should open
	// +optional
	Target *MonitorSpecScriptEventsEventJavascriptTarget `json:"target,omitempty" tf:"target"`
	// The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
	// +optional
	Wait *MonitorSpecScriptEventsEventJavascriptWait `json:"wait,omitempty" tf:"wait"`
}

type MonitorSpecScriptEventsEventKeystrokesTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventKeystrokesTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventKeystrokesTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventKeystrokesTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventKeystrokesTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventKeystrokesValidateValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventKeystrokesValidate struct {
	// The element to wait for. Required for the `validation` type, not applicable otherwise.
	// +kubebuilder:validation:MinItems=1
	Validation []MonitorSpecScriptEventsEventKeystrokesValidateValidation `json:"validation" tf:"validation"`
}

type MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventKeystrokesWaitValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventKeystrokesWait struct {
	// The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
	// +optional
	Milliseconds *int64 `json:"milliseconds,omitempty" tf:"milliseconds"`
	// he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
	// The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
	// The elements to wait for. Required for the `validation` type, not applicable otherwise.
	// +optional
	Validation *MonitorSpecScriptEventsEventKeystrokesWaitValidation `json:"validation,omitempty" tf:"validation"`
	// The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
	WaitFor *string `json:"waitFor" tf:"wait_for"`
}

type MonitorSpecScriptEventsEventKeystrokes struct {
	// Indicates whether the `textValue` is encrypted (`true`) or not (`false`)
	// +optional
	Masked *bool `json:"masked,omitempty" tf:"masked"`
	// Defines whether to blur the text field when it loses focus.
	// Set to `true` to trigger the blur the `textValue`
	// +optional
	SimulateBlurEvent *bool `json:"simulateBlurEvent,omitempty" tf:"simulate_blur_event"`
	// The tab on which the page should open
	// +optional
	Target *MonitorSpecScriptEventsEventKeystrokesTarget `json:"target,omitempty" tf:"target"`
	// The text to enter
	Text *string `json:"text" tf:"text"`
	// The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
	// +optional
	Validate *MonitorSpecScriptEventsEventKeystrokesValidate `json:"validate,omitempty" tf:"validate"`
	// The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
	// +optional
	Wait *MonitorSpecScriptEventsEventKeystrokesWait `json:"wait,omitempty" tf:"wait"`
}

type MonitorSpecScriptEventsEventNavigateAuthentication struct {
	// A reference to the entry within the credential vault
	Creds *string `json:"creds" tf:"creds"`
	// The type of authentication
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventNavigateTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventNavigateTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventNavigateTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventNavigateTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventNavigateTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventNavigateValidateValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventNavigateValidateValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventNavigateValidateValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventNavigateValidateValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventNavigateValidateValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventNavigateValidateValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventNavigateValidateValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventNavigateValidate struct {
	// The element to wait for. Required for the `validation` type, not applicable otherwise.
	// +kubebuilder:validation:MinItems=1
	Validation []MonitorSpecScriptEventsEventNavigateValidateValidation `json:"validation" tf:"validation"`
}

type MonitorSpecScriptEventsEventNavigateWaitValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventNavigateWaitValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventNavigateWaitValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventNavigateWaitValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventNavigateWaitValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventNavigateWaitValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventNavigateWaitValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventNavigateWait struct {
	// The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
	// +optional
	Milliseconds *int64 `json:"milliseconds,omitempty" tf:"milliseconds"`
	// he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
	// The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
	// The elements to wait for. Required for the `validation` type, not applicable otherwise.
	// +optional
	Validation *MonitorSpecScriptEventsEventNavigateWaitValidation `json:"validation,omitempty" tf:"validation"`
	// The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
	WaitFor *string `json:"waitFor" tf:"wait_for"`
}

type MonitorSpecScriptEventsEventNavigate struct {
	// The login credentials to bypass the browser login mask
	// +optional
	Authentication *MonitorSpecScriptEventsEventNavigateAuthentication `json:"authentication,omitempty" tf:"authentication"`
	// The tab on which the page should open
	// +optional
	Target *MonitorSpecScriptEventsEventNavigateTarget `json:"target,omitempty" tf:"target"`
	// The URL to navigate to
	Url *string `json:"url" tf:"url"`
	// The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
	// +optional
	Validate *MonitorSpecScriptEventsEventNavigateValidate `json:"validate,omitempty" tf:"validate"`
	// The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
	// +optional
	Wait *MonitorSpecScriptEventsEventNavigateWait `json:"wait,omitempty" tf:"wait"`
}

type MonitorSpecScriptEventsEventSelectSelectionsOption struct {
	// The index of the option to be selected
	Index *int64 `json:"index" tf:"index"`
	// The value of the option to be selected
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventSelectSelections struct {
	// The option to be selected
	// +kubebuilder:validation:MinItems=1
	Option []MonitorSpecScriptEventsEventSelectSelectionsOption `json:"option" tf:"option"`
}

type MonitorSpecScriptEventsEventSelectTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventSelectTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventSelectTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventSelectTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventSelectTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventSelectValidateValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventSelectValidateValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventSelectValidateValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventSelectValidateValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventSelectValidateValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventSelectValidateValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventSelectValidateValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventSelectValidate struct {
	// The element to wait for. Required for the `validation` type, not applicable otherwise.
	// +kubebuilder:validation:MinItems=1
	Validation []MonitorSpecScriptEventsEventSelectValidateValidation `json:"validation" tf:"validation"`
}

type MonitorSpecScriptEventsEventSelectWaitValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventSelectWaitValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventSelectWaitValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventSelectWaitValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventSelectWaitValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventSelectWaitValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventSelectWaitValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventSelectWait struct {
	// The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
	// +optional
	Milliseconds *int64 `json:"milliseconds,omitempty" tf:"milliseconds"`
	// he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
	// The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
	// The elements to wait for. Required for the `validation` type, not applicable otherwise.
	// +optional
	Validation *MonitorSpecScriptEventsEventSelectWaitValidation `json:"validation,omitempty" tf:"validation"`
	// The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
	WaitFor *string `json:"waitFor" tf:"wait_for"`
}

type MonitorSpecScriptEventsEventSelect struct {
	// The options to be selected
	Selections *MonitorSpecScriptEventsEventSelectSelections `json:"selections" tf:"selections"`
	// The tab on which the page should open
	// +optional
	Target *MonitorSpecScriptEventsEventSelectTarget `json:"target,omitempty" tf:"target"`
	// The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
	// +optional
	Validate *MonitorSpecScriptEventsEventSelectValidate `json:"validate,omitempty" tf:"validate"`
	// The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
	// +optional
	Wait *MonitorSpecScriptEventsEventSelectWait `json:"wait,omitempty" tf:"wait"`
}

type MonitorSpecScriptEventsEventTapTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventTapTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventTapTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventTapTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventTapTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventTapValidateValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventTapValidateValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventTapValidateValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventTapValidateValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventTapValidateValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventTapValidateValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventTapValidateValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventTapValidate struct {
	// The element to wait for. Required for the `validation` type, not applicable otherwise.
	// +kubebuilder:validation:MinItems=1
	Validation []MonitorSpecScriptEventsEventTapValidateValidation `json:"validation" tf:"validation"`
}

type MonitorSpecScriptEventsEventTapWaitValidationTargetLocatorsLocator struct {
	// Defines where to look for an element. `css` (CSS Selector) or `dom` (Javascript code)
	Type *string `json:"type" tf:"type"`
	// The name of the element to be found
	Value *string `json:"value" tf:"value"`
}

type MonitorSpecScriptEventsEventTapWaitValidationTargetLocators struct {
	// A locator dentifyies the desired element
	// +kubebuilder:validation:MinItems=1
	Locator []MonitorSpecScriptEventsEventTapWaitValidationTargetLocatorsLocator `json:"locator" tf:"locator"`
}

type MonitorSpecScriptEventsEventTapWaitValidationTarget struct {
	// The list of locators identifying the desired element
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locators []MonitorSpecScriptEventsEventTapWaitValidationTargetLocators `json:"locators,omitempty" tf:"locators"`
	// The tab of the target
	// +optional
	Window *string `json:"window,omitempty" tf:"window"`
}

type MonitorSpecScriptEventsEventTapWaitValidation struct {
	// The condition of the validation. `false` means the validation succeeds if the specified content/element is found. `true` means the validation fails if the specified content/element is found
	// +optional
	FailIfFound *bool `json:"failIfFound,omitempty" tf:"fail_if_found"`
	// The content to look for on the page.
	// Regular expressions are allowed. In that case set `isRegex` as `true`. Required for `content_match`, optional for `element_match`.
	// +optional
	Match *string `json:"match,omitempty" tf:"match"`
	// Defines whether `match` is plain text (`false`) or a regular expression (`true`)
	// +optional
	Regex *bool `json:"regex,omitempty" tf:"regex"`
	// The elemnt to look for on the page
	// +optional
	Target *MonitorSpecScriptEventsEventTapWaitValidationTarget `json:"target,omitempty" tf:"target"`
	// The goal of the validation. `content_match` (check page for the specific content. Not allowed for validation inside of wait condition), `element_match` (check page for the specific element).
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecScriptEventsEventTapWait struct {
	// The time to wait, in millisencods. The maximum allowed value is `60000`. Required for the type `time`, not applicable otherwise.
	// +optional
	Milliseconds *int64 `json:"milliseconds,omitempty" tf:"milliseconds"`
	// he maximum amount of time to wait for a certain element to appear, in milliseconds—if exceeded, the action is marked as failed.
	// The maximum allowed value is 60000. Required for the type `validation`, not applicable otherwise..
	// +optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout"`
	// The elements to wait for. Required for the `validation` type, not applicable otherwise.
	// +optional
	Validation *MonitorSpecScriptEventsEventTapWaitValidation `json:"validation,omitempty" tf:"validation"`
	// The time to wait before the next event is triggered. Possible values are `page_complete` (wait for the page to load completely), `network` (wait for background network activity to complete), `next_action` (wait for the next action), `time` (wait for a specified periodof time) and `validation` (wait for a specific element to appear)
	WaitFor *string `json:"waitFor" tf:"wait_for"`
}

type MonitorSpecScriptEventsEventTap struct {
	// the mouse button to be used for the click
	Button *int64 `json:"button" tf:"button"`
	// The tab on which the page should open
	// +optional
	Target *MonitorSpecScriptEventsEventTapTarget `json:"target,omitempty" tf:"target"`
	// The validation rules for the event—helps you verify that your browser monitor loads the expected page content or page element
	// +optional
	Validate *MonitorSpecScriptEventsEventTapValidate `json:"validate,omitempty" tf:"validate"`
	// The wait condition for the event—defines how long Dynatrace should wait before the next action is executed
	// +optional
	Wait *MonitorSpecScriptEventsEventTapWait `json:"wait,omitempty" tf:"wait"`
}

type MonitorSpecScriptEventsEvent struct {
	// Properties specified for a click event
	// +optional
	Click *MonitorSpecScriptEventsEventClick `json:"click,omitempty" tf:"click"`
	// Properties specified for a cookie event
	// +optional
	Cookie *MonitorSpecScriptEventsEventCookie `json:"cookie,omitempty" tf:"cookie"`
	// A short description of the event to appear in the UI
	Description *string `json:"description" tf:"description"`
	// Properties specified for a javascript event
	// +optional
	Javascript *MonitorSpecScriptEventsEventJavascript `json:"javascript,omitempty" tf:"javascript"`
	// Properties specified for a key strokes event
	// +optional
	Keystrokes *MonitorSpecScriptEventsEventKeystrokes `json:"keystrokes,omitempty" tf:"keystrokes"`
	// Properties specified for a navigation event
	// +optional
	Navigate *MonitorSpecScriptEventsEventNavigate `json:"navigate,omitempty" tf:"navigate"`
	// Properties specified for a key strokes event.
	// +optional
	Select *MonitorSpecScriptEventsEventSelect `json:"select,omitempty" tf:"select"`
	// Properties specified for a tap event
	// +optional
	Tap *MonitorSpecScriptEventsEventTap `json:"tap,omitempty" tf:"tap"`
}

type MonitorSpecScriptEvents struct {
	// An event
	// +optional
	Event []MonitorSpecScriptEventsEvent `json:"event,omitempty" tf:"event"`
}

type MonitorSpecScript struct {
	// The setup of the monitor
	// +optional
	Configuration *MonitorSpecScriptConfiguration `json:"configuration,omitempty" tf:"configuration"`
	// Steps of the clickpath—the first step must always be of the `navigate` type
	// +optional
	Events *MonitorSpecScriptEvents `json:"events,omitempty" tf:"events"`
	// The type of monitor. Possible values are `clickpath` for clickpath monitors and `availability` for single-URL browser monitors. These monitors are only allowed to have one event of the `navigate` type
	Type *string `json:"type" tf:"type"`
}

type MonitorSpecTagsTag struct {
	// The origin of the tag. Supported values are `AWS`, `AWS_GENERIC`, `AZURE`, `CLOUD_FOUNDRY`, `CONTEXTLESS`, `ENVIRONMENT`, `GOOGLE_CLOUD` and `KUBERNETES`.
	//
	// Custom tags use the `CONTEXTLESS` value.
	Context *string `json:"context" tf:"context"`
	// The key of the tag.
	//
	// Custom tags have the tag value here.
	Key *string `json:"key" tf:"key"`
	// The source of the tag. Supported values are `USER`, `RULE_BASED` and `AUTO`.
	// +optional
	Source *string `json:"source,omitempty" tf:"source"`
	//  The value of the tag.
	//
	// Not applicable to custom tags.
	// +optional
	Value *string `json:"value,omitempty" tf:"value"`
}

type MonitorSpecTags struct {
	// Tag with source of a Dynatrace entity.
	// +optional
	Tag []MonitorSpecTagsTag `json:"tag,omitempty" tf:"tag"`
}

type MonitorSpec struct {
	State *MonitorSpecResource `json:"state,omitempty" tf:"-"`

	Resource MonitorSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type MonitorSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// The anomaly detection configuration.
	// +optional
	AnomalyDetection *MonitorSpecAnomalyDetection `json:"anomalyDetection,omitempty" tf:"anomaly_detection"`
	// The monitor is enabled (`true`) or disabled (`false`).
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// The frequency of the monitor, in minutes.
	//
	// You can use one of the following values: `5`, `10`, `15`, `30`, and `60`.
	Frequency *int64 `json:"frequency" tf:"frequency"`
	// The key performance metrics configuration
	// +optional
	KeyPerformanceMetrics *MonitorSpecKeyPerformanceMetrics `json:"keyPerformanceMetrics,omitempty" tf:"key_performance_metrics"`
	// A list of locations from which the monitor is executed.
	//
	// To specify a location, use its entity ID.
	// +optional
	// +kubebuilder:validation:MinItems=1
	Locations []string `json:"locations,omitempty" tf:"locations"`
	// A set of manually assigned applications.
	// +optional
	// +kubebuilder:validation:MinItems=1
	ManuallyAssignedApps []string `json:"manuallyAssignedApps,omitempty" tf:"manually_assigned_apps"`
	// The name of the monitor.
	Name *string `json:"name" tf:"name"`
	// The Browser Script
	// +optional
	Script *MonitorSpecScript `json:"script,omitempty" tf:"script"`
	// A set of tags assigned to the monitor.
	//
	// You can specify only the value of the tag here and the `CONTEXTLESS` context and source 'USER' will be added automatically.
	// +optional
	Tags []MonitorSpecTags `json:"tags,omitempty" tf:"tags"`
}

type MonitorStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// MonitorList is a list of Monitors
type MonitorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Monitor CRD objects
	Items []Monitor `json:"items,omitempty"`
}
