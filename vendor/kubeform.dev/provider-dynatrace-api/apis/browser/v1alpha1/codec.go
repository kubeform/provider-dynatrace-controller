/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecAnomalyDetection{}).Type1()):                                              MonitorSpecAnomalyDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecKeyPerformanceMetrics{}).Type1()):                                         MonitorSpecKeyPerformanceMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScript{}).Type1()):                                                        MonitorSpecScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfiguration{}).Type1()):                                           MonitorSpecScriptConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationBandwidth{}).Type1()):                                  MonitorSpecScriptConfigurationBandwidthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationCookies{}).Type1()):                                    MonitorSpecScriptConfigurationCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationDevice{}).Type1()):                                     MonitorSpecScriptConfigurationDeviceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationHeaders{}).Type1()):                                    MonitorSpecScriptConfigurationHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationIgnoredErrorCodes{}).Type1()):                          MonitorSpecScriptConfigurationIgnoredErrorCodesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttings{}).Type1()):                        MonitorSpecScriptConfigurationJavascriptSetttingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}).Type1()):         MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}).Type1()): MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEvents{}).Type1()):                                                  MonitorSpecScriptEventsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClick{}).Type1()):                                        MonitorSpecScriptEventsEventClickCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickTarget{}).Type1()):                                  MonitorSpecScriptEventsEventClickTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidate{}).Type1()):                                MonitorSpecScriptEventsEventClickValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidateValidationTarget{}).Type1()):                MonitorSpecScriptEventsEventClickValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWait{}).Type1()):                                    MonitorSpecScriptEventsEventClickWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidation{}).Type1()):                          MonitorSpecScriptEventsEventClickWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidationTarget{}).Type1()):                    MonitorSpecScriptEventsEventClickWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookie{}).Type1()):                                       MonitorSpecScriptEventsEventCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookieCookies{}).Type1()):                                MonitorSpecScriptEventsEventCookieCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascript{}).Type1()):                                   MonitorSpecScriptEventsEventJavascriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptTarget{}).Type1()):                             MonitorSpecScriptEventsEventJavascriptTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWait{}).Type1()):                               MonitorSpecScriptEventsEventJavascriptWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidation{}).Type1()):                     MonitorSpecScriptEventsEventJavascriptWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}).Type1()):               MonitorSpecScriptEventsEventJavascriptWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokes{}).Type1()):                                   MonitorSpecScriptEventsEventKeystrokesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesTarget{}).Type1()):                             MonitorSpecScriptEventsEventKeystrokesTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidate{}).Type1()):                           MonitorSpecScriptEventsEventKeystrokesValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}).Type1()):           MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWait{}).Type1()):                               MonitorSpecScriptEventsEventKeystrokesWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidation{}).Type1()):                     MonitorSpecScriptEventsEventKeystrokesWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}).Type1()):               MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigate{}).Type1()):                                     MonitorSpecScriptEventsEventNavigateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateAuthentication{}).Type1()):                       MonitorSpecScriptEventsEventNavigateAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateTarget{}).Type1()):                               MonitorSpecScriptEventsEventNavigateTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidate{}).Type1()):                             MonitorSpecScriptEventsEventNavigateValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}).Type1()):             MonitorSpecScriptEventsEventNavigateValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWait{}).Type1()):                                 MonitorSpecScriptEventsEventNavigateWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidation{}).Type1()):                       MonitorSpecScriptEventsEventNavigateWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}).Type1()):                 MonitorSpecScriptEventsEventNavigateWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelect{}).Type1()):                                       MonitorSpecScriptEventsEventSelectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectSelections{}).Type1()):                             MonitorSpecScriptEventsEventSelectSelectionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectTarget{}).Type1()):                                 MonitorSpecScriptEventsEventSelectTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidate{}).Type1()):                               MonitorSpecScriptEventsEventSelectValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidateValidationTarget{}).Type1()):               MonitorSpecScriptEventsEventSelectValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWait{}).Type1()):                                   MonitorSpecScriptEventsEventSelectWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidation{}).Type1()):                         MonitorSpecScriptEventsEventSelectWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidationTarget{}).Type1()):                   MonitorSpecScriptEventsEventSelectWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTap{}).Type1()):                                          MonitorSpecScriptEventsEventTapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapTarget{}).Type1()):                                    MonitorSpecScriptEventsEventTapTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidate{}).Type1()):                                  MonitorSpecScriptEventsEventTapValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidateValidationTarget{}).Type1()):                  MonitorSpecScriptEventsEventTapValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWait{}).Type1()):                                      MonitorSpecScriptEventsEventTapWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidation{}).Type1()):                            MonitorSpecScriptEventsEventTapWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidationTarget{}).Type1()):                      MonitorSpecScriptEventsEventTapWaitValidationTargetCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecAnomalyDetection{}).Type1()):                                              MonitorSpecAnomalyDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecKeyPerformanceMetrics{}).Type1()):                                         MonitorSpecKeyPerformanceMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScript{}).Type1()):                                                        MonitorSpecScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfiguration{}).Type1()):                                           MonitorSpecScriptConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationBandwidth{}).Type1()):                                  MonitorSpecScriptConfigurationBandwidthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationCookies{}).Type1()):                                    MonitorSpecScriptConfigurationCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationDevice{}).Type1()):                                     MonitorSpecScriptConfigurationDeviceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationHeaders{}).Type1()):                                    MonitorSpecScriptConfigurationHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationIgnoredErrorCodes{}).Type1()):                          MonitorSpecScriptConfigurationIgnoredErrorCodesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttings{}).Type1()):                        MonitorSpecScriptConfigurationJavascriptSetttingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}).Type1()):         MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}).Type1()): MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEvents{}).Type1()):                                                  MonitorSpecScriptEventsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClick{}).Type1()):                                        MonitorSpecScriptEventsEventClickCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickTarget{}).Type1()):                                  MonitorSpecScriptEventsEventClickTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidate{}).Type1()):                                MonitorSpecScriptEventsEventClickValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidateValidationTarget{}).Type1()):                MonitorSpecScriptEventsEventClickValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWait{}).Type1()):                                    MonitorSpecScriptEventsEventClickWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidation{}).Type1()):                          MonitorSpecScriptEventsEventClickWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidationTarget{}).Type1()):                    MonitorSpecScriptEventsEventClickWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookie{}).Type1()):                                       MonitorSpecScriptEventsEventCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookieCookies{}).Type1()):                                MonitorSpecScriptEventsEventCookieCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascript{}).Type1()):                                   MonitorSpecScriptEventsEventJavascriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptTarget{}).Type1()):                             MonitorSpecScriptEventsEventJavascriptTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWait{}).Type1()):                               MonitorSpecScriptEventsEventJavascriptWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidation{}).Type1()):                     MonitorSpecScriptEventsEventJavascriptWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}).Type1()):               MonitorSpecScriptEventsEventJavascriptWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokes{}).Type1()):                                   MonitorSpecScriptEventsEventKeystrokesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesTarget{}).Type1()):                             MonitorSpecScriptEventsEventKeystrokesTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidate{}).Type1()):                           MonitorSpecScriptEventsEventKeystrokesValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}).Type1()):           MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWait{}).Type1()):                               MonitorSpecScriptEventsEventKeystrokesWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidation{}).Type1()):                     MonitorSpecScriptEventsEventKeystrokesWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}).Type1()):               MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigate{}).Type1()):                                     MonitorSpecScriptEventsEventNavigateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateAuthentication{}).Type1()):                       MonitorSpecScriptEventsEventNavigateAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateTarget{}).Type1()):                               MonitorSpecScriptEventsEventNavigateTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidate{}).Type1()):                             MonitorSpecScriptEventsEventNavigateValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}).Type1()):             MonitorSpecScriptEventsEventNavigateValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWait{}).Type1()):                                 MonitorSpecScriptEventsEventNavigateWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidation{}).Type1()):                       MonitorSpecScriptEventsEventNavigateWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}).Type1()):                 MonitorSpecScriptEventsEventNavigateWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelect{}).Type1()):                                       MonitorSpecScriptEventsEventSelectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectSelections{}).Type1()):                             MonitorSpecScriptEventsEventSelectSelectionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectTarget{}).Type1()):                                 MonitorSpecScriptEventsEventSelectTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidate{}).Type1()):                               MonitorSpecScriptEventsEventSelectValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidateValidationTarget{}).Type1()):               MonitorSpecScriptEventsEventSelectValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWait{}).Type1()):                                   MonitorSpecScriptEventsEventSelectWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidation{}).Type1()):                         MonitorSpecScriptEventsEventSelectWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidationTarget{}).Type1()):                   MonitorSpecScriptEventsEventSelectWaitValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTap{}).Type1()):                                          MonitorSpecScriptEventsEventTapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapTarget{}).Type1()):                                    MonitorSpecScriptEventsEventTapTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidate{}).Type1()):                                  MonitorSpecScriptEventsEventTapValidateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidateValidationTarget{}).Type1()):                  MonitorSpecScriptEventsEventTapValidateValidationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWait{}).Type1()):                                      MonitorSpecScriptEventsEventTapWaitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidation{}).Type1()):                            MonitorSpecScriptEventsEventTapWaitValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidationTarget{}).Type1()):                      MonitorSpecScriptEventsEventTapWaitValidationTargetCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type MonitorSpecAnomalyDetectionCodec struct {
}

func (MonitorSpecAnomalyDetectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecAnomalyDetection)(ptr) == nil
}

func (MonitorSpecAnomalyDetectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecAnomalyDetection)(ptr)
	var objs []MonitorSpecAnomalyDetection
	if obj != nil {
		objs = []MonitorSpecAnomalyDetection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecAnomalyDetection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecAnomalyDetectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecAnomalyDetection)(ptr) = MonitorSpecAnomalyDetection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecAnomalyDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecAnomalyDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecAnomalyDetection)(ptr) = objs[0]
			} else {
				*(*MonitorSpecAnomalyDetection)(ptr) = MonitorSpecAnomalyDetection{}
			}
		} else {
			*(*MonitorSpecAnomalyDetection)(ptr) = MonitorSpecAnomalyDetection{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecAnomalyDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecAnomalyDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecAnomalyDetection)(ptr) = obj
		} else {
			*(*MonitorSpecAnomalyDetection)(ptr) = MonitorSpecAnomalyDetection{}
		}
	default:
		iter.ReportError("decode MonitorSpecAnomalyDetection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecKeyPerformanceMetricsCodec struct {
}

func (MonitorSpecKeyPerformanceMetricsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecKeyPerformanceMetrics)(ptr) == nil
}

func (MonitorSpecKeyPerformanceMetricsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecKeyPerformanceMetrics)(ptr)
	var objs []MonitorSpecKeyPerformanceMetrics
	if obj != nil {
		objs = []MonitorSpecKeyPerformanceMetrics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecKeyPerformanceMetrics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecKeyPerformanceMetricsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecKeyPerformanceMetrics)(ptr) = MonitorSpecKeyPerformanceMetrics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecKeyPerformanceMetrics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecKeyPerformanceMetrics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecKeyPerformanceMetrics)(ptr) = objs[0]
			} else {
				*(*MonitorSpecKeyPerformanceMetrics)(ptr) = MonitorSpecKeyPerformanceMetrics{}
			}
		} else {
			*(*MonitorSpecKeyPerformanceMetrics)(ptr) = MonitorSpecKeyPerformanceMetrics{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecKeyPerformanceMetrics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecKeyPerformanceMetrics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecKeyPerformanceMetrics)(ptr) = obj
		} else {
			*(*MonitorSpecKeyPerformanceMetrics)(ptr) = MonitorSpecKeyPerformanceMetrics{}
		}
	default:
		iter.ReportError("decode MonitorSpecKeyPerformanceMetrics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptCodec struct {
}

func (MonitorSpecScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScript)(ptr) == nil
}

func (MonitorSpecScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScript)(ptr)
	var objs []MonitorSpecScript
	if obj != nil {
		objs = []MonitorSpecScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScript)(ptr) = MonitorSpecScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScript)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScript)(ptr) = MonitorSpecScript{}
			}
		} else {
			*(*MonitorSpecScript)(ptr) = MonitorSpecScript{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScript)(ptr) = obj
		} else {
			*(*MonitorSpecScript)(ptr) = MonitorSpecScript{}
		}
	default:
		iter.ReportError("decode MonitorSpecScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationCodec struct {
}

func (MonitorSpecScriptConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfiguration)(ptr) == nil
}

func (MonitorSpecScriptConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfiguration)(ptr)
	var objs []MonitorSpecScriptConfiguration
	if obj != nil {
		objs = []MonitorSpecScriptConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfiguration)(ptr) = MonitorSpecScriptConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfiguration)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfiguration)(ptr) = MonitorSpecScriptConfiguration{}
			}
		} else {
			*(*MonitorSpecScriptConfiguration)(ptr) = MonitorSpecScriptConfiguration{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfiguration)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfiguration)(ptr) = MonitorSpecScriptConfiguration{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationBandwidthCodec struct {
}

func (MonitorSpecScriptConfigurationBandwidthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationBandwidth)(ptr) == nil
}

func (MonitorSpecScriptConfigurationBandwidthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationBandwidth)(ptr)
	var objs []MonitorSpecScriptConfigurationBandwidth
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationBandwidth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationBandwidth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationBandwidthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationBandwidth)(ptr) = MonitorSpecScriptConfigurationBandwidth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationBandwidth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationBandwidth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationBandwidth)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationBandwidth)(ptr) = MonitorSpecScriptConfigurationBandwidth{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationBandwidth)(ptr) = MonitorSpecScriptConfigurationBandwidth{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationBandwidth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationBandwidth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationBandwidth)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationBandwidth)(ptr) = MonitorSpecScriptConfigurationBandwidth{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationBandwidth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationCookiesCodec struct {
}

func (MonitorSpecScriptConfigurationCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationCookies)(ptr) == nil
}

func (MonitorSpecScriptConfigurationCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationCookies)(ptr)
	var objs []MonitorSpecScriptConfigurationCookies
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationCookies)(ptr) = MonitorSpecScriptConfigurationCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationCookies)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationCookies)(ptr) = MonitorSpecScriptConfigurationCookies{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationCookies)(ptr) = MonitorSpecScriptConfigurationCookies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationCookies)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationCookies)(ptr) = MonitorSpecScriptConfigurationCookies{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationDeviceCodec struct {
}

func (MonitorSpecScriptConfigurationDeviceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationDevice)(ptr) == nil
}

func (MonitorSpecScriptConfigurationDeviceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationDevice)(ptr)
	var objs []MonitorSpecScriptConfigurationDevice
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationDevice{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationDevice{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationDeviceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationDevice)(ptr) = MonitorSpecScriptConfigurationDevice{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationDevice

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationDevice{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationDevice)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationDevice)(ptr) = MonitorSpecScriptConfigurationDevice{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationDevice)(ptr) = MonitorSpecScriptConfigurationDevice{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationDevice

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationDevice{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationDevice)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationDevice)(ptr) = MonitorSpecScriptConfigurationDevice{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationDevice", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationHeadersCodec struct {
}

func (MonitorSpecScriptConfigurationHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationHeaders)(ptr) == nil
}

func (MonitorSpecScriptConfigurationHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationHeaders)(ptr)
	var objs []MonitorSpecScriptConfigurationHeaders
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationHeaders)(ptr) = MonitorSpecScriptConfigurationHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationHeaders)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationHeaders)(ptr) = MonitorSpecScriptConfigurationHeaders{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationHeaders)(ptr) = MonitorSpecScriptConfigurationHeaders{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationHeaders)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationHeaders)(ptr) = MonitorSpecScriptConfigurationHeaders{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationIgnoredErrorCodesCodec struct {
}

func (MonitorSpecScriptConfigurationIgnoredErrorCodesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) == nil
}

func (MonitorSpecScriptConfigurationIgnoredErrorCodesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr)
	var objs []MonitorSpecScriptConfigurationIgnoredErrorCodes
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationIgnoredErrorCodes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationIgnoredErrorCodes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationIgnoredErrorCodesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) = MonitorSpecScriptConfigurationIgnoredErrorCodes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationIgnoredErrorCodes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationIgnoredErrorCodes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) = MonitorSpecScriptConfigurationIgnoredErrorCodes{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) = MonitorSpecScriptConfigurationIgnoredErrorCodes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationIgnoredErrorCodes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationIgnoredErrorCodes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationIgnoredErrorCodes)(ptr) = MonitorSpecScriptConfigurationIgnoredErrorCodes{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationIgnoredErrorCodes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationJavascriptSetttingsCodec struct {
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) == nil
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr)
	var objs []MonitorSpecScriptConfigurationJavascriptSetttings
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationJavascriptSetttings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationJavascriptSetttings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttings{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationJavascriptSetttings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationJavascriptSetttings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttings{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationJavascriptSetttings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettingsCodec struct {
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) == nil
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr)
	var objs []MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationJavascriptSetttingsTimeoutSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsCodec struct {
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) == nil
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr)
	var objs []MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions
	if obj != nil {
		objs = []MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}
			}
		} else {
			*(*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) = obj
		} else {
			*(*MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions)(ptr) = MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptConfigurationJavascriptSetttingsVisuallyCompleteOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsCodec struct {
}

func (MonitorSpecScriptEventsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEvents)(ptr) == nil
}

func (MonitorSpecScriptEventsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEvents)(ptr)
	var objs []MonitorSpecScriptEvents
	if obj != nil {
		objs = []MonitorSpecScriptEvents{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEvents{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEvents)(ptr) = MonitorSpecScriptEvents{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEvents

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEvents{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEvents)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEvents)(ptr) = MonitorSpecScriptEvents{}
			}
		} else {
			*(*MonitorSpecScriptEvents)(ptr) = MonitorSpecScriptEvents{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEvents

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEvents{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEvents)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEvents)(ptr) = MonitorSpecScriptEvents{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEvents", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickCodec struct {
}

func (MonitorSpecScriptEventsEventClickCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClick)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClick)(ptr)
	var objs []MonitorSpecScriptEventsEventClick
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClick{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClick{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClick)(ptr) = MonitorSpecScriptEventsEventClick{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClick

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClick{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClick)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClick)(ptr) = MonitorSpecScriptEventsEventClick{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClick)(ptr) = MonitorSpecScriptEventsEventClick{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClick

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClick{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClick)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClick)(ptr) = MonitorSpecScriptEventsEventClick{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClick", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickTargetCodec struct {
}

func (MonitorSpecScriptEventsEventClickTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClickTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClickTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventClickTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClickTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClickTarget)(ptr) = MonitorSpecScriptEventsEventClickTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClickTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClickTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClickTarget)(ptr) = MonitorSpecScriptEventsEventClickTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClickTarget)(ptr) = MonitorSpecScriptEventsEventClickTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClickTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClickTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClickTarget)(ptr) = MonitorSpecScriptEventsEventClickTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClickTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickValidateCodec struct {
}

func (MonitorSpecScriptEventsEventClickValidateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClickValidate)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickValidateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClickValidate)(ptr)
	var objs []MonitorSpecScriptEventsEventClickValidate
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClickValidate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickValidateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClickValidate)(ptr) = MonitorSpecScriptEventsEventClickValidate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClickValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClickValidate)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClickValidate)(ptr) = MonitorSpecScriptEventsEventClickValidate{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClickValidate)(ptr) = MonitorSpecScriptEventsEventClickValidate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClickValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClickValidate)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClickValidate)(ptr) = MonitorSpecScriptEventsEventClickValidate{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClickValidate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickValidateValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventClickValidateValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickValidateValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventClickValidateValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClickValidateValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidateValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickValidateValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickValidateValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClickValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickValidateValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickValidateValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClickValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClickValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickValidateValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClickValidateValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickWaitCodec struct {
}

func (MonitorSpecScriptEventsEventClickWaitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClickWait)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickWaitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClickWait)(ptr)
	var objs []MonitorSpecScriptEventsEventClickWait
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClickWait{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWait{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickWaitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClickWait)(ptr) = MonitorSpecScriptEventsEventClickWait{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClickWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClickWait)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClickWait)(ptr) = MonitorSpecScriptEventsEventClickWait{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClickWait)(ptr) = MonitorSpecScriptEventsEventClickWait{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClickWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClickWait)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClickWait)(ptr) = MonitorSpecScriptEventsEventClickWait{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClickWait", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickWaitValidationCodec struct {
}

func (MonitorSpecScriptEventsEventClickWaitValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickWaitValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClickWaitValidation)(ptr)
	var objs []MonitorSpecScriptEventsEventClickWaitValidation
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClickWaitValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickWaitValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) = MonitorSpecScriptEventsEventClickWaitValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClickWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) = MonitorSpecScriptEventsEventClickWaitValidation{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) = MonitorSpecScriptEventsEventClickWaitValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClickWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClickWaitValidation)(ptr) = MonitorSpecScriptEventsEventClickWaitValidation{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClickWaitValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventClickWaitValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventClickWaitValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventClickWaitValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventClickWaitValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventClickWaitValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventClickWaitValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickWaitValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventClickWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickWaitValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickWaitValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventClickWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventClickWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventClickWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventClickWaitValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventClickWaitValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventCookieCodec struct {
}

func (MonitorSpecScriptEventsEventCookieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventCookie)(ptr) == nil
}

func (MonitorSpecScriptEventsEventCookieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventCookie)(ptr)
	var objs []MonitorSpecScriptEventsEventCookie
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventCookie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventCookieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventCookie)(ptr) = MonitorSpecScriptEventsEventCookie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventCookie)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventCookie)(ptr) = MonitorSpecScriptEventsEventCookie{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventCookie)(ptr) = MonitorSpecScriptEventsEventCookie{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventCookie)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventCookie)(ptr) = MonitorSpecScriptEventsEventCookie{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventCookie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventCookieCookiesCodec struct {
}

func (MonitorSpecScriptEventsEventCookieCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventCookieCookies)(ptr) == nil
}

func (MonitorSpecScriptEventsEventCookieCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventCookieCookies)(ptr)
	var objs []MonitorSpecScriptEventsEventCookieCookies
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventCookieCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookieCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventCookieCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventCookieCookies)(ptr) = MonitorSpecScriptEventsEventCookieCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventCookieCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookieCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventCookieCookies)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventCookieCookies)(ptr) = MonitorSpecScriptEventsEventCookieCookies{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventCookieCookies)(ptr) = MonitorSpecScriptEventsEventCookieCookies{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventCookieCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventCookieCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventCookieCookies)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventCookieCookies)(ptr) = MonitorSpecScriptEventsEventCookieCookies{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventCookieCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventJavascriptCodec struct {
}

func (MonitorSpecScriptEventsEventJavascriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventJavascript)(ptr) == nil
}

func (MonitorSpecScriptEventsEventJavascriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventJavascript)(ptr)
	var objs []MonitorSpecScriptEventsEventJavascript
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventJavascript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventJavascriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventJavascript)(ptr) = MonitorSpecScriptEventsEventJavascript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventJavascript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventJavascript)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventJavascript)(ptr) = MonitorSpecScriptEventsEventJavascript{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventJavascript)(ptr) = MonitorSpecScriptEventsEventJavascript{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventJavascript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventJavascript)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventJavascript)(ptr) = MonitorSpecScriptEventsEventJavascript{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventJavascript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventJavascriptTargetCodec struct {
}

func (MonitorSpecScriptEventsEventJavascriptTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventJavascriptTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventJavascriptTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventJavascriptTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventJavascriptTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventJavascriptTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventJavascriptTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventJavascriptTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventJavascriptTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventJavascriptWaitCodec struct {
}

func (MonitorSpecScriptEventsEventJavascriptWaitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventJavascriptWait)(ptr) == nil
}

func (MonitorSpecScriptEventsEventJavascriptWaitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventJavascriptWait)(ptr)
	var objs []MonitorSpecScriptEventsEventJavascriptWait
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventJavascriptWait{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWait{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventJavascriptWaitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventJavascriptWait)(ptr) = MonitorSpecScriptEventsEventJavascriptWait{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventJavascriptWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventJavascriptWait)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventJavascriptWait)(ptr) = MonitorSpecScriptEventsEventJavascriptWait{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptWait)(ptr) = MonitorSpecScriptEventsEventJavascriptWait{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventJavascriptWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventJavascriptWait)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptWait)(ptr) = MonitorSpecScriptEventsEventJavascriptWait{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventJavascriptWait", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventJavascriptWaitValidationCodec struct {
}

func (MonitorSpecScriptEventsEventJavascriptWaitValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) == nil
}

func (MonitorSpecScriptEventsEventJavascriptWaitValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr)
	var objs []MonitorSpecScriptEventsEventJavascriptWaitValidation
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventJavascriptWaitValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventJavascriptWaitValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventJavascriptWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidation{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventJavascriptWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptWaitValidation)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidation{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventJavascriptWaitValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventJavascriptWaitValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventJavascriptWaitValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventJavascriptWaitValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventJavascriptWaitValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventJavascriptWaitValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventJavascriptWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventJavascriptWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventJavascriptWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventJavascriptWaitValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventJavascriptWaitValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokes)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokes)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokes
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokes)(ptr) = MonitorSpecScriptEventsEventKeystrokes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokes)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokes)(ptr) = MonitorSpecScriptEventsEventKeystrokes{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokes)(ptr) = MonitorSpecScriptEventsEventKeystrokes{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokes)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokes)(ptr) = MonitorSpecScriptEventsEventKeystrokes{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesTargetCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokesTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokesTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokesTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokesTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokesTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesValidateCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesValidateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesValidateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokesValidate
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokesValidate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesValidateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokesValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidate{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokesValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesValidate)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidate{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokesValidate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesValidateValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokesValidateValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesWaitCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesWaitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesWaitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokesWait)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokesWait
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokesWait{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWait{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesWaitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) = MonitorSpecScriptEventsEventKeystrokesWait{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokesWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) = MonitorSpecScriptEventsEventKeystrokesWait{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) = MonitorSpecScriptEventsEventKeystrokesWait{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokesWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesWait)(ptr) = MonitorSpecScriptEventsEventKeystrokesWait{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokesWait", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesWaitValidationCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesWaitValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesWaitValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokesWaitValidation
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokesWaitValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesWaitValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokesWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidation{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokesWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesWaitValidation)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidation{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokesWaitValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventKeystrokesWaitValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventKeystrokesWaitValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigate)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigate)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigate
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigate)(ptr) = MonitorSpecScriptEventsEventNavigate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigate)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigate)(ptr) = MonitorSpecScriptEventsEventNavigate{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigate)(ptr) = MonitorSpecScriptEventsEventNavigate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigate)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigate)(ptr) = MonitorSpecScriptEventsEventNavigate{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateAuthenticationCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateAuthentication
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) = MonitorSpecScriptEventsEventNavigateAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) = MonitorSpecScriptEventsEventNavigateAuthentication{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) = MonitorSpecScriptEventsEventNavigateAuthentication{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateAuthentication)(ptr) = MonitorSpecScriptEventsEventNavigateAuthentication{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateTargetCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateTarget)(ptr) = MonitorSpecScriptEventsEventNavigateTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateTarget)(ptr) = MonitorSpecScriptEventsEventNavigateTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateTarget)(ptr) = MonitorSpecScriptEventsEventNavigateTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateTarget)(ptr) = MonitorSpecScriptEventsEventNavigateTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateValidateCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateValidateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateValidate)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateValidateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateValidate)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateValidate
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateValidate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateValidateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateValidate)(ptr) = MonitorSpecScriptEventsEventNavigateValidate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateValidate)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateValidate)(ptr) = MonitorSpecScriptEventsEventNavigateValidate{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateValidate)(ptr) = MonitorSpecScriptEventsEventNavigateValidate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateValidate)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateValidate)(ptr) = MonitorSpecScriptEventsEventNavigateValidate{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateValidate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateValidateValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateValidateValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateValidateValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateValidateValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateValidateValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateValidateValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateValidateValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateValidateValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateWaitCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateWaitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateWait)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateWaitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateWait)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateWait
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateWait{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWait{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateWaitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateWait)(ptr) = MonitorSpecScriptEventsEventNavigateWait{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateWait)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateWait)(ptr) = MonitorSpecScriptEventsEventNavigateWait{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateWait)(ptr) = MonitorSpecScriptEventsEventNavigateWait{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateWait)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateWait)(ptr) = MonitorSpecScriptEventsEventNavigateWait{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateWait", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateWaitValidationCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateWaitValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateWaitValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateWaitValidation
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateWaitValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateWaitValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidation{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateWaitValidation)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidation{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateWaitValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventNavigateWaitValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventNavigateWaitValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventNavigateWaitValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventNavigateWaitValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventNavigateWaitValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventNavigateWaitValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventNavigateWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventNavigateWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventNavigateWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventNavigateWaitValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventNavigateWaitValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectCodec struct {
}

func (MonitorSpecScriptEventsEventSelectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelect)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelect)(ptr)
	var objs []MonitorSpecScriptEventsEventSelect
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelect)(ptr) = MonitorSpecScriptEventsEventSelect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelect)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelect)(ptr) = MonitorSpecScriptEventsEventSelect{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelect)(ptr) = MonitorSpecScriptEventsEventSelect{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelect)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelect)(ptr) = MonitorSpecScriptEventsEventSelect{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectSelectionsCodec struct {
}

func (MonitorSpecScriptEventsEventSelectSelectionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectSelections)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectSelectionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectSelections)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectSelections
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectSelections{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectSelections{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectSelectionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectSelections)(ptr) = MonitorSpecScriptEventsEventSelectSelections{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectSelections

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectSelections{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectSelections)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectSelections)(ptr) = MonitorSpecScriptEventsEventSelectSelections{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectSelections)(ptr) = MonitorSpecScriptEventsEventSelectSelections{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectSelections

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectSelections{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectSelections)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectSelections)(ptr) = MonitorSpecScriptEventsEventSelectSelections{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectSelections", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectTargetCodec struct {
}

func (MonitorSpecScriptEventsEventSelectTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectTarget)(ptr) = MonitorSpecScriptEventsEventSelectTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectTarget)(ptr) = MonitorSpecScriptEventsEventSelectTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectTarget)(ptr) = MonitorSpecScriptEventsEventSelectTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectTarget)(ptr) = MonitorSpecScriptEventsEventSelectTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectValidateCodec struct {
}

func (MonitorSpecScriptEventsEventSelectValidateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectValidate)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectValidateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectValidate)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectValidate
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectValidate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectValidateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectValidate)(ptr) = MonitorSpecScriptEventsEventSelectValidate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectValidate)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectValidate)(ptr) = MonitorSpecScriptEventsEventSelectValidate{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectValidate)(ptr) = MonitorSpecScriptEventsEventSelectValidate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectValidate)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectValidate)(ptr) = MonitorSpecScriptEventsEventSelectValidate{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectValidate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectValidateValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventSelectValidateValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectValidateValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectValidateValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectValidateValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidateValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectValidateValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectValidateValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectValidateValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectValidateValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectValidateValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectValidateValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectWaitCodec struct {
}

func (MonitorSpecScriptEventsEventSelectWaitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectWait)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectWaitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectWait)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectWait
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectWait{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWait{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectWaitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectWait)(ptr) = MonitorSpecScriptEventsEventSelectWait{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectWait)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectWait)(ptr) = MonitorSpecScriptEventsEventSelectWait{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectWait)(ptr) = MonitorSpecScriptEventsEventSelectWait{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectWait)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectWait)(ptr) = MonitorSpecScriptEventsEventSelectWait{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectWait", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectWaitValidationCodec struct {
}

func (MonitorSpecScriptEventsEventSelectWaitValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectWaitValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectWaitValidation
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectWaitValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectWaitValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidation{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectWaitValidation)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidation{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectWaitValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventSelectWaitValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventSelectWaitValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventSelectWaitValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventSelectWaitValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventSelectWaitValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventSelectWaitValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventSelectWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventSelectWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventSelectWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventSelectWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventSelectWaitValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventSelectWaitValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapCodec struct {
}

func (MonitorSpecScriptEventsEventTapCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTap)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTap)(ptr)
	var objs []MonitorSpecScriptEventsEventTap
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTap{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTap{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTap)(ptr) = MonitorSpecScriptEventsEventTap{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTap)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTap)(ptr) = MonitorSpecScriptEventsEventTap{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTap)(ptr) = MonitorSpecScriptEventsEventTap{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTap)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTap)(ptr) = MonitorSpecScriptEventsEventTap{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTap", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapTargetCodec struct {
}

func (MonitorSpecScriptEventsEventTapTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTapTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTapTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventTapTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTapTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTapTarget)(ptr) = MonitorSpecScriptEventsEventTapTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTapTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTapTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTapTarget)(ptr) = MonitorSpecScriptEventsEventTapTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTapTarget)(ptr) = MonitorSpecScriptEventsEventTapTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTapTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTapTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTapTarget)(ptr) = MonitorSpecScriptEventsEventTapTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTapTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapValidateCodec struct {
}

func (MonitorSpecScriptEventsEventTapValidateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTapValidate)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapValidateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTapValidate)(ptr)
	var objs []MonitorSpecScriptEventsEventTapValidate
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTapValidate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapValidateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTapValidate)(ptr) = MonitorSpecScriptEventsEventTapValidate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTapValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTapValidate)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTapValidate)(ptr) = MonitorSpecScriptEventsEventTapValidate{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTapValidate)(ptr) = MonitorSpecScriptEventsEventTapValidate{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTapValidate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTapValidate)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTapValidate)(ptr) = MonitorSpecScriptEventsEventTapValidate{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTapValidate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapValidateValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventTapValidateValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapValidateValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventTapValidateValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTapValidateValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidateValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapValidateValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapValidateValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTapValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapValidateValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapValidateValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTapValidateValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapValidateValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTapValidateValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapValidateValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTapValidateValidationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapWaitCodec struct {
}

func (MonitorSpecScriptEventsEventTapWaitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTapWait)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapWaitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTapWait)(ptr)
	var objs []MonitorSpecScriptEventsEventTapWait
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTapWait{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWait{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapWaitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTapWait)(ptr) = MonitorSpecScriptEventsEventTapWait{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTapWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTapWait)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTapWait)(ptr) = MonitorSpecScriptEventsEventTapWait{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTapWait)(ptr) = MonitorSpecScriptEventsEventTapWait{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTapWait

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWait{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTapWait)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTapWait)(ptr) = MonitorSpecScriptEventsEventTapWait{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTapWait", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapWaitValidationCodec struct {
}

func (MonitorSpecScriptEventsEventTapWaitValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapWaitValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTapWaitValidation)(ptr)
	var objs []MonitorSpecScriptEventsEventTapWaitValidation
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTapWaitValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapWaitValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) = MonitorSpecScriptEventsEventTapWaitValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTapWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) = MonitorSpecScriptEventsEventTapWaitValidation{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) = MonitorSpecScriptEventsEventTapWaitValidation{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTapWaitValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTapWaitValidation)(ptr) = MonitorSpecScriptEventsEventTapWaitValidation{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTapWaitValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MonitorSpecScriptEventsEventTapWaitValidationTargetCodec struct {
}

func (MonitorSpecScriptEventsEventTapWaitValidationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) == nil
}

func (MonitorSpecScriptEventsEventTapWaitValidationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr)
	var objs []MonitorSpecScriptEventsEventTapWaitValidationTarget
	if obj != nil {
		objs = []MonitorSpecScriptEventsEventTapWaitValidationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MonitorSpecScriptEventsEventTapWaitValidationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapWaitValidationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MonitorSpecScriptEventsEventTapWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) = objs[0]
			} else {
				*(*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapWaitValidationTarget{}
			}
		} else {
			*(*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapWaitValidationTarget{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MonitorSpecScriptEventsEventTapWaitValidationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MonitorSpecScriptEventsEventTapWaitValidationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) = obj
		} else {
			*(*MonitorSpecScriptEventsEventTapWaitValidationTarget)(ptr) = MonitorSpecScriptEventsEventTapWaitValidationTarget{}
		}
	default:
		iter.ReportError("decode MonitorSpecScriptEventsEventTapWaitValidationTarget", "unexpected JSON type")
	}
}
